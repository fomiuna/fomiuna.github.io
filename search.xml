<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《86-不存在的战区》——比起轻小说更像普通文学，很值得一读的轻小说</title>
    <url>/2021/01/18/EightySix_comment_s/</url>
    <content><![CDATA[<h2 id="惯例的开场白">惯例的开场白</h2>
<p>  说来也巧，虽然很早就知道这部作品但一直没读过，因为轻之国度的答题外加听说 4 月份动画化了，外加近期被《弱势角色友崎君》恶心得够呛<em>（说是要继续看完，但终究还是失去了动力）</em>，所以才打算在动画化之前把这系列作品读一遍。读完获得“电击小说大赏”的第一卷，不禁感慨电击文库的作品的含金量比 GAGAGA 文库不知道高多少!</p>
<a id="more"></a>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/EightySix_1.jpg" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>小说第一卷的封面，女主芙拉迪蕾娜·米利泽和男主辛耶·诺赞伸手相望还以为这又是一卷快速拉郎配的作品，看完才知道这俩人关系就没多深，话说这算不算是封面欺诈？另外，女主瞩目的吊带袜是因为作者自己的 XP，能在后记第一句就表明，这作者也蛮猛的</em></td>
</tr>
</tbody>
</table>
<!-- ![小说第一卷的封面，女主芙拉迪蕾娜·米利泽和男主辛耶·诺赞伸手相望还以为这又是一卷快速拉郎配的作品，看完才知道这俩人关系就没多深，话说这算不算是封面欺诈？另外，女主瞩目的吊带袜是因为作者自己的XP，能在后记第一句就表明，这作者也蛮猛的](EightySix 1.jpg) -->
<h2 id="对于第一卷本身的感想">对于第一卷本身的感想</h2>
<p>  作为故事开头的第一卷，世界观宏大，设定出色丰富，尤其是 I-IV 老师（代表作《Aldnoah. Zero》的火星军，《异度之刃2》的机设）负责的机设，反派的设计颇有一种从《异度之刃》片场走过来的错觉<em>（明明负责的是 2 的机设）</em>；剧情内容涉及政治制度、人种问题、特殊环境下的亲情、战友情等，范围面广，并且在当下 acg 作品中也比较有深度；展开精彩紧凑，所有情节紧扣核心，毫不拖泥带水，甚至连轻小说必有的男女感情培养都是蜻蜓点水；人设和塑造完全为了剧情服务，不会让人完全的接受不能<em>（大概，一丁点，没有内涵弱角友崎的意识）</em>，重要的角色该死就死，有老动画内味儿了嗷。至于到底讲了什么，我觉得以我的语文水平很难在不丢失精华的条件下，概括出这作品的梗概<em>（还有防剧透的原因，至于是不是懒，就请大家各自体会了（笑））</em>，更建议感兴趣的朋友可以读一下，反正一卷也就3个小时不到就能看完，条件允许的话我甚至还可以出借实体书（天闻角川的简体一本 25 块左右，自己购买也是可以的，<em>天闻角川打钱吧！</em>）。</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/EightySix_2.jpg" width="70%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>小说剧情最后的互相敬礼，明明剧情上说女主经历了很多，还被冠以“女王”之名，但看起来还是和原来的无知少女一样，不知道剧情的还以为情侣久违地相见呢？我个人倒是很喜欢这张图，实体书是分页设计就很是残念</em></td>
</tr>
</tbody>
</table>
<!-- ![小说剧情最后的互相敬礼，明明剧情上说女主经历了很多，还被冠以“女王”之名，但看起来还是和原来的无知少女一样，不知道剧情的还以为情侣久违地相见呢？我个人倒是很喜欢这张图，实体书是分页设计就很是残念](EightySix 2.jpg) -->
<p>  这作品的优点很多，但缺点其实也比较明显。<strong>故事上</strong>因为篇幅限制导致大多数剧情其实一两句话就交代了，致使很难深刻把握人物感情上的变化，大多数东西都停留在纸面上，当然像我这种 acg 入脑，脑补能力贼强倒是能 get 到一些点。<strong>叙事上</strong>比起传统的一个或者两个固定视角的做法，视角切换过于频繁，外加日语”不喜欢加主语“的习惯，有时候到底是谁说的谁想的，都很难分辨清楚；你说这是群像剧呢？最后人都没剩下几个。你说这是主次分明的剧呢？视点隔三岔五换来换去的看得真让人眼花缭乱。这个时候反倒是让我不得不佩服成田良悟的笔力了<em>（代表作《永生之酒》《无头骑士异闻录》）</em>。除外就是<strong>人设上</strong>太服务剧情（指比起让人物增添受欢迎的元素，更着重剧情上的作用）导致每个出场人物不够饱满。主角队到剧情 2/3 处人名还没记住，就死了只剩下 5 个。女主姬友的存在感让我不禁担心后面几卷真的会出现吗，明明还有男主青梅竹马的 FLAG 。作为第 1 卷核心塑造的女主因为缺乏对她能力的详细展示，读下来花瓶感相当重，并且因为哭的次数太多（短短一本哭了至少 3 次），设置人设上还增添了一份负面色彩（虽然满符合剧情设定就是了），最后读者了解到女主因为和”先锋队“接触之后彻底改变了的时候故事就结束了。而男主辛又感觉晦涩难懂了很多，作为轻小说这种娱乐作品的男主，我对他的印象就是能冷静应对各种状况，一人能在战场上无双的老兵外加家暴 PTSD；可能是我只读了一遍且读得比较快的原因，男主很多时候的感情表现老实说不容易像女主那般浅显易懂，比如为啥跟自己老哥对决还能笑，一边能实现自己”送葬“的期望，一边享受战斗本身？这种令我理解费劲的地方还挺多的。</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/EightySix_3.jpg" width="70%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>小说彩页的主角队介绍，这里的人除了凯耶之外，几句话就交代了死亡了，甚至大多数角色的死亡只体现在数字上，活脱脱的死亡名单留影 wwww，不禁让人想象动画播出的时候观众来猜死亡顺序和幸存人员的场景了，再恶意一点，没准动画每集最后官方都会那张合影来显示幸存人员，和《弹丸论破》一样在死亡人员头上打× wwwww</em></td>
</tr>
</tbody>
</table>
<!-- ![小说彩页的主角队介绍，这里的人除了凯耶之外，几句话就交代了死亡了，甚至大多数角色的死亡只体现在数字上，活脱脱的死亡名单留影 wwww，不禁让人想象动画播出的时候观众来猜死亡顺序和幸存人员的场景了，再恶意一点，没准动画每集最后官方都会那张合影来显示幸存人员，和《弹丸论破》一样在死亡人员头上打× wwwww](EightySix 3.jpg) -->
<p>  坏话说了那么多<em>（作品粉丝收起了自己的 40m 长刀）</em>，单纯是因为以上是基于一个故事完整的短篇小说来看的，但实际上这些缺点瑕不掩瑜，作为大奖作品足够优秀了，故事依然十分有趣。如果是作为轻小说的第一卷来看的话，反倒是惊艳得不禁让人担心后续能保持这样得质量吗？</p>
<h2 id="以动画改编的胡思乱想作为结尾">以动画改编的胡思乱想作为结尾</h2>
<p>  其实就这部分我原本想从自己看过的很多作品对比来展开来写的。想想自己也不是什么业内人士，平时也没有什么专业的知识储备和观点，这样大谈特谈还没出改编动画真的好吗？不过，看 PV 及其评论的时候呼声很高的“如果只做第一卷的内容，这部动画必定是霸权了”之类的云云，让我忍不住想要胡思乱想。如果这作品做第一卷的内容，我觉得这动画可能注定不会普遍让大多数人接受。不是说题材小众，设定太复杂了之类的，说白了就是这个动画的卖相一般，卖点太少：</p>
<ul>
<li>最容易吸引眼球、秀制作秀演出的战斗少：除开序章，第一卷能拿得出手也就两场；</li>
<li>人设太着重服务剧情：大多人数形象不够立体，较为立体的女主不容易快速获得观众好感，当然会因为女主外表而“三观跟着五感走”的就另当别论了；</li>
<li>所涉及的题材太敏感：设定上的政治指向性比高达 UC 纪元系列都明显，很容易与现实相结合然后因为不合理的地方被声讨，而轻小说这种娱乐作品的不合理本来就是必然的。</li>
</ul>
<p>  诸上原因，让我觉得这一卷的内容想要做的十分精彩，要么就得加入后几卷的一些剧情来丰富第一卷的在剧情上节奏的不足，比如《刀剑神域》，SAO 的部分其实包含了有第一卷的主线和第二卷的各种短篇<em>（看过原作的应该都知道）</em>，就剧情完成度上，我个人更喜欢 ALO 部分的剧情：桐亚深厚的感情，莉法的感情纠结，同时”剧情到了，氛围到了，BGM 起，唯心挂就来了“<em>（如果没有最后川原砾的恶趣味的话）</em>。或者原创原剧情中原本一笔带过的部分来调整原作剧情节奏的不足，如《Fate/Zero》前期就加入了各种打斗冲淡了剧情本身无聊。如果是前者，就必须压缩一定的剧情来给后面的内容腾出空间，删去一些第一卷中的一些精华部分，届时意见最大的是原作粉丝吧<em>（笑）</em>；如果是后者，就得相当考验动画制作组的决策和发挥水平了，索性就让原作者来参与动画制作吧，就像《路人女主的养成方法》，《我的妹妹不可能这么可爱》一样，没准还能抽到上上签做成《樱花庄的宠物女孩》这种标杆级轻改呢？<em>（然后被政治敏感埋葬在黑暗中 wwwww）</em></p>
<p>  如果不相信“只做第一卷的动画内容质量一般”的话，我强烈推荐看看《零之魔法书》、《有顶天家族》、《我想要吃掉你的胰脏》等原作较优秀的改编动画，我作为粉丝个人还是很买账，但具体观感见仁见智吧，毕竟都是没多少人讨论的冷门动画<em>（安利的难度就不说了……）</em>，更何况“胰脏”还是大约 TV 六集容量的动画电影。人设完成为剧情服务的优秀作品我推荐《A.I.C.O. -Incarnation》，网飞投资的原创，最后扑街得连作品的影子都见不到了，更别说讨论了。其实《re：从零开始的异世界》前期就有这种“人设服务于剧情“的感觉，毕竟作为女主的艾米莉亚在人气方面被中期因为作者感情问题暴走而塑造的雷姆碾压，并且BD效量不佳啊……话说回来，同样的长直白发，前期思想简单的，突然觉得 86 就算只做一卷，女主芙蕾人气应该也不会低就是了。</p>
<p>  不过动画究竟怎么样，还是得 4 月开播之后见分晓吧，我个人还是很期待的。PV 和 op 试听也循环了好几遍，配乐还是那个泽野味儿。这次算是我篇幅最短的博文了，总之，小说我还是十分推荐的，很值得一读。<em>（稀里糊涂也算是把坑填上了，双重意义上的填坑）</em></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>lightnovel</tag>
      </tags>
  </entry>
  <entry>
    <title>Some solutions to FML Ed2</title>
    <url>/2021/06/30/FML_sol_z/</url>
    <content><![CDATA[<p>  最近闲下来时在翻 Mohri 的 <a href="https://cs.nyu.edu/~mohri/mlbook/">Foundations of Machine Learning</a>(Second Edition). 网上能找到的题解太少了, 自己就边看边做了一些, 大概以后还会继续更(?</p>
<a id="more"></a>
<p>  这里把书目录中的主要内容列一下:</p>
<blockquote>
<ol type="1">
<li>Introduction</li>
<li>The PAC Learning Framework</li>
<li>Rademacher Complexity and VC-Dimension</li>
<li>Model Selection</li>
<li>Support Vector Machine</li>
<li>Kernel Methods</li>
<li>Boosting</li>
<li>On-Line Learning</li>
<li>Multi-Class Classification</li>
<li>Ranking</li>
<li>Regression</li>
<li>Maximum Entropy Models</li>
<li>Conditional Maximum Entropy Models</li>
<li>Algorithmic Stability</li>
<li>Dimensionality Reduction</li>
<li>Learning Automata and Languages</li>
<li>Reinforcement Learning</li>
</ol>
</blockquote>
<p><br></p>
<p><div class="pdfobject-container" data-target="/notes1.pdf" data-height="1000px"></div> <!-- <object data="/files/notes.pdf" type="application/pdf" width="100%" height="877px"> --></p>
<p><br></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>study notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Look Back and Step Forward</title>
    <url>/2021/07/20/LB_com_z/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/lb_fanart.png" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>来自推特 愛須冷蔵（あいすれいぞう）<span class="citation" data-cites="icereizou">@icereizou</span> 老师的 fanart，几乎是和作品同步上线。据其称是自己也帮忙参与了这部短篇的部分工作。</em></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>  7 月 19 日少年 jump+ 上线了藤本树的新作《ルックバック》，这是一部 143 页的短篇漫画。在看之前凭着自己对藤本的印象，我没想到他对于这种青春物语类的作品也能处理得如此之好。作品讲述了藤野和京本从小学因画漫画相遇之后发生的一系列故事：从单方面竞争到一起合作，再到两人分离直至意外降临。虽说是十分老套的剧情，但藤本发挥出了他特有的讲故事的能力，通过“look back”将整个作品串了起来——故事线在空中舞动，但线的另一端被稳稳地握在藤本的手中。 数分钟内一部短篇翻完，走过了主人公十几年的岁月，感觉就像看电影一样令人沉浸其中。<br />
  回顾整个作品，“look back”当然兼具字面意义上的“看后面”以及作为引申义的“看过去”：</p>
<ul>
<li>全篇有大量的让读者从背后看着主人公画画的镜头，藤本用这种手段体现了时光的流逝和人物的决意</li>
<li>藤野看着京本的背后，是要追赶超越；京本看着藤野的背后，是憧憬向往</li>
<li>藤本为我们构想了一个藤野和京本小学时没有相遇的剧本。幼年时的京本回头看到撕碎的四格漫画，自然而然引出后来想象中的世界；藤野被由风吹下的四格漫画拉回现实，回头看到自己在京本背后签下的名字，陷入了两人的回忆</li>
</ul>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/lb_1.jpg" width="60%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>全篇最精彩的几个镜头之一。在 jump 官网上二刷的时候，从上一页藤野踏着步子的蓄力到这连续两页排版的起舞，转换是非常让人震撼的。初次在贴吧上看到的熟肉削弱了这种感觉。</em></td>
</tr>
</tbody>
</table>
<p>  从这部作品中我们能看到藤野的转变：从最初带有一点自满到被京本第一次打击，然后被激起对抗心理的藤野所苦练的结果还是败给了京本的高超画技。藤野开始慢慢放弃，到毕业时在机缘巧合之下与京本相遇并得知了她是自己的粉丝，受到鼓舞的藤野重拾画笔，与京本合作开始再次画了起来——两人就这样互相追逐着、扶持着。就像很多人说的那样，这部有着伪自传性质的漫画是写给所有创作者的情书。当藤野问京本，画漫画明明并不开心，经常画一整天也画不完，麻烦不断，为什么你还在画呢？——我相信接下来京本的笑容所给出的回答是，“因为有人喜欢”。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/dlbi.jpg" width="70%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>“开头+标题+结尾”构成的 neta。</em></td>
</tr>
</tbody>
</table>
<p>  另外值得提到的就是作品上线时适逢京都动画纵火案遇难者二周年追悼式，并且在这部漫画中也出现了与纵火犯类似的臆想症犯人，再结合藤本树作为京都动画粉丝的身份，其用意就基本明了。漫画开头的“don't”和结尾处的“in anger”字样，配合上标题的名字 neta 了 Oasis 乐队的歌曲 Don't Look Back in Anger。而这首歌如其名字，告诉人们不要总停留在过去而是向前看。藤野失去京本后停下了手中的画笔，开始责怪自己不该把京本带出房间，甚至自己就不该画画。藤本树在这里安排了一段在藤野没有把京本带出去的世界中所发生的故事。这一段可以是藤野的想象，也可以是藤本树的愿望——如果现实里真有那么一位藤野可以踹飞纵火犯的话就好了。温柔的（？）藤本树通过飘落的四格漫画指引着藤野进到了京本的房间，在这里京本对自己作品的热爱触动了藤野的内心。藤本在这里告诉我们能做到的，就是像漫画最后的藤野那样，将回忆整理好后撸起袖子重新出发。我相信藤本在这里又给出了另外一个回答：不仅是为了喜欢自己作品的人，也是为了不能再画下去的人们而画着。</p>
<p>  最后就用京都动画纵火案二周年追悼式上某遇难者家属的留言作结吧：</p>
<blockquote>
<p>あの日から<br />
雨が突然止んだ<ruby>瞬<rp>(</rp><rt>と</rt><rp>)</rp>間<rp>(</rp><rt>き</rt><rp>)</rp></ruby><br />
雲の間から光が差した<ruby>瞬<rp>(</rp><rt>と</rt><rp>)</rp>間<rp>(</rp><rt>き</rt><rp>)</rp></ruby><br />
爽やかな風が吹いた<ruby>瞬<rp>(</rp><rt>と</rt><rp>)</rp>間<rp>(</rp><rt>き</rt><rp>)</rp></ruby><br />
あなたが奇跡を起こしてくれているのでは<br />
と思ってしまいます</p>
<p>それでも会いたい<br />
ただ、ただ、会いたい<br />
あなたに会いたい</p>
</blockquote>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/lb_2.png" width="40%" style="display: inline-block" /><img src="/images/lb_3.png" width="40%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>全篇最打动我的一串镜头。失去的痛苦会在已经习惯的日常的点点滴滴中透过违和感被无限放大，我对这种含蓄的情感爆发感同身受。在上面被害者家属留言的背后，我能看到的就是一颗因被抽离了日常而想要拼命填补这种空缺的千疮百孔的内心，真的是让我破防了。</em></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>manga</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔诗四则汇总</title>
    <url>/2023/03/12/autumntospring2023_poem_s/</url>
    <content><![CDATA[<p>因为科研许久没有更新博客，于是把愚夜观近半年来写的诗进行整理做成汇总，简单地记录一下。</p>
<a id="more"></a>
<escape><br />

<table>
<tr>
<th>
《秋日独步有感》<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>
</th>
</tr>
<tr>
<td>
<p>叶黄纷飞卷珠帘，莺歌缭绕奏清弦。</p>
不见伊人伤逝者<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>，当下黄花犹少年。
</td>
</tr>
</table>
<p></escape></p>
<escape><br />

<table>
<tr>
<th>
《夜读有感告友人书》<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>
</th>
</tr>
<tr>
<td>
<p>一叶家函溢乡情，一声杜鹃<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>道归音。</p>
<p>秋风无情欲狂乱，平仲<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>寡静苦不停。</p>
<p>官渡<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>水寒诗<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>豪迈，赤壁<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>江暖<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>歌<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>酬勤。</p>
昔时凯旋孰无难，今日泪饮亦前行。
</td>
</tr>
</table>
<p></escape></p>
<escape><br />

<table>
<tr>
<th>
《春晓》<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>
</th>
</tr>
<tr>
<td>
<p>夜梦寒霜尚凝存，​晨觉莺歌始告温。</p>
<p>​窗前白梅悄复盛，​释书望外既知春。</p>
​无须挂念昨日的寒霜，无须担忧明日的春寒，​今日不享受，明日岂珍惜。
</td>
</tr>
</table>
<p></escape></p>
<escape>
<table>
<tr>
<th colspan="4">
《夜雨》<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>
</th>
</tr>
<tr>
<td>
<p>今夜的雨，</p>
<p>是昏昏灯光下的竖琴。</p>
<p>风儿撩拨出琴音，</p>
<p>娓娓道来着，</p>
这源于莎翁<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>手笔的旋律。
</td>
<td>
<p>傲慢与暴怒，</p>
<p>是前段的感情。</p>
<p>傲慢蒙蔽了他的眼睛；</p>
<p>暴怒断送了他的权力，</p>
和他幻想的幸福光阴。
</td>
<td>
<p>破灭与悔恨，</p>
<p>是后段的主题。</p>
<p>破灭宣告了他的结局，</p>
<p>悔恨唤醒了他的泪滴，</p>
和他仅有的美好回忆。
</td>
<td>
<p>风儿继续撩拨出琴音，</p>
<p>夹杂着树的啜泣，</p>
<p>和灯的叹息。</p>
<p>我静静聆听着，</p>
这源于夜雨演奏的内心。
</td>
</tr>
</table>
<p></escape></p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><span style="font-family:楷体">作于 2022 年 10 月 30 日，漫步校园触景生情，原本感叹一下物是人非，但仍然不想服老wwwww。</span><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><span style="font-family:楷体">指时间，出自《论语·子罕》：子在川上曰：“逝者如斯夫，不舍昼夜。”</span><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><span style="font-family:楷体">作于 2022 年 11 月 4 日，正值新冠疫情期间，一位师弟家中老人身体抱恙，想回家而不能。于是化用三国的两大典故出于安慰写下此诗。</span><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><span style="font-family:楷体">杜鹃亦称“不归鸟”，其叫声也称“不如归去”。</span><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><span style="font-family:楷体">银杏的别名。</span><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><span style="font-family:楷体">指官渡之战，曹操军“以少胜多”，大败袁绍。</span><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><span style="font-family:楷体">这里指曹操在官渡之战大胜之后写下的《观沧海》，但实际好像是北征乌桓之后写的。</span><a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><span style="font-family:楷体">指赤壁之战，孙刘联合”以少胜多”，大破曹军。</span><a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><span style="font-family:楷体">火烧赤壁，水当然是暖的wwwwww。</span><a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><span style="font-family:楷体">指由周瑜所作的《长河吟》。</span><a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p><span style="font-family:楷体">作于 2023 年 3 月 5 日，觉得去年的疫情（寒冬）终于过去，未来还有不知道何时会来到的倒春寒（战乱），觉得应该珍惜当下这短暂的春日，享受当下。</span><a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p><span style="font-family:楷体">作于 2023 年 3 月 11 日，写下此诗以反思自己白天的傲慢态度和最近容易动怒的表现，戒焦躁，戒焦躁，戒焦躁！</span><a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p><span style="font-family:楷体">莎士比亚的别称，后续的内容化用了莎士比亚的著名戏剧《李尔王》。</span><a href="#fnref13" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title>愚夜观随笔诗一则</title>
    <url>/2021/07/06/cpc100_poem_s/</url>
    <content><![CDATA[<h3 id="建党百年杂糅毛公作小题">《建党百年杂糅毛公作小题》</h3>
<p>苍茫大地任浮沉<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>，人间正道<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>铸今朝<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。</p>
<p>沧桑已是百年路，而今迈步<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>续风流。</p>
<a id="more"></a>
<h3 id="小注">小注</h3>
<p>  在自己“编辑”的强烈催稿下，决定把自己七月一日当天随手写的诗上传到博客上，并将自己当时写诗时的构思和想法整合起来作为小注，以便助他人理解所用。</p>
<p>  虽然我个人觉得这首随笔作浅显易懂，意思应该一读就懂；但按照惯例，还是打算先给出了这首诗的大意：不管这苍茫大地怎样盛衰兴废，只有所谓的”人间正道“才能铸就今天（的辉煌）。但这沧桑巨变终究已是百年走过的过路，所以还需要从今日迈步前行，去延续前辈的”风流“。</p>
<p>  我从初中起就很喜欢教员的诗词文章，文章逻辑清晰且富有感染力，诗词形象易懂且豪情万丈，所以平常自己构思这类抒发自己对国家盛事的高涨心情的随笔之时，总会不自觉想要取用他的诗词文章中的一些观点和意向。构思这首诗的时候索性就找了最喜欢的几首直接杂揉了起来，一来是为了在建党百年之际致敬建当初党建国的伟人们，二来是应答教员当时的一些想法，想要传达”今日的盛世，如他所愿“。现在看来，自己真的中二之气不减啊。</p>
<p>  对于这诗的最后一句的构思，我联想了相比于教员留下《忆秦娥·娄山关》的沉重，时代终究是有变化的，就算同样是面临转折的关键时期，但当下的我们不需要”从头越“的决心，更多地，则要续写辉煌。同时，也曾想过在最后取用《长沙》的“风华正茂”来作为结尾——<strong>“沧桑虽有百年路，风华不减仍正茂”</strong>，还能使得小诗整体在一定程度上压韵。后来想想随笔本就没必要严守韵律，正好自己一直对前段时间的“躺平”浪潮很反感，更多想要表达“诸多的沧桑巨变，传奇经历都已是过去，当下包括我在内的年轻人最应该去做的，就是延续教员一辈们的‘风流’，让‘数风流人物，换看今朝’仍旧是现实”的强烈愿望，所以才写成这种不符合传统绝句的模样。说来也巧，自己有这种心思的时候，并没有关心习大大在建党百年大会上讲话的具体内容；事后才知道，无论采取哪个结尾，能都和习大大讲话内容的几点不谋而和，现在倒令我私底下颇为自豪，认为自己的党性姑且不算低。</p>
<p>  最后再补充一下，我原本是不想要给自己的诗句注文的，一是觉得这种未免有些过于自恋，二是觉得诗这种用来抒情的形式，本应该任其读者理解想象的，注文反而会限制读者自己的想法和思路。催稿催得如此紧，自己手头又拿不出什么好的东西，只好添加一些注文也好水水文字。不过自己也还是有想把自己的创作想法留下的这层意愿，这么看来，自己不仅中二，还很自恋啊<em>（自嘲叹气）</em>……</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><span style="font-family:楷体">“苍茫大地”和“浮沉”取自《沁园春·长沙》的“问苍茫大地，谁主沉浮？”一句。</span><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><span style="font-family:楷体">“人间正道”和后文的“沧桑”取自《人民解放军占领南京》的“天若有情天亦老，人间正道是沧桑”一句。</span><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><span style="font-family:楷体">“今朝”和“风流”取自《沁园春·长沙》的“数风流人物，还看今朝”一句。</span><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><span style="font-family:楷体">“而今迈步”取自《忆秦娥·娄山关》的“雄关漫道真如铁，而今迈步从头越”一句。</span><a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title>学不来老师 if 线完结感想</title>
    <url>/2020/12/14/bokutachi_comment_s/</url>
    <content><![CDATA[<p>  看完了心情复杂不知道说些什么，但好歹也要说一句——恭喜学不来老师 if 线完结。<br />
<a id="more"></a>   整部作品的观感老实说很不好，无奈自己也是在 dmzj 从第一话因为画风和题材有趣追这部作品，所以耐着性子把本篇之后的所有 if 线也看完了。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/20201214_01.jpg" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>到此五个女主的结局全都有了，后续看样子还有其他计划，但按照传统武德，这里应该是完结了</em></td>
</tr>
</tbody>
</table>
<p>  作为四个 if 线中可以说人气最高呼声最好，个人觉得完全不像 if 线的老师 if 线，但就这一篇章本身来说各种可圈可点。一是比起前中期单纯的萌，越来越精湛成熟的画风。就拿卷首彩页来说，老师 if 线的封面可以说是我最喜欢的，对应了本篇老师解开过去心结的篇章的卷首彩页，只是视角不同，镜子破碎和服装的变化可以说镜子内外不同的自己终究合二为一。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/20201214_02.jpg" width="50%" style="display: inline-block" /><img src="/images/20201214_03.jpg" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>左图为本篇老师篇章出现的卷首彩页，右图为老师 if 线的卷首彩页，虽然视觉不同，但多个相同的元素很容易让人联系到一块</em></td>
</tr>
</tbody>
</table>
<p>  二是桐须老师感情的自然转变和对新背景设定和伏笔的回首上。剧情展开足够甜，同时回首了老师高中文化祭和唯我高中文化祭的伏笔，并且唯一以结婚为结尾，简直就是真女主待遇。可惜这么好的背景设定没有在本篇出现，还好麻雀虽小五脏俱全，这也足以证明了筒井老师画了这里也成长了不少。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/20201214_04.png" width="50%" style="display: inline-block" /><img src="/images/20201214_05.png" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>“惜美浪文乃，略输身材；润香理珠，稍逊人望；一代王者，唯我水希，亲妹设定排不上。”最终话这里是真的太棒了！</em></td>
</tr>
</tbody>
</table>
<p>  如果这是一篇短篇，我会相当喜欢这 9 话左右的内容，只可惜这是作为漫画《我们无法一起学习》的一个结局篇章。老师 if 线抛开了这部作品本篇所有的核心矛盾（奋斗和理想，与各个女主的感情）和伏笔另起炉灶，甚至连老师篇章的伏笔和矛盾也扔掉了，这就是我觉得不像 if 线的原因。当初看封面我以为这里会呼应本篇老师篇章的主题，继续理想与现实的讨论，但最后故事给我一种“挂羊头卖狗肉”，“牛肉面里面却放的是肋排”的蛋疼。最过分的时候本篇其他女主一个都没有登场，我估摸着就算不是老师的朋友，也算是唯我的朋友吧……算了，我认为干脆改名“我们无法一起教学”算了。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/20201214_06.png" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>老师 if 线最终话这一页前后没有其他女主登场就离谱</em></td>
</tr>
</tbody>
</table>
<p>  这一问题就滋生了更多的其他问题。最典型的就比如男主的感情塑造上。本篇我觉得老师不可能赢的原因就在于老师篇章基本都是男主角唯我刷桐须老师的好感度，而男主角自己并没有太多心动，flag 插的不够多。而 if 线一上来好感度直接拉满，摆明了一脸“劳资就是来泡老师”的态度，过于强行给人一种突兀感生硬感，甚至还有一点轻度ooc。拜托，你是来学校当老师的，不是泡老师。这一点虽然可以解释为篇幅限制，但在放弃本篇的铺垫下，在长篇漫画能出人鱼公主结局“那一天，我有了一种新的想法”的创世举措，也就只有“师从”古味直志的筒井能被原谅了吧（纯调侃，筒井大志也是外传漫画《魔法甜点师小咲》的作者）。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/20201214_07.jpg" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>《魔法甜点师小咲》的封面，我就说学不来最初的画风和伪恋就挺像的，话说筒井不会当过古味的助手吧</em></td>
</tr>
</tbody>
</table>
<p>  至于其他的问题，比如“老师为啥没变老”，“唯我你为什么这么熟练啊”，“其他女主角在哪里”等问题，我觉得会越在意越头大。说真的，如果不是我不会画画，我都想自己开始修改本篇，让这条if线看着合理一些。同样的问题在小美浪学姐 if 线也有，让我的怨念憋了很久。<br />
  总之，如果是单纯喜欢厨老师并且不太注重整体剧情的朋友，优秀的老师 if 线还是很值得一看，完全可以当成一个独立短篇来看待，不用担心本篇太长遗忘的问题；如果是更追求连续剧情发展的作品，我还是更推荐文乃 if 线，紧扣本篇剧情，虽然是老套三角关系但承上启下很自然，感情描写上也是相当优秀，唯一的缺点就是结局力度不够但符合这作品的欢乐特色也使得这条线仍是我心目中最棒的 if 线（应该没有私心，我说的）。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/20201214_08.jpg" width="50%" style="display: inline-block" /><img src="/images/20201214_09.jpg" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>左为本篇文乃篇章的卷首彩页，右为文乃 if 线的卷首彩页。讲道理，这么棒的妹子，难道还不是你喜欢的她，看文乃 if 线的理由吗？</em></td>
</tr>
</tbody>
</table>
<p>  原本想买文乃 if 线或者老师 if 线的单行本支持一下的，看到完结剧情上仍有不尽人意的地方也就算了，不过看预告感觉这作品好像还有后续……别吧，这作品到这里真的不错了，筒井老贼你快开新坑吧，把你后面练出来的本事用在一块它不香吗？</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>manga</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplus2 Primer Ed5 Reading Notes 2</title>
    <url>/2021/07/02/cplus2_noteI2_z/</url>
    <content><![CDATA[<p>Personalized notes taken while reading <a href="https://www.informit.com/store/c-plus-plus-primer-9780321714114">Cplus2 Primer Ed5</a> (C++11 standard) Part III: Tools for Class Authors.</p>
<a id="more"></a>
<h1 id="chapter-13.-copy-control">Chapter 13. Copy Control</h1>
<ul>
<li><p>Unlike the synthesized default constructor, a copy constructor is synthesized even if we define other constructors.</p></li>
<li><p>When we use direct initialization, we are asking the compiler to use ordinary function matching to select the constructor that best matches the arguments we provide. When we use copy initilization, we are asking the compiler to copy the right-hand operand into the object being created, converting that operand if necessary.</p></li>
<li>Copy initialization happens not only when we define variables using an <code>=</code>, but also when we
<ol type="1">
<li>Pass an object as an argument to a parameter of nonreference type</li>
<li>Return an object from a function that has a nonreference return type</li>
<li>Brace initialize the elements in an array or the members of an aggregate class</li>
</ol></li>
</ul>
<h1 id="chapter-14.-overloaded-operations-and-conversions">Chapter 14. Overloaded Operations and Conversions</h1>
<h1 id="chapter-15.-object-oriented-programming">Chapter 15. Object-Oriented Programming</h1>
<h1 id="chapter-16.-templates-and-generic-programming">Chapter 16. Templates and Generic Programming</h1>
]]></content>
      <categories>
        <category>学习</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>study notes</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>由某概率题引发的讨论</title>
    <url>/2021/03/19/gacha_z/</url>
    <content><![CDATA[<p>某日收到友人的一个问题, 如下<strong>问题 1</strong> 所示.</p>
<a id="more"></a>
<h2 id="问题-1">问题 1</h2>
<div class="note info no-icon"><!-- #### No icon note -->
<p>在阴阳师游戏中, 御魂有 6 个位置. 4 件不同位置的御魂可以获得套装效果.<br />
假设在一个副本内, 每次掉落一个御魂, 掉落在 6 个位置中概率相同. (只考虑一套御魂)</p>
<ol type="1">
<li>要集齐一套 4 件套, 平均需要通关几次副本?</li>
<li>如果要求 4 件套中不能有 2 号位, 平均需要通关几次副本?</li>
<li>如果要求 4 件套中必须有一件是 2 号位, 平均需要通关几次副本?</li>
</ol>
</div>
<p><strong><em>Sketch of analysis:</em></strong><br />
1. 我们设随机变量 <span class="math inline">\(X\)</span> 表示集齐一套 4 件套需要的次数. 令 <span class="math inline">\(Y_k\)</span> 表示从刚好有第 <span class="math inline">\(k-1\)</span> 种位置到刚好有第 <span class="math inline">\(k\)</span> 种位置需要通关的次数, <span class="math inline">\(k=1,2,3,4\)</span>. 则显然 <span class="math inline">\(Y_k\)</span> 服从几何分布, 我们有 <span class="math inline">\(Y_k\sim\mathrm{Geo}(\frac{7-k}{6})\)</span>. 故由 <span class="math inline">\(Y_k\)</span> 的定义可知<br />
<span class="math display">\[
        \mathbb{E}[X]=\sum_{k=1}^4\mathbb{E}[Y_k]=\sum_{k=1}^4\frac{6}{7-k}=\frac{57}{10}
    \]</span><br />
2. 类似第 1 问, 此时只需要更改几何分布的参数 <span class="math inline">\(p\)</span> 即可, 我们有 <span class="math inline">\(Y_k\sim\mathrm{Geo}(\frac{6-k}{6})\)</span>, <span class="math inline">\(k=1,2,3,4\)</span>. 可计算出结果为 <span class="math inline">\(\frac{77}{10}\)</span>.<br />
3. 对第 1 问中得到的任一套 4 件套, 2 号位在其中的概率为 <span class="math display">\[
    \binom{5}{3}\Big/\binom{6}{4} = \frac{2}{3}
\]</span> 当 2 号位不在 4 件套中时, 我们需要继续打副本直到得到 2 号位为止. 此时下一套出现 2 号位的概率占未出现位置的一半. 综上分析我们得到当要求 4 件套中必须有一件是 2 号位时平均需要通关 <span class="math display">\[
    \frac{2}{3}\times\frac{57}{10}+\frac{1}{3}\times\bigg(\frac{57}{10}+\frac{1}{2}\times\frac{6}{2}+\frac12\times\Big(\frac{6}{2}+\frac{6}{1}\Big)\bigg)=\frac{77}{10}
\]</span></p>
<p>用 MMA 模拟结果如下. <div class="tabs" id="simulation-with-mma"><ul class="nav-tabs"><li class="tab active"><a href="#simulation-with-mma-1">Q1</a></li><li class="tab"><a href="#simulation-with-mma-2">Q2</a></li><li class="tab"><a href="#simulation-with-mma-3">Q3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="simulation-with-mma-1"><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">sol1[n_] := <span class="keyword">Module</span>[&#123;i = <span class="number">0</span>, count, list, tmp&#125;,</span><br><span class="line">   <span class="keyword">Do</span>[</span><br><span class="line">    count = <span class="number">0</span>; list = <span class="keyword">ConstantArray</span>[<span class="number">0</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">While</span>[count &lt; <span class="number">4</span>,</span><br><span class="line">     tmp = <span class="keyword">RandomInteger</span>[&#123;<span class="number">1</span>, <span class="number">6</span>&#125;];</span><br><span class="line">     <span class="keyword">If</span>[list[[tmp]] == <span class="number">0</span>, list[[tmp]] = <span class="number">1</span>; count++];</span><br><span class="line">     i++],</span><br><span class="line">    &#123;loop, <span class="number">1</span>, n&#125;];</span><br><span class="line">   <span class="keyword">N</span>[i/n]];</span><br><span class="line"></span><br><span class="line">sol1[<span class="number">1000000</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">5.70032</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="simulation-with-mma-2"><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">sol2[n_] := <span class="keyword">Module</span>[&#123;i = <span class="number">0</span>, count, list, tmp&#125;,</span><br><span class="line">   <span class="keyword">Do</span>[</span><br><span class="line">    count = <span class="number">0</span>; list = <span class="keyword">ConstantArray</span>[<span class="number">0</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">While</span>[count &lt; <span class="number">4</span>,</span><br><span class="line">     tmp = <span class="keyword">RandomInteger</span>[&#123;<span class="number">1</span>, <span class="number">6</span>&#125;];</span><br><span class="line">     <span class="keyword">If</span>[tmp != <span class="number">2</span>, <span class="keyword">If</span>[list[[tmp]] == <span class="number">0</span>, list[[tmp]] = <span class="number">1</span>; count++]];</span><br><span class="line">     i++],</span><br><span class="line">    &#123;loop, <span class="number">1</span>, n&#125;];</span><br><span class="line">   <span class="keyword">N</span>[i/n]];</span><br><span class="line"></span><br><span class="line">sol2[<span class="number">1000000</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">7.69819</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="simulation-with-mma-3"><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">sol3[n_] := <span class="keyword">Module</span>[&#123;i = <span class="number">0</span>, count, list, tmp&#125;,</span><br><span class="line">   <span class="keyword">Do</span>[</span><br><span class="line">    count = <span class="number">0</span>; list = <span class="keyword">ConstantArray</span>[<span class="number">0</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">While</span>[count &lt; <span class="number">4</span> || list[[<span class="number">2</span>]] == <span class="number">0</span>,</span><br><span class="line">     tmp = <span class="keyword">RandomInteger</span>[&#123;<span class="number">1</span>, <span class="number">6</span>&#125;];</span><br><span class="line">     <span class="keyword">If</span>[list[[tmp]] == <span class="number">0</span>, list[[tmp]] = <span class="number">1</span>; count++];</span><br><span class="line">     i++],</span><br><span class="line">    &#123;loop, <span class="number">1</span>, n&#125;];</span><br><span class="line">   <span class="keyword">N</span>[i/n]];</span><br><span class="line"></span><br><span class="line">sol3[<span class="number">1000000</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">7.70398</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<p>上面这个问题稍微推广就可得到氪金抽卡问题. 其实我很早就有写点抽卡中的概率问题的想法了, 这次友人给我的问题让我有了去写的动力. 这里先考虑一个简单的问题.</p>
<h2 id="问题-2">问题 2</h2>
<div class="note info no-icon"><!-- #### No icon note -->
<p>扭蛋池中有 <span class="math inline">\(n\)</span> 种扭蛋, 设每次 gacha 都等可能地得到其中一种扭蛋一个. 若某氪金大佬想要抽齐所有扭蛋 (即每种扭蛋都至少抽出一个), 以 <span class="math inline">\(X_n\)</span> 表示该大佬需要 gacha 的次数. 讨论 <span class="math inline">\(X_n\)</span> 的概率特征.</p>
</div>
<p><strong><em>Sketch of analysis:</em></strong><br />
利用<strong>问题 1</strong> 中的方法, 把 <span class="math inline">\(X_n\)</span> 拆成 <span class="math inline">\(n\)</span> 个随机变量和 <span class="math inline">\(X_n=\sum_{k=1}^nY_k\)</span> , 其中 <span class="math inline">\(Y_k\sim\mathrm{Geo}(\frac{n-k+1}{n})\)</span> 表示从刚好有第 <span class="math inline">\(k-1\)</span> 种扭蛋到刚好有第 <span class="math inline">\(k\)</span> 种扭蛋需要抽取的次数. 容易计算其期望 <span class="math inline">\(\mathbb{E}[X_n]=nH_n\)</span>, 其中 <span class="math inline">\(H_n=\sum_{i=1}^ni^{-1}\)</span> 是第 <span class="math inline">\(n\)</span> 个调和数. 利用 <span class="math inline">\(Y_k\)</span> 之间的独立性也容易计算出方差为: <span class="math display">\[
      D[X_n]=\sum_{k=1}^nD[Y_k] = n^2\sum_{k=1}^nk^{-2}\overset{\text{(Basel&#39;s equality)}}{&lt;}\frac{\pi^2}{6}n^2
  \]</span> 另外, 由调和数的性质易得 <span class="math display">\[
    nH_n=n\log n+\gamma n+\frac12+\mathcal{O}(n^{-1})\ \Rightarrow\ \frac{X_n}{n\log n}\overset{p}{\rightarrow}1
  \]</span> 那么, <span class="math inline">\(X_n\)</span> 除掉高阶项后的渐进性是怎样的呢? 现在我们讨论 <span class="math inline">\(\lim_{n\to\infty}\frac{X_n-n\log n}{n}\)</span> 的性质. 现设 <span class="math inline">\(Z_n=\frac{X_n-nH_n}{n}\)</span>, 计算 <span class="math inline">\(Z_n\)</span> 的特征函数如下 <span class="math display">\[ 
    \begin{aligned}
    \varphi_{Z_n}(t)=&amp;\mathbb{E}[\mathrm{e}^{itZ_n}]=\mathrm{e}^{-itH_n}\mathbb{E}[\mathrm{e}^{i\frac{t}{n}X_n}]=\mathrm{e}^{-itH_n}\prod_{k=1}^n\Big(1+\frac{n}{n-k+1}\big(\mathrm{e}^{-\frac{it}{n}}-1\big)\Big)^{-1}\\ =&amp;\bigg(\prod_{k=1}^n\mathrm{e}^{\frac{it}{k}}\Big(1+\frac{n}{k}\big(\mathrm{e}^{-\frac{it}{n}}-1\big)\Big)\bigg)^{-1}
    \end{aligned}
  \]</span> 求极限得 <span class="math display">\[ 
    \lim_{n\to\infty}\varphi_{Z_n}(t)=\bigg(\prod_{k=1}^{\infty}\mathrm{e}^{\frac{it}{k}}\Big(1-\frac{it}{k}\Big)\bigg)^{-1} 
  \]</span> 由 <a href="https://en.wikipedia.org/wiki/Gamma_function#Weierstrass&#39;s_definition">Gamma 函数的无穷乘积表达</a> <span class="math display">\[
    \Gamma(z)=\frac{\mathrm{e}^{-\gamma z}}{z}\bigg(\prod_{k=1}^{\infty}\mathrm{e}^{-\frac{z}{k}}\Big(1+\frac{z}{k}\Big)\bigg)^{-1},\quad z\in\mathbb{C}\backslash\mathbb{Z}_{\leq0}
  \]</span> 可知 <span class="math inline">\(\lim_{n\to\infty}\varphi_{Z_n}(t)=\Gamma(1-it)\mathrm{e}^{-it\gamma}\)</span> . 故 <span class="math inline">\(Z_n+\gamma\)</span> 的特征函数逐点收敛到某一随机变量 <span class="math inline">\(V\)</span> 的特征函数. 由 <a href="https://en.wikipedia.org/wiki/L%C3%A9vy%27s_continuity_theorem">Lévy's Convergence Theorem</a> 可知 <span class="math display">\[
    F_V(x)=\lim_{n\to\infty}\mathbb{P}(Z_n+\gamma\leq x)=\lim_{n\to\infty}\mathbb{P}\bigg(\frac{X_n-n(H_n-\gamma)}{n}\leq x\bigg)=\lim_{n\to\infty}\mathbb{P}\Big(\frac{X_n-n\ln n}{n}\leq x\Big)
  \]</span> 这里 <span class="math inline">\(F_V\)</span> 是 <span class="math inline">\(V\)</span> 的 CDF, 满足 <span class="math display">\[
    \int_{\mathbb{R}}\mathrm{e}^{itv}\mathrm{d}F_V(v)=\Gamma(1-it)
  \]</span> 如上分析就指出 <span class="math inline">\(\frac{X_n-n\log n}{n}\overset{d}{\rightarrow}V\)</span>. 另外, 注意到 <a href="https://en.wikipedia.org/wiki/Gamma_function#Integral_representations">Gamma 函数的积分表达</a> <span class="math display">\[
    \Gamma(z)=\int_0^1\bigg(\log\frac{1}{t}\bigg)^{z-1}\mathrm{d}t,\quad z\in\mathbb{C}\wedge\mathrm{Re}(z)&gt;0
  \]</span> 我们可利用该式以及 <span class="math inline">\(V\)</span> 的特征函数满足的关系来凑出 <span class="math inline">\(F_V\)</span>. 考虑 <span class="math display">\[
    \begin{aligned}
      \Gamma(1-it)&amp;=\int_0^1\bigg(\log\frac{1}{x}\bigg)^{-it}\mathrm{d}x\quad(\text{substitution: } x=\mathrm{e}^{-\mathrm{e}^{-v}})\\
      &amp;=\int_{-\infty}^{\infty}\mathrm{e}^{itv}\mathrm{d}\big(\mathrm{e}^{-\mathrm{e}^{-v}}\big)
    \end{aligned}
  \]</span> 故 <span class="math inline">\(V\)</span> 的 CDF 为 <span class="math inline">\(F_V(v)=\mathrm{e}^{-\mathrm{e}^{-v}}\)</span>.</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/plotF_V.png" width="70%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>Plot for <span class="math inline">\(F_V\)</span> which <span class="math inline">\(\frac{X_n-n\log n}{n}\)</span> converges (a.e.) in distribution to.</em></td>
</tr>
</tbody>
</table>
<details class="note default no-icon"><summary><p><strong>RMK 1</strong></p>
</summary>
<p><strong>问题 1</strong> 的解答过程首先是让人联想到抽满的情况: 因为在计算期望的过程中算到抽满为止将得到调和数, 故它可能具有某些好的性质. 所以也就有了<strong>问题 2</strong> 中的讨论. 事实上这类问题被叫做 <a href="https://en.wikipedia.org/wiki/Coupon_collector&#39;s_problem">Coupon collector's problem</a>. 关于如下更进一步的问题, 也已有相关工作进行了研究:</p>
<ul>
<li><span class="math inline">\(n\)</span> 种扭蛋出现概率不同, 即第 <span class="math inline">\(i\)</span> 种扭蛋出现概率为 <span class="math inline">\(p_i\in(0,1)\)</span>, 满足 <span class="math inline">\(\sum_{i=1}^np_i=1\)</span>. 此时的 <span class="math inline">\(X_n\)</span> 还有比较好的性质吗? 文章 <a href="https://www.sciencedirect.com/science/article/pii/0166218X9290177C">Philippe Flajolet, Danièle Gardy, Loÿs Thimonier. <strong>Birthday paradox, coupon collectors, caching algorithms and self-organizing search.</strong></a> 指出 <span class="math display">\[
  \mathbb{E}[X_n]=\int_0^{\infty}\Bigg(1-\prod_{i=1}^n\Big(1-\mathrm{e}^{-p_it}\Big)\Bigg)\mathrm{d}t
\]</span></li>
<li>此氪金大佬想要抽齐 <span class="math inline">\(m\)</span> 套来分别送给 <span class="math inline">\(m\)</span> 个好兄弟 (即每种扭蛋至少抽出 <span class="math inline">\(m\)</span> 个), 此时他需要进行 gacha 的次数 <span class="math inline">\(X_n^{(m)}\)</span> 又是怎样的呢? 文章 <a href="https://faculty.wharton.upenn.edu/wp-content/uploads/2012/04/Double-dixie-cup-problem.pdf">Donald J. Newman, Lawrence Shepp. <strong>The double dixie cup problem.</strong></a> 显示 <span class="math display">\[
  \mathbb{E}[X_n^{(m)}]=n\log n+(m-1)n\log\log n+\mathcal{O}(n),\quad\text{for }m\text{ fixed and }n\to\infty
\]</span></li>
</ul>

</details>
<p>实际中的抽卡其实是具有强针对性的, 故存在许多干扰项 (毕竟不会有人想从一个池子里捞出全游戏中的所有卡). 现在我们从<strong>问题 2</strong> 出发讨论一般性的情况.</p>
<h2 id="问题-3">问题 3</h2>
<div class="note info no-icon"><!-- #### No icon note -->
<p>一氪金抽卡游戏的某次活动新推出了 <span class="math inline">\(n\)</span> 张卡, 并在随活动配套的卡池中 up 了该 <span class="math inline">\(n\)</span> 张新卡. 记第 <span class="math inline">\(i\)</span> 张卡的出货率为 <span class="math inline">\(p_i\)</span>, 不妨设 <span class="math inline">\(p_i\)</span> 满足稀有度由高到低的顺序: <span class="math display">\[
    0&lt;p_1\leq p_2\leq\cdots\leq p_n&lt;1,\ \sum_{i=1}^{n} p_i = p\in(0,1)
  \]</span> 现有一氪佬想要将当期 up 的 <span class="math inline">\(n\)</span> 张新卡全部抽满宝/满命/满潜 (即每张卡至少有 <span class="math inline">\(m\)</span> 张), 那么他平均要抽卡多少次?</p>
</div>
<p><strong><em>Sketch of analysis:</em></strong><br />
事实上可以看出, 该问题是上述<strong>问题 2</strong> 的 Remark 1 里所提到的两种情况的综合 (不等概率 + 多套). 我们设 <span class="math inline">\(X_i\)</span> 表示新卡 <span class="math inline">\(i\)</span> 首次被抽出 <span class="math inline">\(m\)</span> 张时总共已抽取到<strong>全部新卡</strong>的次数. 记 <span class="math inline">\(X=\max\{X_1,\dots,X_n\}\)</span>, 则 <span class="math inline">\(X\)</span> 即为该氪佬需要抽取<strong>新卡</strong>的次数. 由于具体的值未能解出, 这里仅使用 <a href="https://en.wikipedia.org/wiki/Maximum-minimums_identity">Max-Min Identity</a> 对 <span class="math inline">\(\mathbb{E}[X]\)</span> 作一个估计.<br />
展开得 <span class="math display">\[
    \begin{aligned}
      \mathbb{E}[X] = \sum_{i}\mathbb{E}[X_i]-\sum_{i&lt;j}\mathbb{E}[\min\{X_i,&amp;X_j\}]+\sum_{i&lt;j&lt;k}\mathbb{E}[\min\{X_i,X_j,X_k\}]\\
      &amp;+\cdots+(-1)^{n+1}\mathbb{E}[\min\{X_1,\dots,X_n\}]
    \end{aligned}  
  \]</span> 由几何分布的无记忆性, 容易计算 <span class="math inline">\(\mathbb{E}[X_i]=m\Big/\frac{p_i}{p}\)</span>. 对其他的项, 我们有估计 (非常 naive 的放缩) <span class="math display">\[
    \mathbb{E}\Big[Y\Big(\sum_{j=1}^kp_{i_j}\Big/p;m\Big)\Big]\leq\mathbb{E}[\min\{X_{i_1},X_{i_2},\dots,X_{i_k}\}]\leq\mathbb{E}\Big[Y\Big(p_{i_k}/p;m\Big)\Big]
  \]</span> 这里 <span class="math inline">\(i_1&lt;\cdots&lt;i_k\)</span>, 随机变量 <span class="math inline">\(Y(q;r)\)</span> 表示在成功率为 <span class="math inline">\(q\)</span> 的 Bernoulli 实验中累计成功 <span class="math inline">\(r\)</span> 次时总共进行实验的次数. 故我们有上界 (脸黑 bound) <span class="math display">\[
    \begin{aligned}
      \mathbb{E}[X] &amp;\leq\sum_i\mathbb{E}[X_i]-\sum_{i&lt;j}\mathbb{E}\Big[Y\Big((p_i+p_j)\Big/p;m\Big)\Big]+\sum_{i&lt;j&lt;k}\mathbb{E}[Y(p_k/p;m)]+\cdots\\
      &amp;=mp\Bigg(\sum_{i=1}^n\frac{1}{p_i}-\sum_{i&lt;j}\frac{1}{p_i+p_j}+\sum_{i=3}^n\frac{(i-1)(i-2)}{2p_i}+\cdots\Bigg)
    \end{aligned}  
  \]</span> 故该氪佬最终平均需要抽取的次数可由 <span class="math inline">\(\mathbb{E}[X]\Big/p\)</span> 来 bound 住.</p>
<p>其实如上的估计结果看上去就有问题: 直觉上来说抽齐 <span class="math inline">\(m\)</span> 套需要的次数一定是小于 <span class="math inline">\(m\)</span> 倍抽齐 <span class="math inline">\(1\)</span> 套需要的次数的, 所以结果关于 <span class="math inline">\(m\)</span> 成正比是不科学的 (应该是 <span class="math inline">\(m\)</span> 越大 bound 的偏差越大. 嘛, 不管那么多了). 接下来我们看一实例.</p>
<div class="note primary no-icon"><p>垃圾游戏 <a href="https://en.wikipedia.org/wiki/Fate/Grand_Order">Fate/Grand Order</a> (下称 FGO) 在某次活动中开放了双五星新从者 up 池, 并且有一个四星新从者加入 up. 已知 FGO 五星从者出率 <span class="math inline">\(1\%\)</span>, 当期 up 占 <span class="math inline">\(80\%\)</span>. 四星从者出率 <span class="math inline">\(3\%\)</span>, 当期 up 占 <span class="math inline">\(50\%\)</span>. 相同从者合并可提高宝具等级, 最高升至 5 宝. 一氪佬为了不失去自己的全图鉴满宝成就, 请估计他平均需要抽取的次数.</p>
</div>
<p>首先代入计算可得参数 <span class="math display">\[
    p_1=p_2=0.004,\ p_3=0.015,\quad p=0.023,\quad m=5
  \]</span> 代入公式立即得到一 bound: <span class="math display">\[
      5\times\Bigg(\Big(\frac{2}{0.004}+\frac{1}{0.015}\Big)-\Big(\frac{1}{0.008}+\frac{2}{0.019}\Big)+\frac{1}{0.015}\Bigg)=2015.35
  \]</span> FGO 每次 11 连需要 30 发石头, 那么该氪佬平均需要 5496.41 个石头才能保持自己的全图鉴满宝记录.</p>
<details class="note default no-icon"><summary><p><strong>RMK 2</strong></p>
</summary>
<p>那么偏差大致有多少呢? 下面对比几种情况.</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* Calculation with MMA under UNIFORM distribution. *)</span></span><br><span class="line">uniformReal[n_, m_] := </span><br><span class="line">  n <span class="keyword">NIntegrate</span>[</span><br><span class="line">    <span class="number">1</span> - (<span class="number">1</span> - <span class="keyword">Sum</span>[t^k/k!, &#123;k, <span class="number">0</span>, m - <span class="number">1</span>&#125;] <span class="keyword">Exp</span>[-t])^n, &#123;t, <span class="number">0</span>, <span class="keyword">Infinity</span>&#125;];</span><br><span class="line">uniformUpper[n_, m_] := <span class="keyword">Module</span>[&#123;res = <span class="number">0</span>&#125;,</span><br><span class="line">   <span class="keyword">Do</span>[</span><br><span class="line">    res += </span><br><span class="line">     <span class="keyword">If</span>[<span class="keyword">Mod</span>[k, <span class="number">2</span>] == <span class="number">1</span>, </span><br><span class="line">      <span class="keyword">NSum</span>[<span class="keyword">Binomial</span>[i - <span class="number">1</span>, k - <span class="number">1</span>], &#123;i, k, n&#125;], -<span class="keyword">Binomial</span>[n, k]/k],</span><br><span class="line">    &#123;k, <span class="number">1</span>, n&#125;];</span><br><span class="line">   m n res</span><br><span class="line">   ];</span><br><span class="line"></span><br><span class="line">(&#123;uniformReal[#<span class="number">1</span>, #<span class="number">2</span>], uniformUpper[#<span class="number">1</span>, #<span class="number">2</span>]&#125; &amp; @@@ <span class="keyword">Range</span>@<span class="number">5</span>~<span class="keyword">Tuples</span>~<span class="number">2</span>)~<span class="keyword">Partition</span>~<span class="number">5</span> // <span class="keyword">MatrixForm</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
  \left(
  \begin{array}{ccccc}
  \{1.,1.\} &amp; \{2.,2.\} &amp; \{3.,3.\} &amp; \{4.,4.\} &amp; \{5.,5.\} \\
  \{3.,3.\} &amp; \{5.5,6.\} &amp; \{7.875,9.\} &amp; \{10.1875,12.\} &amp; \{12.4609,15.\} \\
  \{5.5,7.5\} &amp; \{9.63889,15.\} &amp; \{13.4869,22.5\} &amp; \{17.192,30.\} &amp; \{20.8084,37.5\} \\
  \{8.33333,19.\} &amp; \{14.1887,38.\} &amp; \{19.5659,57.\} &amp; \{24.7102,76.\} &amp; \{29.7102,95.\} \\
  \{11.4167,48.75\} &amp; \{19.0414,97.5\} &amp; \{25.9868,146.25\} &amp; \{32.6028,195.\} &amp; \{39.0148,243.75\} \\
  \end{array}
  \right)
\]</span> 为省事这里就直接 copy as <span class="math inline">\(\LaTeX\)</span> 了. 输出矩阵中的第 <span class="math inline">\((i,j)\)</span> 元 <span class="math inline">\(\{r, u\}\)</span> 表示 <span class="math inline">\(n=i,m=j\)</span> 时期望的真实值 <span class="math inline">\(r\)</span> 和上界 <span class="math inline">\(u\)</span>. (这个偏差比想象中的大得多)</p>
<p>另外在上述 FGO 例子的计算中, 由于机制不清晰, 我们忽略了四星卡 (礼装/从者) 的保底机制. 但是这个上界也一定程度上的反应出了叶良树被飞马的高度——至少不会很低. (请远离毒池)</p>

</details>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>gacha</tag>
      </tags>
  </entry>
  <entry>
    <title>梦境调查档案① —— 恶心御宅青年真能梦到二次元小姐姐吗</title>
    <url>/2022/04/12/dream_s/</url>
    <content><![CDATA[<center>
<strong>睡前千万不要看路主 11 卷，认真的</strong>
</center>
<a id="more"></a>
<h3 id="前言">前言</h3>
<p>  昨晚的梦过于离奇，醒来之后笔者细细回想，应该是自己睡前看了《路人女主养成方法》第 11 卷的锅。因为 11 卷是久违地男女主糖味儿十足的互动剧情，就算关灯之后自己只要一想起来，就会在床上扭得像条蛆。不管究竟是怎样的原因，<del>出于水博文</del>，觉得昨晚的梦有意思的想法，还是简单记录一下。</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/dream1_1.png" width="40%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>路主 11 卷的封面。完结篇的开始，男主安艺伦也和女主加藤惠关系突飞猛进的一卷。男主安艺伦也为了剧本取材拉着惠各种交流和实践，具体是哪些这里就不剧透了，总之糖度爆表。</em></td>
</tr>
</tbody>
</table>
<h3 id="梦境前半段">梦境前半段</h3>
<p>自己是一个从城市转学到乡下，喜欢看动画漫画轻小说的宅男。<br />
第一天入住的寝室发现是男女合住，并且还住着三个妹子。<br />
自己稀里糊涂就和一个鲍勃头妹子交往了。<br />
性格，身材，发型都和加藤惠如出一辙。<br />
谁会拒绝加藤惠这样的妹子呢？<br />
我就是安艺伦也！</p>
<p><em>（呜啊，我这也太恶心了）</em></p>
<h3 id="中间转折选择">中间转折选择</h3>
<p><font color=#A9A9A9>[场景 教学楼楼道 上课铃响前]</font><br />
女朋友：诶，问你个问题？<br />
我：嗯，你说。<br />
女朋友：<font color=#A9A9A9>（稍有犹豫）</font>嗯……就是……你更愿意我是加藤惠那样的女孩子吗？<br />
我：这……怎么说呢？<br />
<font color=#A9A9A9>（我感到惊讶，且难为情，支支吾吾，不知道好不好开口）</font><br />
我：没，没吧，我对三次元女生又没那种要求。<br />
<font color=#A9A9A9>（具体表情记不清了，自己应该脸红了）</font><br />
<font color=#A9A9A9>（我说完，女朋友没回应，她脸上挂着挂着浅浅一笑，快步小跑走进了教室，我一个人被扔在后面）</font><br />
我：<font color=#A9A9A9>（苦笑且满是疑惑）</font>所以刚才到底是啥意思？</p>
<p><em>（写下来还是这段充满妄想意味儿的情节感觉好瞎，至今回想起来还是觉得羞耻）</em></p>
<h3 id="梦境后半段">梦境后半段</h3>
<p>因为中间转折剧情，女方形象大变样，具体记不清了，差不多就是性格和言语更开放了，并且会伴随一些迷惑行为。<em>（妹子你谁啊，这人设彻底崩坏了吧）</em></p>
<p>梦境内容也开始暴走，自己可以进入大地图视角。大地图上甚至出现了一群类似于邪教的反派组织，自己可以在大地图上选择据点点位进入具体场景像 ARPG 那样捣毁窝点，然后获得用于约会，强化的材料。<em>（不是，你们这群坏蛋又是谁？我只是一个从城市转来乡下，只喜欢看动画漫画轻小说，靠刷你们得各种材料的高中生啊！）</em></p>
<p>之后，在放学回家的有一天，女方起兴提议晚饭吃蛇蛋，我没反对。然后找了个树洞趁毒蛇还睡觉时掏蛇蛋。最后两人惊醒了毒蛇，双双被毒蛇咬了毒死了。<em>（说真的，这一段槽点更多了，为啥晚饭要去吃蛇蛋啊，为啥要去偷啊，还被毒蛇要死了！这都什么狗屎结局！）</em></p>
<p>自己死后，剧情回溯到了自己转学的第一天，二周目的第一天还没彻底发展完就醒了。<em>（所以这梦就是什么粪作 GAL 吧）</em></p>
<h3 id="尾声">尾声</h3>
<p>其实总结整理完了来看看，能攻略多位女角色（其实之前还另外攻略了一位，只不过这个印象最深），每个女角色有自己独立的剧情，并且最后各自的剧情线索能够最后汇总成一个结局。表面上是平淡的乡村校园生活，实际上背后隐藏着邪恶组织在暗流涌动。一个女主是这个故事的破局核心。</p>
<p>这不就是寒蝉鸣泣之时嘛喂！</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/dream1_2.png" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>寒蝉鸣泣之时可以说是经典轮回传奇作品了。蝉在叫，人坏掉。校园日常一转悬疑恐怖，最后全是美军的阴谋。</em></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 高考数学问题</title>
    <url>/2022/06/12/gaokaomaths2022_z/</url>
    <content><![CDATA[<p>(年年水, 不说了.)</p>
<a id="more"></a>
<p>现在高考用卷好像是这么个情况:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">卷名</th>
<th style="text-align: center;">地区</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">全国甲卷</td>
<td style="text-align: center;">云南, 四川, 广西, 贵州, 西藏</td>
</tr>
<tr class="even">
<td style="text-align: center;">全国乙卷</td>
<td style="text-align: center;">陕西, 新疆, 宁夏, 吉林, 黑龙江, 内蒙古, 青海, 甘肃, 安徽, 江西, 山西, 河南</td>
</tr>
<tr class="odd">
<td style="text-align: center;">全国新高考 I 卷</td>
<td style="text-align: center;">山东, 河北, 湖北, 湖南, 江苏, 福建, 广东</td>
</tr>
<tr class="even">
<td style="text-align: center;">全国新高考 II 卷</td>
<td style="text-align: center;">海南, 重庆, 辽宁</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(自主命题)</td>
<td style="text-align: center;">北京, 上海, 天津, 浙江</td>
</tr>
</tbody>
</table>
<p>甲, 乙卷是全套均由教育部统一命题; I, II 卷语数英由教育部命题 (数学不分文理科), 其余科目由各省自行命制.<br />
下面我们按照惯例, 把各卷理科数学最后一题拉出来导一导.</p>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>(全国甲卷)</strong> 已知函数 <span class="math inline">\(f(x)=\displaystyle\frac{\mathrm e^x}{x}-\log x+x-a\)</span>.</p>
<ol type="1">
<li>若 <span class="math inline">\(f(x)\ge0\)</span>, 求 <span class="math inline">\(a\)</span> 的取值范围;</li>
<li>证明: 若 <span class="math inline">\(f(x)\)</span> 有两个零点 <span class="math inline">\(x_1,x_2\)</span>, 则 <span class="math inline">\(x_1x_2&lt;1\)</span>.</li>
</ol>
</div>
<p><strong><em>Sketch:</em></strong><br />
由 <span class="math display">\[
  \frac{\mathrm d}{\mathrm dx}f(x) =\frac{1}{x}\Big(\frac{\mathrm{e}^x}{x}+1\Big)(x-1),\ x&gt;0
\]</span> 知 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((0,1)\)</span> 上单减, 在 <span class="math inline">\((1,+\infty)\)</span> 上单增. 不妨 <span class="math inline">\(0&lt;x_1&lt;1&lt;x_2\)</span>. 考虑 <span class="math display">\[
  \frac{\mathrm d}{\mathrm dx}\Big(f(x)-f(1/x)\Big)=\frac{x-1}{x^2}\Big(\mathrm e^x+x-x\mathrm e^{\frac1x}-1\Big),\ x&gt;1
\]</span> 注意到 <span class="math inline">\(x&gt;1\)</span> 时 <span class="math display">\[
  \mathrm e^x+x-x\mathrm e^{\frac1x}-1&gt;\mathrm ex+x-x\cdot\mathrm e -1&gt;0
\]</span> 故 <span class="math inline">\(f(x)-f(1/x)\)</span> 在 <span class="math inline">\((1,+\infty)\)</span> 上单增, <span class="math inline">\(f(x_2)-f(1/x_2)&gt;\lim_{x\to1+}\big(f(x)-f(1/x)\big)=0\)</span>, 即 <span class="math inline">\(f(1/x_2)&lt;0\)</span>. 由于 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((0,1)\)</span> 上单减, 故 <span class="math inline">\(x_1&lt;1/x_2\)</span>, 即 <span class="math inline">\(x_1x_2&lt;1\)</span>. <br/><br/></p>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>(全国乙卷)</strong> 已知函数 <span class="math inline">\(f(x)=\log(1+x)+ax\mathrm{e}^{-x}\)</span>.</p>
<ol type="1">
<li>当 <span class="math inline">\(a=1\)</span> 时, 求曲线 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\((0,f(0))\)</span> 处的切线方程;</li>
<li>若 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\((-1,0)\)</span>, <span class="math inline">\((0,+\infty)\)</span> 各恰有一个零点, 求 <span class="math inline">\(a\)</span> 的取值范围.</li>
</ol>
</div>
<p><strong><em>Sketch:</em></strong><br />
导: <span class="math display">\[
\frac{\mathrm d}{\mathrm dx}f(x) =\frac{1}{\mathrm e^x(1+x)}\big(\mathrm e^x+a(1-x^2)\big),\ x&gt;-1
\]</span> 令 <span class="math inline">\(g(x)=\mathrm e^x+a(1-x^2)\)</span>, 则 <span class="math inline">\(g&#39;(x)=\mathrm{e}^x -2ax\)</span>. 注意到 <span class="math inline">\(f(0)=0\)</span>, <span class="math inline">\(f&#39;(0)=1+a\)</span>. 下面我们分情况讨论.</p>
<ul>
<li><span class="math inline">\(a\ge-1\)</span>.
<ul>
<li><span class="math inline">\(a\in[-1,0]\)</span>. <span class="math inline">\(g&#39;(x)\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上单增, 故 <span class="math inline">\(g&#39;(x)&gt;g&#39;(0)=1\)</span>, 故 <span class="math inline">\(g(x)&gt;g(0)\ge0\)</span>, 即 <span class="math inline">\(f&#39;(x)&gt;0\)</span>, <span class="math inline">\(x&gt;0\)</span>, 此时 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上没有零点.</li>
<li><span class="math inline">\(a\in(0,+\infty)\)</span>. <span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\((-1,0)\)</span> 上单增, 故 <span class="math inline">\(g(x)&gt;g(-1)&gt;0\)</span>, 即 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((0,1)\)</span> 上单增, <span class="math inline">\(f(x)&lt;f(0)=0\)</span>, 此时 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((-1,0)\)</span> 上没有零点.</li>
</ul></li>
<li><span class="math inline">\(a&lt;-1\)</span>.<br />
注意到 <span class="math inline">\(g&#39;&gt;0\)</span>, <span class="math inline">\(x&gt;0\)</span>, 故 <span class="math inline">\(g\)</span> 单增, 而 <span class="math inline">\(g(0)&lt;0, g(1)&gt;0\)</span>, 表明 <span class="math inline">\(f\)</span> 先减再增, 而 <span class="math inline">\(f(0)=0\)</span>, <span class="math inline">\(f(+\infty)=+\infty\)</span>, 故 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上存在唯一零点. 类似地, 可以讨论 <span class="math inline">\(x\in(-1,0)\)</span>. 这时 <span class="math inline">\(g&#39;\)</span> 单增, 而 <span class="math inline">\(g&#39;(-1)&lt;0,g&#39;(0)&gt;0\)</span> 表明 <span class="math inline">\(g\)</span> 先减再增. 而 <span class="math inline">\(g(-1)&gt;0,g(0)&lt;0\)</span> 可证 <span class="math inline">\(g\)</span> 在 <span class="math inline">\((-1,0)\)</span> 上存在唯一零点, 这表明 <span class="math inline">\(f\)</span> 先增再减. 而 <span class="math inline">\(f(-1+)=-\infty\)</span>, <span class="math inline">\(f(0)=0\)</span>, 故 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((-1,0)\)</span> 上存在唯一零点.</li>
</ul>
<p>综上, <span class="math inline">\(a&lt;-1\)</span> 满足条件. <br/><br/></p>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>(全国新高考 I 卷)</strong> 已知函数 <span class="math inline">\(f(x)=\mathrm e^x-ax\)</span> 和 <span class="math inline">\(g(x)=ax-\log x\)</span> 有相同的最小值.</p>
<ol type="1">
<li>求 <span class="math inline">\(a\)</span>;</li>
<li>证明: 存在直线 <span class="math inline">\(y=b\)</span>, 其与两条曲线 <span class="math inline">\(y=f(x)\)</span> 和 <span class="math inline">\(y=g(x)\)</span> 共有三个不同的交点, 并且从左到右的三个交点的横坐标成等差数列.</li>
</ol>
</div>
<p><strong><em>Sketch:</em></strong><br />
容易算得 <span class="math inline">\(a=1\)</span>. 作图如下:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/gaokaomaths2022_1.png" width="60%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>Plot for <span class="math inline">\(f(x)=e^x-x\)</span>, <span class="math inline">\(g(x)=x-\log x\)</span> and the desired <span class="math inline">\(y=b\)</span>.</em></td>
</tr>
</tbody>
</table>
<p>注意到 <span class="math inline">\(f(x)=b\)</span> 即 <span class="math inline">\(\mathrm e^x=x+b\)</span>, <span class="math inline">\(g(x)=b\)</span> 即 <span class="math inline">\(\log x=x-b\)</span>. 不妨 <span class="math inline">\(b&gt;0\)</span>, 利用 <span class="math inline">\(\mathrm e^x\)</span>, <span class="math inline">\(\log x\)</span> 图像关于 <span class="math inline">\(y=x\)</span> 的对称性, 考虑作图如下 (图里取的 <span class="math inline">\(b=1.5\)</span>):</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/gaokaomaths2022_2.png" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>Intersections of <span class="math inline">\(y=\mathrm e^x\)</span> and <span class="math inline">\(y=x+b\)</span>, <span class="math inline">\(y=\log x\)</span> and <span class="math inline">\(y=x-b\)</span>.</em></td>
</tr>
</tbody>
</table>
<p>显然, 由对称性可知 <span class="math inline">\(x_B-x_A=x_D-x_C\)</span>. 故问题可以转化为证明存在实数 <span class="math inline">\(b\)</span> 使得 <span class="math inline">\(B,C\)</span> 两点横坐标相等, 即 <span class="math inline">\(x_B=x_C\)</span>. 可以证明 <span class="math inline">\(b\)</span> 从 <span class="math inline">\(1+\)</span> 到 <span class="math inline">\(+\infty\)</span> 时 <span class="math inline">\(x_B\)</span> 从 <span class="math inline">\(0+\)</span> 单调递增至 <span class="math inline">\(+\infty\)</span>, <span class="math inline">\(x_C\)</span> 从 <span class="math inline">\(1-\)</span> 单调递减至 <span class="math inline">\(0+\)</span>. 故存在满足条件的 <span class="math inline">\(b\)</span>. <br/><br/></p>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>(全国新高考 II 卷)</strong> 已知函数 <span class="math inline">\(f(x)=x\mathrm{e}^{ax}-\mathrm e^x\)</span>.</p>
<ol type="1">
<li>当 <span class="math inline">\(a=1\)</span> 时, 讨论 <span class="math inline">\(f(x)\)</span> 的单调性;</li>
<li>当 <span class="math inline">\(x&gt;0\)</span> 时, <span class="math inline">\(f(x)&lt;-1\)</span>, 求实数 <span class="math inline">\(a\)</span> 的取值范围;</li>
<li>设 <span class="math inline">\(n\in\mathbb N^*\)</span>, 证明: <span class="math inline">\(\frac{1}{\sqrt{1^2+1}}+\frac{1}{\sqrt{2^2+2}}+\cdots+\frac{1}{\sqrt{n^2+n}}&gt;\log(n+1)\)</span>.</li>
</ol>
</div>
<p><strong><em>Sketch:</em></strong><br />
直接硬算第三题. 设 <span class="math inline">\(g(x)=\frac{1}{\sqrt{x^2+x}}-\log(x+1)+\log x,\ x&gt;0\)</span>, 故 <span class="math display">\[
  \begin{aligned}
    \frac{\mathrm d}{\mathrm dx}g(x) =&amp; -\frac12(x^2+x)^{-\frac32}(2x+1)-\frac{1}{x+1}+\frac1x\\
     =&amp;\frac{1}{2}(x^2+x)^{-\frac32}(2\sqrt{x^2+x}-2x-1) \\
    =&amp; \frac{1}{2}(x^2+x)^{-\frac32}\frac{1-\sqrt{1+x^{-1}}}{1+\sqrt{1+x^{-1}}}&lt;0,\ x&gt;0
  \end{aligned}
\]</span> 故 <span class="math inline">\(g\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上单调递减, 注意到 <span class="math display">\[
\begin{aligned}
  \lim_{x\to 0+}g(x) &amp;= \lim_{x\to+\infty}\Big(\frac{x}{\sqrt{x+1}}-\log(1+x)\Big)=+\infty\\
  \lim_{x\to+\infty}g(x)&amp;= \lim_{x\to 0+}\Big(\frac{x}{\sqrt{x+1}}-\log(1+x)\Big)=0
\end{aligned}
\]</span> 故 <span class="math inline">\(g(x)&gt;0,\ \forall x&gt;0\)</span>. 所以 <span class="math display">\[
  \sum_{k=1}^n\frac{1}{\sqrt{k^2+k}}&gt;\sum_{k=1}^n\big(\log(k+1)-\log k\big)=\log(n+1)
\]</span></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>maths</tag>
      </tags>
  </entry>
  <entry>
    <title>愚夜观随笔诗其二</title>
    <url>/2022/02/22/gsxb_poem_s/</url>
    <content><![CDATA[<h3 id="读故事新编有感1">读《故事新编》有感<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></h3>
<p>羿射九日<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>始晓晨，禹治百川<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>系苍生。</p>
<p>自古年少多情思，岂为朝花作愚人。</p>
<a id="more"></a>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><span style="font-family:楷体">作于 2022 年 1 月 17 日，因前一天的感情旧事，反复沉思得此解，遂作下此诗用于后面警示勉励自己。</span><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><span style="font-family:楷体">指的是《故事新编》中的《奔月》一文。</span><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><span style="font-family:楷体">指的是《故事新编》中的《理水》一文。</span><a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title>(ICML20) The FAST Algorithm for Submodular Maximization</title>
    <url>/2021/12/07/icml20_Fast_z/</url>
    <content><![CDATA[<p>经过悠长的摸鱼期终于还是感受到了情况的紧迫, 继否决了一票 idea 之后我将再次冲锋, 打算基于一个全新的想法来完成自己的 paper, 希望这次人没事. 本文将怀着忐忑不安的心情介绍一下 ICML 2020 的<a href="https://proceedings.mlr.press/v119/breuer20a.html">一篇 paper</a>, 这篇文章将使用一种快速的并行算法, 在 <span class="math inline">\(\mathcal{O}(\log(n)\log^2(\log k))\)</span> 的自适应轮数以及 <span class="math inline">\(\mathcal{O}(n\log\log k)\)</span> 的 query 数内重新给出单调次模函数的 <span class="math inline">\(k\)</span> 基数约束这一经典问题的 <span class="math inline">\(1-1/\mathrm e\)</span> 近似解.</p>
<a id="more"></a>
<h2 id="preliminaries">Preliminaries</h2>
<p>我们使用 adaptivity 来衡量并行时间复杂度, 即有多项式数量的 query 被并行处理的轮数. 例如简单贪心算法的 adaptivity 是 <span class="math inline">\(\mathcal O(k)\)</span>, 最差为 <span class="math inline">\(\mathcal O(n)\)</span>. 最近出现的 adaptive sampling 框架对该问题可在 <span class="math inline">\(\mathcal O(\log n)\)</span> 轮数下给出常数近似比, 并且也已经有人将该思想从最初的 <span class="math inline">\(1/3\)</span> 近似比 improve 到 <span class="math inline">\(1-1/\mathrm e\)</span> 的最佳近似比. 但作者指出目前的算法存在 &quot;the logarithmic parallel runtime of algorithms in this genre carries extremely large constants and polynomial dependencies on precision and confidence parameters that are hidden in their asymptotic analysis&quot; 这样的问题, 例如若想以 <span class="math inline">\(95\%\)</span> 的置信度取得 <span class="math inline">\(1-1/\mathrm e-0.1\)</span> 的近似比时每轮需要采样的集合数就达到了 <span class="math inline">\(10^6\sim10^8\)</span> 量级.</p>
<p>本文所作的贡献就在于保证渐近近似比一定的情况下, 使得算法在非渐近最差情形下 query 复杂度和运行轮数 (实际运行时间) 能维持在一个较低的水平, 为此使用到了 adaptive sequencing 和 multiple optimization 的技术.</p>
<h2 id="algorithms">Algorithms</h2>
<p>我们首先从一个简单版本的算法开始.</p>
<div class="note info no-icon"><h3 id="alg.-1-adaptive-sequencing-with-known-fo">(Alg. 1) Adaptive-Sequencing with known <span class="math inline">\(f(O)\)</span></h3>
<p>input <span class="math inline">\(f,k,\epsilon\)</span><br />
initiate <span class="math inline">\(S=\emptyset\)</span><br />
<strong>while</strong> <span class="math inline">\(|S|&lt;k\)</span> and number of iterations <span class="math inline">\(&lt;\epsilon^{-1}\)</span> <strong>do</strong><br />
  <span class="math inline">\(X\gets N\)</span>, <span class="math inline">\(t\gets(1-\epsilon)(f(O)-f(S))/k\)</span><br />
  <strong>while</strong> <span class="math inline">\(X\neq\emptyset\)</span> and <span class="math inline">\(|S|&lt;k\)</span> <strong>do</strong><br />
    <span class="math inline">\(a_1,\dots,a_k\gets\text{SEQ}(X,k)\)</span><br />
    <span class="math inline">\(i^*\gets\min\{i\in[k]:|X_i|\leq(1-\epsilon)|X|\}\)</span><br />
        with <span class="math inline">\(X_i\gets\{a\in X:f(a\mid S\cup\{a_1,\dots,a_{i-1}\})\geq t\}\)</span><br />
    <span class="math inline">\(S\gets S\cup\{a_1,\dots,a_{i^*-1}\}\)</span><br />
    <span class="math inline">\(X\gets X_{i^*}\)</span><br />
<strong>return</strong> <span class="math inline">\(S\)</span></p>
</div>
<p>这里 <span class="math inline">\(\text{SEQ}(X,k)\)</span> 是从集合 <span class="math inline">\(X\)</span> 中等概率随机取样的一个 <span class="math inline">\(k\)</span> 元素排列. 可以看出有关系 <span class="math inline">\(X_k\subset X_{k-1}\subset\cdots\subset X_1\)</span>, 我们取 <span class="math inline">\(i^*\)</span> 使得 <span class="math inline">\(|X_{i^*}|\leq(1-\epsilon)|X|&lt;X_{i^*-1}\)</span>, 然后将 <span class="math inline">\(a_1,\dots,a_{i^*-1}\)</span> 加入到 <span class="math inline">\(S\)</span> 中并且将 <span class="math inline">\(X\)</span> 的占至少 <span class="math inline">\(\epsilon\)</span> 部分的 marginal gain 小于门槛值 <span class="math inline">\(t\)</span> 的元素删去.</p>
<p>算法 Alg. 1 包括内外两个循环, 对于一个外循环, 由 <span class="math inline">\(|X|=0\)</span> 为终止条件知内循环次数 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\((1-\epsilon)^in\geq1\)</span>, 故内循环轮数不超过 <span class="math inline">\(\epsilon^{-1}\log n\)</span>, 总的 <strong>adaptivity 复杂度</strong>为 <span class="math inline">\(\mathcal O(\epsilon^{-2}\log n)\)</span>. 对每个内循环, 我们至多要计算 <span class="math inline">\(k|X|\)</span> 次 marginal gain, 故 <strong>query 复杂度</strong>为 <span class="math inline">\(\mathcal O\Big(\epsilon^{-1}\sum_{i=1}^{\epsilon^{-1}\log n}k(1-\epsilon)^in\Big)=\mathcal O(\epsilon^{-2}nk)\)</span>.</p>
<p>下面分析近似比.</p>
<div class="note primary no-icon"><h4 id="lemma-1">Lemma 1</h4>
<p>Let <span class="math inline">\(S_i\)</span> be the current solution <span class="math inline">\(S\)</span> at the start of iteration <span class="math inline">\(i\)</span> of the outer-loop of Alg. 1. For any <span class="math inline">\(i\)</span>, if <span class="math inline">\(|S_{i+1}|&lt;k\)</span>, then <span class="math inline">\(f(S_{i+1}\mid S_i)\geq\epsilon(f(O)-f(S_i))\)</span>.</p>
</div>
<p><strong><em>Proof of Lemma 1:</em></strong> 由 <span class="math inline">\(|S_{i+1}|&lt;k\)</span> 可知在第 <span class="math inline">\(i\)</span> 轮外循环结束时 <span class="math inline">\(X=\emptyset\)</span>. 这表明对任一 <span class="math inline">\(e\in N\backslash S_{i+1}\)</span>, <span class="math inline">\(e\)</span> 都在第 <span class="math inline">\(i\)</span> 轮外循环的某一内循环中因对某时刻 solution 集合 <span class="math inline">\(S\)</span> 的 marginal gain 小于门槛值而被舍弃, 这里 <span class="math inline">\(S_i\subset S\subset S_{i+1}\)</span>. 故由次模性得 <span class="math display">\[
  f(O)-f(S_{i+1})\leq\sum_{e\in O\backslash S_{i+1}}f(e\mid S_{i+1})\leq\sum_{e\in O\backslash S_{i+1}}\frac{(1-\epsilon)(f(O)-f(S_i))}{k}\leq(1-\epsilon)(f(O)-f(S_i))
\]</span> 整理后即得 Lemma 1 结论.</p>
<div class="note primary no-icon"><h4 id="lemma-2">Lemma 2</h4>
<p>At any iteration of the inner-loop of Alg. 1, for all <span class="math inline">\(i&lt;i^*\)</span>, we have <span class="math display">\[
    \mathbb E_{a_i}[f(a_i\mid S\cup\{a_1,\dots,a_{i-1}\})]\geq(1-\epsilon)^2(f(O)-f(S))/k
  \]</span></p>
</div>
<p><strong><em>Proof of Lemma 2:</em></strong> 由于 <span class="math inline">\(a_i\)</span> 是从 <span class="math inline">\(X\)</span> 中等概率选取的元素, 且对 <span class="math inline">\(i&lt;i^*\)</span> 都有 <span class="math inline">\(|X_i|\geq(1-\epsilon)|X|\)</span>, 故 <span class="math display">\[
  \mathbb E_{a_i}[f(a_i\mid S\cup\{a_1,\dots,a_{i-1}\})]\geq\mathrm{Pr}_{a_i}[f(a_i\mid S\cup\{a_1,\dots,a_{i-1}\})\geq t]\cdot t\geq(1-\epsilon)^2(f(O)-f(S))/k
\]</span></p>
<div class="note primary no-icon"><h4 id="theorem-1">Theorem 1</h4>
<p>Alg. 1 is an algorithm with at most <span class="math inline">\(\epsilon^{-2}\log n\)</span> adaptive rounds and <span class="math inline">\(\epsilon^{-2}nk\)</span> queries that achieves a <span class="math inline">\(1-1/\mathrm e-\frac{3}{2}\epsilon\)</span> approximation in expectation.</p>
</div>
<p><strong><em>Proof of Theorem 1:</em></strong> 分情况讨论.</p>
<ul>
<li>若算法不因违反 <span class="math inline">\(|S|&lt;k\)</span> 结束, 即 <span class="math inline">\(\epsilon^{-1}\)</span> 次外循环全部完成了. 设 <span class="math inline">\(S_1,\dots,S_{\epsilon^{-1}}\)</span> 依次为这 <span class="math inline">\(\epsilon^{-1}\)</span> 次外循环中每次循环下的 solution 集合 <span class="math inline">\(S\)</span>. 由 Lemma 1 知每次循环使得目标函数值增加至少 <span class="math inline">\(t\)</span>, 即 <span class="math display">\[
  f(S_i)\geq f(S_{i-1})+\epsilon(f(O)-f(S_{i-1}))
\]</span> 递推易得 <span class="math inline">\(f(S_i)\geq\Big(1-(1-\epsilon)^i\Big)f(O)\)</span>. 再由 <span class="math inline">\(1-x\leq\mathrm e^{-x}\)</span> 就得 <span class="math inline">\(f(S_{\epsilon^{-1}})\geq(1-\mathrm e^{-1})f(O)\)</span>.</li>
<li>若算法因 <span class="math inline">\(|S|\geq k\)</span> 退出, 我们设 <span class="math inline">\(S_i\)</span> 代表 <span class="math inline">\(S\)</span> 中按序加入的前 <span class="math inline">\(i\)</span> 个元素所构成的集合, 不妨 <span class="math inline">\(S_{i}=S_{i-1}\cup\{a_i\}\)</span>. 则利用 Lemma 2 中结论 <span class="math display">\[
  \begin{aligned}
    \mathbb E_{a_i}[f(a_i\mid S_{i-1})]=&amp;\mathbb E_{a_i}[f(a_i\mid S&#39;\cup\{e_1,\dots,e_{j}\})]\\
    \geq&amp;(1-\epsilon)^2\frac{f(O)-f(S&#39;)}{k}\\
    \Rightarrow \mathbb E[f(S_{i}\mid S_{i-1})]\geq&amp;(1-\epsilon)^2\frac{f(O)-f(S_{i-1})}{k}
  \end{aligned}
\]</span> 这里 <span class="math inline">\(S&#39;\)</span> 是该轮 <span class="math inline">\(S\)</span> 的初始值. 故类似地 <span class="math display">\[
  \begin{aligned}
    f(S_k)\geq&amp;\bigg(1-\Big(1-\frac{(1-\epsilon)^2}{k}\Big)^k\bigg)f(O)\geq\Big(1-\mathrm e^{-(1-\epsilon)^2}\Big)f(O)\\
    \geq&amp;\Big(1-\mathrm e^{-(1-2\epsilon)}\Big)f(O)\geq(1-\mathrm e^{-1}(1-4\epsilon))f(O)\geq\Big(1-\mathrm e^{-1}-\frac32\epsilon\Big)f(O)
  \end{aligned}
\]</span></li>
</ul>
<p>现在我们可以考虑完整版的算法了. 该算法将不再假设 <span class="math inline">\(f(O)\)</span> 已知, 且由于二分搜索和采样方法的引入降低了 query 复杂度.</p>
<div class="note info no-icon"><h3 id="alg.-2-fast-full-the-full-algorithm">(Alg. 2) Fast-Full: the full algorithm</h3>
<p>input <span class="math inline">\(f,k,\epsilon\)</span><br />
<span class="math inline">\(V\gets\text{GEOMETRIC}\Big(\max_{a\in N}f(a),\max_{|S|\leq k}\sum_{a\in S}f(a),1-\epsilon\Big)\)</span><br />
<span class="math inline">\(v^*\gets\text{BISEARCH}\Big(V,\max\{v\in V:f(S_v)\geq(1-\mathrm e^{-1})v\}\Big)\)</span> where <span class="math inline">\(S_v\gets\text{FAST}(v)\)</span><br />
<strong>return</strong> <span class="math inline">\(S_{v^*}\)</span></p>
<h3 id="alg.-3-fast-the-fast-adaptive-sequencing-technique-algorithm">(Alg. 3) FAST: the Fast Adaptive Sequencing Technique algorithm</h3>
<p>input <span class="math inline">\(f,k,v,\epsilon\)</span><br />
initiate <span class="math inline">\(S=\emptyset\)</span><br />
<strong>while</strong> <span class="math inline">\(|S|&lt;k\)</span> and number of iterations <span class="math inline">\(&lt;\epsilon^{-1}\)</span> <strong>do</strong><br />
  <span class="math inline">\(X\gets N\)</span>, <span class="math inline">\(t\gets(1-\epsilon)(v-f(S))/k\)</span><br />
  <strong>while</strong> <span class="math inline">\(X\neq\emptyset\)</span> and <span class="math inline">\(|S|&lt;k\)</span> <strong>do</strong><br />
    <span class="math inline">\(a_1,\dots,a_{|X|}\gets\text{SEQ}(X,|X|)\)</span>, <span class="math inline">\(A_i\gets a_1,\dots,a_i\)</span><br />
    <span class="math inline">\(S\gets S\cup\{a_i:f(a_i\mid S\cup A_{i-1})\geq t\}\)</span><br />
    <span class="math inline">\(X_0\gets\{a\in X:f(a\mid S)\geq t\}\)</span><br />
    <strong>if</strong> <span class="math inline">\(|X_0|\leq(1-\epsilon)|X|\)</span> <strong>then</strong> <span class="math inline">\(X\gets X_0\)</span> and continue to next iteration<br />
    <span class="math inline">\(R\gets\text{SAMPLE}(X,m)\)</span>, <span class="math inline">\(I\gets\text{GEOMETRIC}(1,k-|S|,1-\epsilon)\)</span><br />
    <span class="math inline">\(i^*\gets\text{BISEARCH}(I,\max\{i\in I:|\{a\in R:f(a\mid S\cup A_{i-1})\geq t\}|\geq(1-2\epsilon)|R|\})\)</span><br />
    <span class="math inline">\(S\gets S\cup A_{i^*}\)</span><br />
<strong>return</strong> <span class="math inline">\(S\)</span></p>
</div>
<p>可以看到主算法 Alg. 2 用了常用的 sieve 手段解决 <span class="math inline">\(f(O)\)</span> 未知的问题. <span class="math inline">\(\text{GEOMETRIC}(a,b,q), (a&lt;b,0&lt;q&lt;1)\)</span> 生成一个从 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(b\)</span> 的公比为 <span class="math inline">\(q^{-1}\)</span> 的等比数列 (筛子), 然后我们在这个有序数组中二分查找满足 <span class="math inline">\(1-e^{-1}\)</span> 近似要求的最大 <span class="math inline">\(v\)</span> 即可 (<span class="math inline">\(v\)</span> 即是我们对 <span class="math inline">\(f(O)\)</span> 的近似).</p>
<p>Alg. 3 稍显复杂, 但原理与 Alg. 1 类似. 首先生成 <span class="math inline">\(X\)</span> 的一个均匀分布随机排列 <span class="math inline">\(\text{SEQ}(X,|X|)\)</span>, 然后将对 <span class="math inline">\(S\cup A_{i-1}\)</span> marginal gain 大于门槛值 <span class="math inline">\(t\)</span> 的 <span class="math inline">\(a_i\)</span> 加入到 <span class="math inline">\(S\)</span> 中. 接下来我们确定 <span class="math inline">\(i^*\)</span> 是使得 <span class="math inline">\(X\)</span> 中对于 <span class="math inline">\(S\cup A_{i^*-1}\)</span> 的 marginal gain 大于门槛值的元素足够多 (比例不小于 <span class="math inline">\(1-2\epsilon\)</span>) 的最大标号. 这里为了效率起见, 我们不再对 <span class="math inline">\(X\)</span> 中每个元素进行检验, 而是提前取样一个从 <span class="math inline">\(X\)</span> 中均匀概率选取 <span class="math inline">\(m\)</span> 个元素构成的集合 <span class="math inline">\(\text{SAMPLE}(X,m)\)</span>.</p>
<div class="note primary no-icon"><h4 id="theorem-2">Theorem 2</h4>
<p>Assume <span class="math inline">\(k\geq\frac{2\log(2\delta^{-1}\ell)}{\epsilon^2(1-5\epsilon)}\)</span> and <span class="math inline">\(\epsilon\in(0,0.1)\)</span>, where <span class="math inline">\(\ell=\log(\frac{\log k}{\epsilon})\)</span>. Then <span class="math inline">\(\text{FAST}\)</span> with <span class="math inline">\(m=\frac{2+\epsilon}{\epsilon^2(1-3\epsilon)}\log\big(\frac{4\ell\log n}{\delta\epsilon^2}\big)\)</span> has at most <span class="math inline">\(\epsilon^{-2}\ell^2\log n\)</span> adaptive rounds, <span class="math inline">\(2\epsilon^{-2}\ell n+\epsilon^{-2}\ell^2m\log n\)</span> queries, and achieves a <span class="math inline">\(1-\mathrm e^{-1}-4\epsilon\)</span> approximation w.p. <span class="math inline">\(1-\delta\)</span>.</p>
</div>
<details class="note default no-icon"><summary><p><strong>RMK 1</strong></p>
</summary>
<p>TBD</p>

</details>
]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>submodular maximization</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>(ICML20) Streaming Submodular Maximization under a $k$-Set System</title>
    <url>/2020/12/01/icml20_streaming_kset_z/</url>
    <content><![CDATA[<p>号称第一个解决 streaming + non-monotone + <span class="math inline">\(k\)</span>-system constraint 问题的<a href="https://arxiv.org/abs/2002.03352">算法</a>出现了. 究竟是怎么一回事呢? 现在就让小编带大家一起来看看吧.</p>
<a id="more"></a>
<h2 id="a-framework">A Framework</h2>
<p>文章提出了一个新的将<strong>适用于单调次模函数的流算法</strong>转变为<strong>适用于非单调次模函数的流算法</strong>的框架. 其实这种 converting 框架在 <a href="https://arxiv.org/abs/1706.03583">AAAI2018 的一篇文章</a>中已经被提出过一次了, 不过在那篇文章中要求所用的流算法具有 <span class="math display">\[
  f(S)\geq\alpha f(S\cup T)
\]</span> 这样的性质 (<span class="math inline">\(S\)</span> 为算法输出, <span class="math inline">\(T\)</span> 为任一可行解, <span class="math inline">\(\alpha&gt;0\)</span> 为某个常数).</p>
<p>本文中的框架对输入算法要求具有 <span class="math inline">\((\alpha,\gamma)\)</span>-approximation 的性质:</p>
<div class="note default no-icon"><p><strong>Definition:</strong> Consider a data stream algorithm for maximizing a non-negative submodular function <span class="math inline">\(f:2^{\mathcal{N}}\to\mathbb{R}_{\geq0}\)</span> subject to a constraint <span class="math inline">\((\mathcal{N},\mathcal{I})\)</span>. We say that such an algorithm is an <span class="math inline">\((\alpha,\gamma)\)</span>-approximation algorithm, for some <span class="math inline">\(\alpha&gt;1\)</span> and <span class="math inline">\(\gamma\geq0\)</span>, if it returns two sets <span class="math inline">\(S\subseteq A\subseteq\mathcal{N}\)</span> such that <span class="math inline">\(S\in\mathcal{I}\)</span>, and for all <span class="math inline">\(T\in\mathcal{I}\)</span> we have <span class="math display">\[
    \mathbb{E}[f(T\cup A)]\leq\alpha\mathbb{E}[f(S)]+\gamma
\]</span></p>
</div>
<p>现在我们来看看这个 framework, 记 <span class="math inline">\(\text{StreamingAlg}\)</span> 为输入的流算法, <span class="math inline">\(\text{ConstrainedAlg}\)</span> 为同一问题的 offline 算法.</p>
<div class="note info no-icon"><h3 id="alg.-1-non-monotone-data-stream-algorithm">(Alg. 1) Non-monotone Data Stream Algorithm</h3>
<p><strong>Input:</strong> a positive integer <span class="math inline">\(r\)</span><br />
<strong>Output:</strong> a set <span class="math inline">\(S\in\mathcal{I}\)</span><br />
Initialize <span class="math inline">\(r\)</span> independent copies of <span class="math inline">\(\text{StreamingAlg}\)</span>: <span class="math inline">\(\text{StreamingAlg}^{(1)},\dots,\text{StreamingAlg}^{(r)}\)</span><br />
<strong>while</strong> there are more elements in the stream <strong>do</strong><br />
  Let <span class="math inline">\(D_0\)</span> be a singleton set containing the next element of the stream<br />
  <strong>for</strong> <span class="math inline">\(i=1\)</span> to <span class="math inline">\(r\)</span> <strong>do</strong> <span class="math inline">\(D_i\leftarrow\text{StreamingAlg}^{(i)}(D_{i-1})\)</span><br />
Let <span class="math inline">\(D_0\leftarrow\emptyset\)</span><br />
<strong>for</strong> <span class="math inline">\(i=1\)</span> to <span class="math inline">\(r\)</span> <strong>do</strong><br />
  <span class="math inline">\((S_i,A_i,D_i)\leftarrow\text{StreamingAlg}^{(i)}_{\mathbf{end}}(D_{i-1})\)</span><br />
  <span class="math inline">\(S_i&#39;\leftarrow\text{ConstrainedAlg}(A_i)\)</span><br />
<strong>return</strong> the set <span class="math inline">\(S\)</span> maximizing <span class="math inline">\(f\)</span> among <span class="math inline">\(\{S_i,S_i&#39;\}_{i=1}^r\)</span></p>
</div>
<p>算法的思想很简单, 首先对每个到来的元素 <span class="math inline">\(u\)</span>, 使用 <span class="math inline">\(r\)</span> 个独立相同的 <span class="math inline">\(\text{StreamingAlg}\)</span> 程序来依次进行处理: 第一个程序的输入为 <span class="math inline">\(\{u\}\)</span>, 之后每个程序以被上一个程序扔出内存的部分 (可能是因为 constraint 不满足, 或者是因为部分元素被置换出去) 为输入进行处理. 当 stream 整个 pass 结束后, 仍按次序输出这 <span class="math inline">\(r\)</span> 个子程序的结果. 由于 <span class="math inline">\(\text{StreamingAlg}\)</span> 是 <span class="math inline">\((\alpha,\gamma)\)</span>-approximation 算法, 我们将集合 <span class="math inline">\(S,A\)</span> 输出, 同时也对集合 <span class="math inline">\(A\)</span> 跑一次 offline 程序 <span class="math inline">\(\text{ConstrainedAlg}\)</span>. 在输出 <span class="math inline">\(S,A\)</span> 的同时, 我们也将所有在该子程序内存中但不在 <span class="math inline">\(A\)</span> 中的数据构成的集合 <span class="math inline">\(D\)</span> 输出, 作为下一个子程序的输入 (第一个子程序的输入为空集). 这个过程可以简单描述成如下图所示.</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/20201203.png" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>仿佛就是 streaming 版本的 <a href="http://proceedings.mlr.press/v65/feldman17b/feldman17b.pdf">RepeatedGreedy</a> (实际上接下来的 Proposition 1 的推导完全类似 RepeatedGreedy 的近似比推导)</em></td>
</tr>
</tbody>
</table>
<p>对于这个框架, 我们有如下结论.</p>
<div class="note primary no-icon"><h4 id="proposition-1">Proposition 1</h4>
<p>Given an <span class="math inline">\((\alpha,\gamma)\)</span>-approximation data stream algorithm <span class="math inline">\(\text{StreamingAlg}\)</span> for maximizing a non-negative submodular function subject to some constraint and an offline <span class="math inline">\(\beta\)</span>-approximation algorithm <span class="math inline">\(\text{ConstrainedAlg}\)</span> for the same problem. There exists a data stream algorithm returning a feasible set <span class="math inline">\(S\)</span> that obeys <span class="math display">\[
  \mathbb{E}[f(S)]\geq\frac{(r-1)f(O)-r\gamma}{r\alpha+r(r-1)\beta/2}
\]</span> Furthermore,</p>
<ul>
<li>this algorithm is deterministic if <span class="math inline">\(\text{StreamingAlg}\)</span> and <span class="math inline">\(\text{ConstrainedAlg}\)</span> are both deterministic.</li>
<li>the space complexity of this algorithm is upper bounded by <span class="math inline">\(O(rM_{\text{StreamingAlg}}+M_{\text{ConstrainedAlg}})\)</span>, where <span class="math inline">\(M_{\text{StreamingAlg}}\)</span> and <span class="math inline">\(M_{\text{ConstrainedAlg}}\)</span> represent the space complexities of thier matching algorithms under the assumption that the input for <span class="math inline">\(\text{StreamingAlg}\)</span> is a subset of the full input and the input for <span class="math inline">\(\text{ConstrainedAlg}\)</span> is the <span class="math inline">\(A\)</span> set produced by <span class="math inline">\(\text{StreamingAlg}\)</span> on some such subset.</li>
</ul>
</div>
<h2 id="algorithms">Algorithms</h2>
<p>下面介绍论文提出的解决 <span class="math inline">\(k\)</span>-system 约束的算法. 为了方便分析, 先给出一个预先知道 <span class="math inline">\(M=\max_{u\in\mathcal{N},\{u\}\in\mathcal{I}}f(\{u\})\)</span> 和最大独立集大小 <span class="math inline">\(\rho\)</span> 的版本.</p>
<div class="note info no-icon"><h3 id="alg.-2-streaming-algorithm-for-k-system">(Alg. 2) Streaming Algorithm for <span class="math inline">\(k\)</span>-system</h3>
<p><strong>Input:</strong> a threshold <span class="math inline">\(\tau\in[M,2M]\)</span>, the size <span class="math inline">\(\rho\)</span> of the largest independent set, and parameter <span class="math inline">\(k\)</span> of the constraint<br />
<strong>Output:</strong> a solution <span class="math inline">\(T\in\mathcal{I}\)</span><br />
Let <span class="math inline">\(\ell\leftarrow\lfloor\log_2(4\rho)\rfloor\)</span> and <span class="math inline">\(h\leftarrow\lceil\log_2(2k+1)\rceil\)</span><br />
<strong>for</strong> <span class="math inline">\(i=0\)</span> to <span class="math inline">\(\ell\)</span> <strong>do</strong> Initialize <span class="math inline">\(E_i\leftarrow\emptyset\)</span><br />
<strong>for</strong> every element <span class="math inline">\(u\)</span> arriving <strong>do</strong><br />
  Let <span class="math inline">\(m(u)\leftarrow f(u|\cup_{i=0}^{\ell}E_i)\)</span><br />
  <strong>if</strong> <span class="math inline">\(m(u)&gt;0\)</span> <strong>then</strong> Let <span class="math inline">\(i(u)\leftarrow\lfloor\log_2(\tau/m(u))\rfloor\)</span> <strong>else</strong> Let <span class="math inline">\(i(u)\leftarrow\infty\)</span><br />
  <strong>if</strong> <span class="math inline">\(0\leq i(u)\leq\ell\)</span> and <span class="math inline">\(E_{i(u)}+u\in\mathcal{I}\)</span> <strong>then</strong> Update <span class="math inline">\(E_{i(u)}\leftarrow E_{i(u)}+u\)</span><br />
<strong>for</strong> <span class="math inline">\(j=0\)</span> to <span class="math inline">\(h-1\)</span> <strong>do</strong><br />
  Let <span class="math inline">\(i\leftarrow j\)</span> and <span class="math inline">\(T_j\leftarrow\emptyset\)</span><br />
  <strong>while</strong> <span class="math inline">\(i\leq\ell\)</span> <strong>do</strong><br />
    <strong>while</strong> there is an element <span class="math inline">\(u\in E_i\)</span> such that <span class="math inline">\(T_j+u\in\mathcal{I}\)</span> <strong>do</strong> Update <span class="math inline">\(T_j\leftarrow T_j+u\)</span><br />
    <span class="math inline">\(i\leftarrow i+h\)</span><br />
<strong>return</strong> the set <span class="math inline">\(T\)</span> maximizing <span class="math inline">\(f\)</span> among <span class="math inline">\(T_0,T_1,\dots,T_{h-1}\)</span></p>
</div>
<p>下面我们将详细分析一下这个算法的性质. 首先我们可以看出 Alg. 2 仍采用了类似 sieve 的方法. 那么, 在 streaming 条件下使用 threshold 有什么困难? 对 knapsack, 同时超过 threshold 且超过 budget 的元素可以对 threshold 设置成和 budget 相关的一个量来 bound 住这部分元素的值. 但对 <span class="math inline">\(k\)</span>-system, 如果硬上 multi-solution + threshold, 超过 threshold 但因 independent set 约束不能加入集合的这部分元素无法像 knapsack 那样简单地处理. 算法对不同 threshold 构造了 <span class="math inline">\(\ell\)</span> 个集合, 然后最终的结果通过在这 <span class="math inline">\(\ell\)</span> 个集合中按一定规则进行挑选得到. 首先我们需要说明集合 <span class="math inline">\(E\)</span> 的性质是好的, 这由以下引理保证.</p>
<div class="note default no-icon"><p><strong>Lemma 1:</strong> For every set <span class="math inline">\(S\in\mathcal{I}\)</span>, <span class="math display">\[
  f(E|\emptyset)\geq\dfrac{f(S\cup E|\emptyset)-\tau/4}{2k+1}
\]</span></p>
</div>
<p><strong><em>Proof Sketch of Lemma 1:</em></strong> 算法构造了 <span class="math inline">\(\ell+1\)</span> 个区间 <span class="math inline">\((2^{-(i+1)}\tau,2^{-i}\tau]\)</span> 和与之对应的集合 <span class="math inline">\(E_i\)</span>, <span class="math inline">\(i=0,1,\dots,\ell\)</span>. 每当 <span class="math inline">\(u\)</span> 到来时的 marginal gain 满足 <span class="math display">\[
    m(u)=f(u|\text{Pre}(u,E))\in (2^{-(i+1)}\tau,2^{-i}\tau]
\]</span> 时 (这里 <span class="math inline">\(E=\cup_{i=0}^{\ell}E_i\)</span>), 我们就将 <span class="math inline">\(u\)</span> 加入到 <span class="math inline">\(E_i\)</span> 中 (在满足 <span class="math inline">\(k\)</span>-system 条件约束下). 由 greedy 性质可知 <span class="math inline">\(E_i\)</span> 是 <span class="math inline">\(U_i=\{u\in\mathcal{N}:i(u)=i\}\)</span> 的一个 base, 再结合 <span class="math inline">\(U_i\)</span> 之间的不交性启发我们考虑 <span class="math inline">\(S\)</span> 在各 <span class="math inline">\(U_i\)</span> 中的部分: <span class="math inline">\(|S\cap U_i|\leq k|E_i|\)</span>, <span class="math inline">\(i=0,1,\dots,\ell\)</span>. 而对 <span class="math inline">\(i&lt;0\vee i&gt;\ell\)</span> 的部分, 我们就可以通过调整 <span class="math inline">\(\ell,\tau\)</span> 的值将其 bound 住.</p>
<p>由于我们现在得到的 <span class="math inline">\(E\)</span> 并不一定是 independet set, 所以我们需要从 <span class="math inline">\(E\)</span> 中选出满足约束条件的集合的同时, 也要要求其和 <span class="math inline">\(E\)</span> 能建立起某种联系 (方便近似比的导出). 下面来看这个关键的引理.</p>
<div class="note default no-icon"><p><strong>Lemma 2:</strong> For every integer <span class="math inline">\(0\leq j&lt;h\)</span> we have <span class="math display">\[
    f(T_j|\emptyset)\geq\frac{1}{4k}\sum_{\substack{0\leq i\leq\ell\\ i\equiv j\pmod{h}}}\sum_{u\in E_i}m(u)
\]</span></p>
</div>
<p><strong><em>Proof of Lemma 2:</em></strong> 由次模性 <span class="math display">\[
  f(T_j|\emptyset)=\sum_{u\in T_j}f(u|\text{Pre}(u,T_j))\geq\sum_{u\in T_j}f(u|\text{Pre}(u,E))=\sum_{u\in T_j}m(u)\tag{1}
\]</span> 我们记 <span class="math inline">\(T_j^i\)</span> 是从 <span class="math inline">\(E_j\)</span> 开始对 <span class="math inline">\(E_i\)</span> 做完 greedy 后得到的集合 (<span class="math inline">\(j\leq i\leq \ell, i\equiv j\pmod{h}\)</span>). 设 <span class="math inline">\(T_j^{j-h}=\emptyset\)</span>, 下面我们证明一个更强的结论 <span class="math display">\[
    \sum_{u\in T_j^i}m(u)\geq\frac{1}{4k}\sum_{\substack{j\leq r\leq i\\ r\equiv j\pmod{h}}}\sum_{u\in E_r}m(u)+\frac{|T_j^i|\tau}{2^{i+2}k},\quad \forall i\in[-h,\ell],\ i\equiv j(\text{mod}\ h)
\]</span> 我们对 <span class="math inline">\(i\)</span> 作归纳证明. 当 <span class="math inline">\(i&lt;0\)</span> 时, 显然不等式两边都为 0, 下面考虑 <span class="math inline">\(0\leq i\leq\ell\)</span> 的情况. 由于 <span class="math inline">\(T_j^{i}\)</span> 是 <span class="math inline">\(T_j^{i-h}\cup E_i\)</span> 的 base, 故 <span class="math inline">\(|E_i|\leq k|T_j^i|\)</span>, 再使用 <span class="math inline">\(i-h\)</span> 的归纳猜想, 我们有 <span class="math display">\[
  \begin{aligned}
    \sum_{u\in T_j^i}m(u)=&amp;\sum_{u\in T_j^i\backslash T_j^{i-h}}m(u)+\sum_{u\in T_j^{i-h}}m(u)\geq\Big(\frac{|E_i|}{k}-|T_j^{i-h}|\Big)\frac{\tau}{2^{i+1}}+\sum_{u\in T_j^{i-h}}m(u)\\
    \geq&amp;\frac{1}{4k}\sum_{u\in E_i}m(u)+\frac{|E_i|\tau}{2^{i+2}k}-\frac{|T_j^{i-h}|\tau}{2^{i+1}} + \frac{1}{4k}\sum_{\substack{j\leq r\leq i-h\\ r\equiv j\pmod{h}}}\sum_{u\in E_r}m(u)+\frac{|T_j^{i-h}|\tau}{2^{i-h+2}k}\\
    =&amp;\frac{1}{4k}\sum_{\substack{j\leq r\leq i\\ r\equiv j\pmod{h}}}\sum_{u\in E_r}m(u)+\frac{|E_i|\tau}{2^{i+2}k}+\frac{|T_j^{i-h}|\tau}{2^{i+2}k}(2^h-2k)\\
    \geq&amp;\frac{1}{4k}\sum_{\substack{j\leq r\leq i\\ r\equiv j\pmod{h}}}\sum_{u\in E_r}m(u)+\frac{|E_i|\tau}{2^{i+2}k}+\frac{|T_j^{i-h}|\tau}{2^{i+2}k}\\
    \geq&amp;\frac{1}{4k}\sum_{\substack{j\leq r\leq i\\ r\equiv j\pmod{h}}}\sum_{u\in E_r}m(u)+\frac{|T_j^i|\tau}{2^{i+2}k}
  \end{aligned}
\]</span> 故由归纳法知结论成立. 取 <span class="math inline">\(i=j+h\lfloor(\ell-j)/h\rfloor\)</span> 结合式 <span class="math inline">\((1)\)</span> 即知 Lemma 2 欲证式成立, 证毕.</p>
<div class="note primary no-icon"><h4 id="proposition-2">Proposition 2</h4>
<p>Alg. 2 stores <span class="math inline">\(O(\rho(\log\rho+\log k))\)</span> elements at every given time point. For a <span class="math inline">\(k\)</span>-system <span class="math inline">\((\mathcal{N},\mathcal{I})\)</span>, the algorithm returns a set <span class="math inline">\(T\)</span> such that <span class="math display">\[
    f(T)\geq\frac{f(E\cup S)-\tau/4}{4kh(2k+1)}
\]</span> for every set <span class="math inline">\(S\in\mathcal{I}\)</span>.</p>
</div>
<p><strong><em>Proof of Proposition 2:</em></strong> space complexity 是显然的. 另外可由 <span class="math display">\[
    \begin{aligned}
      f(T)\geq&amp;\frac{\sum_{j=0}^{h-1}f(T_j)}{h}\geq f(\emptyset)+\frac{1}{4kh}\sum_{j=0}^{h-1}\sum_{\substack{0\leq i\leq\ell\\ i\equiv j\pmod{h}}}\sum_{u\in E_i}m(u)\\
      =&amp;f(\emptyset)+\frac{1}{4kh}\sum_{i=0}^{\ell}\sum_{u\in E_i}m(u)\geq f(\emptyset)+\frac{f(E|\emptyset)}{4kh}\geq\frac{f(E\cup S)-\tau/4}{4kh(2k+1)}
    \end{aligned}
\]</span> 得到.</p>
<p>有了 Proposition 2 后我们就可以来分析对单调和非单调的目标函数的结果了. 当目标函数 <span class="math inline">\(f\)</span> 是单调的时候直接使用 Alg. 2 即可: 取 <span class="math inline">\(U=O\)</span>, 再由 <span class="math inline">\(\tau\leq2M\leq 2f(O)\)</span>, 得到 <span class="math display">\[
    f(T)\geq\frac{f(O)-f(O)/2}{4kh(2k+1)}\Rightarrow f(O)\leq8kh(2k+1)f(T)
\]</span> 而对于非单调的情形我们需要采用 Alg. 1 框架: 取 <span class="math inline">\(A=E\)</span> 根据定义可知 Alg. 2 是一个 <span class="math inline">\((4kh(2k+1),\tau/4)\)</span>-approximation 的 streaming 算法. 我们使用 Alg. 2 作为 Alg. 1 中的 <span class="math inline">\(\text{StreamingAlg}\)</span>, 使用 <a href="http://proceedings.mlr.press/v65/feldman17b/feldman17b.pdf">RepeatedGreedy</a> (此时 <span class="math inline">\(\beta=k+O(\sqrt{k})\)</span>) 作为 Alg. 1 中的 <span class="math inline">\(\text{ConstrainedAlg}\)</span>, 取 <span class="math inline">\(r=4\)</span> 就有 <span class="math display">\[
    f(T)\geq\frac{(4-1)f(O)-\tau}{4\alpha+6\beta}\geq\frac{3f(O)-2f(O)}{16kh(2k+1)+6(k+O(\sqrt{k}))}\Rightarrow f(O)\leq O(k^2\log k)f(T)
\]</span> 所以综合以上两种情况我们就有如下关于近似比的结论.</p>
<div class="note primary no-icon"><h4 id="proposition-3">Proposition 3</h4>
<p>There is a streaming <span class="math inline">\(O(k^2\log k)\)</span>-approximation algorithm for the problem of maximizing a non-negative submodular function subject to a <span class="math inline">\(k\)</span>-system constraint.</p>
</div>
<p>对于更强的 <span class="math inline">\(k\)</span>-extendible 约束, 有稍好的结果 (证略).</p>
<div class="note primary no-icon"><h4 id="proposition-4">Proposition 4</h4>
<p>There is a streaming <span class="math inline">\(O(k\log k)\)</span>-approximation algorithm for the problem of maximizing a non-negative submodular function subject to a <span class="math inline">\(k\)</span>-extendible system constraint.</p>
</div>
<p>由于无法预先知道 <span class="math inline">\(M,\rho\)</span>, 文章采取了逐步减弱条件的方式来达到同样效果.</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>submodular maximization</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>同人 h 本画师收集</title>
    <url>/2020/11/10/illustrator_recommendation_s/</url>
    <content><![CDATA[<p>懂的都懂。</p>
<a id="more"></a>
<ol type="1">
<li><p><strong>YD</strong>  隶属社团：Orangemaru<br />
(COMIC1☆13) [OrangeMaru (YD)] スキル強化解禁 + OrangeMaru Special 04 (Fate/Grand Order)<br />
(COMIC1☆11) [OrangeMaru (YD)] TOKIMEKI ニオイ (アイドルマスター シンデレラガールズ)</p></li>
<li><p><strong>北原亜希</strong>  隶属社团：秘密結社M<br />
(C92) [秘密結社M (北原亜希)] 詩羽アナザーバッドエンド (冴えない彼女の育てかた)<br />
(C91) [秘密結社M (北原亜希)] 妊娠しちゃった...誰か「たすけて」。 (美少女戦士セーラームーン)</p></li>
<li><p><strong>あるぷ</strong>  隶属社团：リンゴヤ<br />
(C97) [リンゴヤ (あるぷ)] 松浦の休日 (ラブライブ！サンシャイン!!)<br />
(C96) [リンゴヤ (あるぷ)] 高海の休日～2日目～<br />
p.s. 此人非常肝，量大质高，强力推荐</p></li>
<li><p><strong>酔っ払い鬼?</strong>  隶属社团：CORORI<br />
(C94) [CORORI (酔っ払い鬼?)] かなかん身代わり果南ちゃんふんばルビィ! (ラブライブ! サンシャイン!!)<br />
(C97) [CORORI (酔っ払い鬼?)] かなかん 果南ちゃん大ピンチ(拉致編) (ラブライブ! サンシャイン!!)</p></li>
<li><p><strong>いちたか</strong>  隶属社团：Crazy9<br />
(C93) [Crazy9 (いちたか)] C9-33 女神様のハジメテ エレシュキガルの場合 (Fate/Grand Order)<br />
(COMIC1☆10) [Crazy9 (いちたか)] C9-24 鹿島とハジメテ (艦隊これくしょん -艦これ-)</p></li>
<li><p><strong>アサヒナヒカゲ</strong>  隶属社团：アカペンギン<br />
(C97) [アカペンギン (アサヒナヒカゲ)] 桐須先生が教える保健体育 (ぼくたちは勉強ができない)<br />
(C92) [アカペンギン (アサヒナヒカゲ)] たわわな後輩ちゃん (月曜日のたわわ)</p></li>
<li><p><strong>たまごろー</strong>  隶属社团：フニフニラボ<br />
(C97) [フニフニラボ (たまごろー)] たびのきろくに (ポケモンマスターズ)<br />
(C92) [フニフニラボ (たまごろー)] マオフレンズ (ポケットモンスター)</p></li>
<li><p><strong>きくらげ</strong>  隶属社团：きくらげ屋<br />
(C87) [きくらげ屋 (きくらげ )] 恋姦6 [中国翻訳]<br />
(C86) [きくらげ屋 (きくらげ )] 黒のリーマンと妖精姫エルニース<br />
p.s. 这位失联了</p></li>
<li><p><strong>白野ジア</strong>  隶属社团：シロジア<br />
(C93) [シロジア (白野ジア)] ゆきのひ。 (やはり俺の青春ラブコメはまちがっている。)<br />
[シロジア (白野ジア)] がまんして、ほしがって。 (やはり俺の青春ラブコメはまちがっている。)</p></li>
<li><p><strong>愛上陸</strong>  隶属社团：50on!<br />
(C95) [50on! (愛上陸)] 催眠性指導 倉敷麗華の場合<br />
(C96) [50on! (愛上陸)] 催眠性指導4 妊娠体験指導</p></li>
<li><p><strong>あらくれ</strong>  隶属社团：あらくれた者たち<br />
[あらくれた者たち (あらくれ)] 最高に食べごろの夜<br />
[あらくれた者たち (あらくれ)] 寝取られた人妻と寝取られる人妻</p></li>
<li><p><strong>キチロク</strong>  隶属社团：第6基地<br />
(C96) [第6基地 (キチロク)] 推シツケ<br />
(C97) [第6基地 (キチロク)] 女子大生高坂穂乃果のヤリサー事件簿 (ラブライブ!)</p></li>
<li><p><strong>イシガキタカシ</strong>  隶属社团：Type-G<br />
[Type-G (イシガキタカシ)] 雌神楽 -フェイト編1- (魔法少女リリカルなのは) [DL版]<br />
(C83) [Type-G (イシガキタカシ)] 桜花散る！ (マブラヴ オルタネイティブ トータル・イクリプス)<br />
p.s. 这位现在很少画同人了，目前是alicesoft的主力画师之一</p></li>
<li><p><strong>冷泉、和泉</strong>  隶属社团：サイクロン<br />
(C94) [サイクロン (冷泉、和泉)] T-32 hooollow (Fate/Grand Order)<br />
(C92) [サイクロン (和泉、冷泉)] T-30 Do (Fate/Grand Order)</p></li>
<li><p><strong>kiasa</strong>  隶属社团：ジョウ・レン騎士団<br />
(C90) [ジョウ・レン騎士団 (kiasa)] 青子BLUE IF (魔法使いの夜)<br />
(C93) [ジョウ・レン騎士団 (kiasa)] 桜檻 弐 (Fate/stay night) [中国翻訳]<br />
p.s. 是个樱厨</p></li>
<li><p><strong>ぐすたふ</strong>  隶属社团：てろめあな<br />
(C96) [てろめあな (ぐすたふ)] 水着の下の誘惑 (アイドルマスター シンデレラガールズ)<br />
(C95) [てろめあな (ぐすたふ)] 美波だって誘惑しますよ? (アイドルマスター シンデレラガールズ)<br />
p.s. 新田美波忠实单推人，产能不高但质量很棒</p></li>
<li><p><strong>クロエ</strong>  隶属社团：Sugar<em>Berry</em>Syrup<br />
(COMIC1☆15) [Sugar<em>Berry</em>Syrup (クロエ)] 恥辱の痴漢電車4～彼氏にせがまれ痴漢電車に乗った少女～<br />
[Sugar<em>Berry</em>Syrup (クロエ)] 淫溺の令嬢5 ～冷たいくちづけ～ + 蜜瓜特典</p></li>
<li><p><strong>清炭ハリケーン</strong>  隶属社团：清炭ハリケーン<br />
(C93) [清炭ハリケーン (清炭ハリケーン)] ONE-HURRICANE 6 (ワンパンマン)<br />
(C88) [清炭ハリケーン (清炭ハリケーン)] ONE-HURRICANE 囚われのフブキ (ワンパンマン)</p></li>
<li><p><strong>八尋ぽち</strong>  隶属社团：ぽぽちち<br />
[ぽぽちち (八尋ぽち)] レンタル彼女お触りします (彼女、お借りします)<br />
[ぽぽちち (八尋ぽち)] レンタル彼女お触りします02 (彼女、お借りします)</p></li>
<li><p><strong>稲鳴四季</strong>  隶属社团：studio A<br />
[studio A (稲鳴四季)] 奉仕部のいやらしい慰安旅行。 (やはり俺の青春ラブコメはまちがっている。)<br />
[studio A (稲鳴四季)] ある日の火照った女の子達。 (やはり俺の青春ラブコメはまちがっている。)</p></li>
<li><p><strong>アズマサワヨシ</strong>  隶属社团：A・L・L<br />
[A・L・L (アズマサワヨシ)] ご指名は？マリーちゃんで！ (デッド・オア・アライブ)<br />
[アズマサワヨシ] あやかし館へようこそ!<br />
p.s. 这位彻底上岸了</p></li>
<li><p><strong>みちきんぐ</strong>  隶属社团：あんみつよもぎ亭<br />
(C97) [あんみつよもぎ亭 (みちきんぐ)] わちきは赤ちゃんになり申した (東方Project)<br />
(C96) [あんみつよもぎ亭 (みちきんぐ)] ANMITSU TOUHOU THE AFTER Vol.2 (東方Project)</p></li>
<li><p><strong>あきのそら</strong>  隶属社团：ぺたパン<br />
(C91) [ぺたパン (あきのそら)] IROHA STORY 01 (やはり俺の青春ラブコメはまちがっている。)<br />
(C88) [ぺたパン (あきのそら)] LOVE STORY #02 (やはり俺の青春ラブコメはまちがっている。)<br />
p.s. 水陆两栖，同人本现在画得少了</p></li>
<li><p><strong>きょくちょ</strong>  隶属社团：きょくちょ局<br />
[きょくちょ局 (きょくちょ)] 遠坂姉妹凌辱-凛編- (Fate/stay night)<br />
[きょくちょ局 (きょくちょ)] 凛辱 (Fate/stay night)</p></li>
<li><p><strong>中乃空</strong>  隶属社团：In The Sky<br />
[In The Sky (中乃空)] 姉を寝取った日<br />
(C97) [In The Sky (中乃空)] 北斎純情乙女噺 (Fate/Grand Order)</p></li>
<li><p><strong>なかじまゆか</strong>  隶属社团：Digital Lover<br />
[Digital Lover (なかじまゆか)] 人妻幼馴染とひと夏のできごと3 DLO-14<br />
[Digital Lover (なかじまゆか)] 人妻幼馴染とひと夏のできごと DLO-07</p></li>
<li><p><strong>智弘カイ</strong>  隶属社团：Ink Complex<br />
(C97) [Ink Complex (智弘カイ)] 秘公開プラン<br />
(C92) [Ink Complex (智弘カイ)] The Dark Side of the Moon (アイドルマスター シンデレラガールズ)</p></li>
<li><p><strong>立花オミナ</strong>  隶属社团：しまぱん<br />
[しまぱん (立花オミナ)] P5ハーレム～双葉編～ (ペルソナ5)<br />
[しまぱん (立花オミナ)] P5ハーレム (ペルソナ5)</p></li>
<li><p><strong>桃屋しょう猫</strong>  隶属社团：U.R.C</p></li>
<li><p><strong>つかこ</strong>  </p></li>
<li><p><strong>井藤ななみ</strong>  </p></li>
<li><p><strong>朝峰テル</strong>  </p></li>
</ol>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>manga</tag>
        <tag>xp</tag>
        <tag>lsp</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 数学考试问题</title>
    <url>/2021/06/17/mathsexam2021_z/</url>
    <content><![CDATA[<p>(这篇是水博客用的, 不过总感觉好像之前也干过类似的事.)</p>
<a id="more"></a>
<p>现在高考全国卷好像分四套了: 甲卷、乙卷、一卷、二卷，感觉总体上有题目一年出得比一年差的趋势.</p>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>(高考全国甲卷)</strong> 已知 <span class="math inline">\(a&gt;0\)</span> 且 <span class="math inline">\(a\neq1\)</span>, 函数 <span class="math inline">\(f(x)=\frac{x^a}{a^x},\ x&gt;0\)</span>.</p>
<ol type="1">
<li>当 <span class="math inline">\(a=2\)</span> 时, 求 <span class="math inline">\(f(x)\)</span> 的单调区间;</li>
<li>若曲线 <span class="math inline">\(y=f(x)\)</span> 与直线 <span class="math inline">\(y=1\)</span> 有且仅有两个交点, 求 <span class="math inline">\(a\)</span> 的取值范围.</li>
</ol>
</div>
<p><strong><em>Sketch:</em></strong><br />
即解 <span class="math display">\[
      \frac{x^a}{a^x}=1\quad\Rightarrow\quad f(x)=\frac{\ln x}{x}=\frac{\ln a}{a}=f(a)
  \]</span> 注意到 <span class="math inline">\(\frac{\ln x}{x}\)</span> 在 <span class="math inline">\((0,\mathrm e)\)</span> 增, 在 <span class="math inline">\((\mathrm e,\infty)\)</span> 减. 故若想要方程有两解, 则需 <span class="math inline">\(f(a)&lt;\mathrm e^{-1}\)</span>. 注意到 <span class="math inline">\(f(0-)=-\infty,f(+\infty)=+0\)</span>, 由单调性, 我们还需要 <span class="math inline">\(f(a)&gt;0\)</span>. 故所求 <span class="math inline">\(a\)</span> 的取值范围为 <span class="math display">\[
      f^{-1}\Big((0,\mathrm e^{-1})\Big) = (1,\mathrm e)\cup(\mathrm e,+\infty)
  \]</span> <br/></p>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>(高考全国一卷)</strong> 已知函数 <span class="math inline">\(f(x)=x(1-\ln x)\)</span>.</p>
<ol type="1">
<li>讨论 <span class="math inline">\(f(x)\)</span> 的单调性;</li>
<li>设 <span class="math inline">\(a,b\)</span> 为两个不相等的正数, 且 <span class="math inline">\(b\ln a-a\ln b=a-b\)</span>. 证明: <span class="math inline">\(2&lt;\frac1a+\frac1b&lt;\mathrm e\)</span>.</li>
</ol>
</div>
<p><strong><em>Sketch:</em></strong><br />
稍作整理可知 <span class="math inline">\(a,b\)</span> 满足 <span class="math inline">\(f(a^{-1})=f(b^{-1})\)</span>. 由于 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((0,1)\)</span> 上增, 在 <span class="math inline">\((1,\mathrm e)\)</span> 上减, 且在 <span class="math inline">\((0,\mathrm e)\)</span> 上为正, 在 <span class="math inline">\((\mathrm e,\infty)\)</span> 为负. 故条件可变为 <span class="math display">\[
      0&lt;x_1&lt;1&lt;x_2&lt;\mathrm e,\quad\text{s.t.}\quad f(x_1)=f(x_2)
  \]</span> 我们对 <span class="math inline">\(d=1-x_1\in(0,1)\)</span> 考虑 <span class="math display">\[
    f(1+d)-f(1-d)=\int_{1-d}^{1+d}f&#39;(t)\mathrm dt=\int_0^d\Big(f&#39;(1-t)+f&#39;(1+t)\Big)\mathrm dt
  \]</span> 注意到 <span class="math inline">\(f&#39;(1-t)+f&#39;(1+t)=-\ln(1-t^2)&gt;0,\ \forall t\in(0,d)\)</span>, 故 <span class="math inline">\(f(1+d)&gt;f(1-d)\)</span>, 结合 <span class="math inline">\(f(x_2)=f(1-d)\)</span> 与 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((1,\mathrm e)\)</span> 递减可得 <span class="math display">\[
      x_2&gt;1+d=2-x_1\quad\Rightarrow\quad x_1+x_2&gt;2
  \]</span> 另一方面, 注意到 <span class="math inline">\(x+y=\mathrm e\)</span> 在 <span class="math inline">\((\mathrm e,0)\)</span> 处与 <span class="math inline">\(y=f(x)\)</span> 相切且 <span class="math inline">\(f\)</span> 为凹, 故我们有 <span class="math display">\[
      x_2&lt;\mathrm e-f(x_1)\quad\Rightarrow\quad x_1+x_2&lt;\mathrm e+x_1\ln x_1&lt;\mathrm e
  \]</span> 综合上述两方面即得证. <br/><br/></p>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>(考研数一)</strong> 设 <span class="math inline">\(D\subset\mathbb R^2\)</span> 是有界单连通闭区域, 积分 <span class="math display">\[
    I(D) = \iint_D(4-x^2-y^2)\mathrm dx\mathrm dy
\]</span> 取得最大值的积分区域记为 <span class="math inline">\(D_1\)</span>.</p>
<ol type="1">
<li>求 <span class="math inline">\(I(D_1)\)</span> 的值;</li>
<li>计算 <span class="math display">\[
     \oint_{\partial D_1^+}\frac{(x\mathrm e^{x^2+4y^2}+y)\mathrm dx+(4y\mathrm e^{x^2+4y^2}-x)\mathrm dy}{x^2+4y^2}
  \]</span></li>
</ol>
</div>
<p><strong><em>Sketch:</em></strong><br />
显然 <span class="math inline">\(D\)</span> 为 <span class="math inline">\(D_1=\{(x,y)\in\mathbb R^2\mid x^2+y^2\leq4\}\)</span> 时积分取得最大值. 记第 2 问中所求积分为 <span class="math inline">\(J\)</span>, 利用 Green 公式 <span class="math display">\[
\begin{aligned}
  J&amp;=\oint_{\partial D_1^+}\frac{(x\mathrm e^{4+3y^2}+y)\mathrm dx+(4y\mathrm e^{4+3y^2}-x)\mathrm dy}{4+3y^2}\\
  &amp;=\iint_{D_1}\frac{-1}{(4+3y^2)^2}\bigg(8+(18xy+18xy^3)\mathrm e^{4+3y^2}\bigg)\mathrm dx\mathrm dy\\
  &amp;=-8\iint_{D_1}\frac{\mathrm dx\mathrm dy}{(4+3y^2)^2}\\
  &amp;=-32\int_0^{\pi/2}\!\!\!\!\int_0^2\frac{r}{(4+3r^2\sin^2\theta)^2}\mathrm dr\mathrm d\theta:=-32J&#39;
\end{aligned}
\]</span> 其中第三个等号的成立是对固定 <span class="math inline">\(y\)</span>, 被积为 <span class="math inline">\(x\)</span> 的奇函数; 第四个等号为极坐标代换. 下面我们来求 <span class="math inline">\(J&#39;\)</span>, 对分母作代换 <span class="math inline">\(s=4+3r^2\sin^2\theta\)</span>, 则 <span class="math display">\[
\begin{aligned}
  J&#39;&amp;=\int_{0}^{\pi/2}\frac{\mathrm d\theta}{6\sin^2\theta}\int_{4}^{4+12\sin^2\theta}\frac{\mathrm ds}{s^2}\\
  &amp;=\frac{1}{8}\int_{0}^{\pi/2}\frac{1}{1+3\sin^2\theta}\mathrm d\theta\quad\text{代换: }t=\tan\theta\\
  &amp;=\frac18\int_{0}^{\infty}\frac{1}{1+4t^2}\mathrm dt\\
  &amp;=\frac{1}{16}\tan^{-1}(2t)\bigg|_{0}^{\infty}=\frac{\pi}{32}
\end{aligned}
\]</span> 故所求结果为 <span class="math inline">\(J=-32J&#39;=-\pi\)</span>.</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>maths</tag>
      </tags>
  </entry>
  <entry>
    <title>pdf test</title>
    <url>/2021/03/12/pdftest_z/</url>
    <content><![CDATA[<center>
<strong>Here is a pdf file.</strong>
</center>
<a id="more"></a>
<p><br></p>
<p><div class="pdfobject-container" data-target="/notes.pdf" data-height="1000px"></div> <!-- <object data="/files/notes.pdf" type="application/pdf" width="100%" height="877px"> --></p>
<p><br></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>study notes</tag>
        <tag>submodular maximization</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>料理日常</title>
    <url>/2021/08/18/ryourinichijou_z/</url>
    <content><![CDATA[<p>（自用，记录）</p>
<a id="more"></a>
<div class="note primary no-icon"><!-- #### No icon note -->
<p><strong>芋头、藕炖排骨：</strong></p>
<ol type="1">
<li>排骨早早泡水，用时清洗。藕去皮、清洗、切块，用盐浸渍；</li>
<li>准备一锅清水，加入生姜片、花椒、料酒少许，将清洗好的排骨加入后点火加热（焯水）。在焯水的同时准备另一锅（砂锅）清水放入生姜和花椒，加热；</li>
<li>排骨焯水完成捞出，将锅清空加热后倒入少许清油，待油热后（小烟）将排骨倒入翻炒至表面变黄（几十秒即可），关火捞出排骨；</li>
<li>清洗煸炒完成的排骨和用盐浸渍的藕，当砂锅中的水开后，将藕和排骨放入砂锅；</li>
<li>藕和排骨需要炖煮 90~120min，在结束前 30~40min 时将洗好的芋头加入，起锅前 10min 左右加盐调味；</li>
<li>出锅开恰。</li>
</ol>
<p><strong><em>RMK：</em></strong></p>
<ul>
<li>炖排骨使用的藕较老，所以炖煮时间较长（大块、老猪排骨也相应地需要长时间炖煮）。在处理时用盐浸渍藕也是使其能更快煮软</li>
<li>肉类焯水是冷水入锅，否则破坏口感。焯水时大火冲开后翻动排骨使其受热均匀，最终排骨要完全变色才起锅</li>
<li>在炖前用油过一遍排骨是让排骨的最终口感更香。在油煸时由于排骨中含水，可将火调小后再加入排骨，等水汽蒸发后再将火开大</li>
<li>同样，为了使排骨更快煮软，可以在加入排骨到砂锅后再加入一点醋，用大火冲开后再加入藕。如果想要有葱香味儿，可以在这个时候取几段葱捆在一起投入锅中</li>
<li>芋头易氧化变色，所以我们在要用的时候才处理它。如果提前去皮，最好浸泡在水中</li>
<li>龙骨肉嫩但少，适合炖汤。又想恰肉又想喝汤的话可以选用肋排</li>
</ul>
</div>
<div class="note primary no-icon"><!-- #### No icon note -->
<p><strong>猪肉圆子汤：</strong></p>
<ol type="1">
<li>肉洗净剁碎成泥，放入大碗，加入少许生抽、老抽和蚝油；</li>
<li>加入姜末和花椒面，按一个方向拌匀；</li>
<li>加入少许蛋清液（半到一个蛋的量），加入红苕淀粉，再加入少量清水，继续搅拌至均匀糊状；</li>
<li>加入少许香葱末，继续拌匀；</li>
<li>起锅烧清水至沸腾，关小火，将肉馅团成圆球放入锅中，轻轻搅动后关好锅盖，用中火烧沸；</li>
<li>继续搅动圆子，调至中小火，关盖继续焖煮 5~7min，加入配菜；</li>
<li>待配菜煮熟，起锅前加入少许的盐和鸡精调味即可。</li>
</ol>
<p><strong><em>RMK：</em></strong></p>
<ul>
<li>做圆子使用的是猪的前胛肉</li>
<li>在上述第 2 步的搅拌过程中要加入两到三次<strong>少量</strong>清水，然后反复搅拌，直至肉有相当黏性、筷子能直立在其中，再进入下一步的加料搅拌</li>
<li>可以根据自己的喜好加入配菜，例如西红柿、白菜、冬瓜片、黄瓜、木耳等（西红柿需要提前煸炒出汁）</li>
<li>起锅前调味时可加入少量香油和香葱花</li>
</ul>
</div>
<div class="note primary no-icon"><!-- #### No icon note -->
<p><strong>红烧排骨：</strong></p>
<ol type="1">
<li>先将宰好的排骨放入清水中浸泡 1h 左右；</li>
<li>将排骨洗净，以冷水下锅，然后锅中加入姜片、花椒和料酒，大火煮沸；</li>
<li>排骨捞出，用热水反复清洗干净，控水备用；</li>
<li>起锅烧油（油温五六成热，例如菜籽油刚有小烟），放入姜片、花椒炒香至变黄收缩，然后捞出；</li>
<li>放入排骨，中火煸炒，将水气煸干后放入少许豆瓣酱于油中煸香，反复翻炒，炒至排骨变色（呈淡黄色），加入沸水直至淹没排骨；</li>
<li>大火冲开后转至小火慢慢炖煮，放入少许白砂糖或冰糖与少许醋，加入少许老抽调色，继续炖煮约 90~120min；</li>
<li>起锅前使用大火收汁，此时可以加入适量生抽或盐提味（可再加点鸡精）。</li>
</ol>
<p><strong><em>RMK：</em></strong></p>
<ul>
<li>浸泡是为了去除血水以及杂质</li>
<li>在排骨烧好前 30min 左右加入配菜，如土豆、红萝卜、四季豆等（土豆需要用油煎至半透明状，再加入到排骨中一起炖煮，这是为了防止土豆煮烂）</li>
</ul>
</div>
<div class="note primary no-icon"><!-- #### No icon note -->
<p><strong>炒肉丝（肉片）：</strong></p>
<ol type="1">
<li>先将生肉片成薄片，然后切成丝，装盘备用；</li>
<li>准备姜末、蒜末少许，放入切好的肉丝中，再加入花椒面和少许耗油、生抽、老抽，顺时针同方向边加水边拌匀；</li>
<li>加入适量淀粉，在淀粉上淋入水，然后继续顺时针拌匀，然后准备配菜；</li>
<li>起锅烧油，放入适量的肥肉片，爆出肥油，此时下入半勺豆瓣酱煸炒香，然后放入拌好的肉丝，快速滑散至肉变色，然后加入少许开水，继续翻炒，加入配菜，待菜熟后即可起锅。</li>
</ol>
<p><strong><em>RMK：</em></strong></p>
<ul>
<li>第 2 步加水为少量多次添加，一般为 2~3 次，需搅拌至水被肉充分吸收</li>
<li>第 3 步配菜例（青椒炒肉、芹菜胡萝卜炒肉）：青椒洗净切丝，用少许的盐抓拌均匀备用（若是芹菜就洗净切段，胡萝卜切丝焯水备用）</li>
</ul>
</div>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>蒜香青椒茄子：</strong></p>
<ol type="1">
<li>茄子洗净切片，用清水浸泡。切蒜末、姜末备用。尖椒洗净切丝，用少许的盐码匀备用；</li>
<li>起锅烧油，放入青椒丝煸炒，然后放入蒜末、姜末炒香；</li>
<li>茄子捞出控水，倒入锅中翻炒至茄子变软变色；</li>
<li>放入少许老抽调色，再放入适当的盐和醋调味，继续炒至入味。起锅时加入少许鸡精和生抽即可。</li>
</ol>
<p><strong><em>RMK：</em></strong></p>
<ul>
<li>煸炒青椒丝需要炒断生（变色）</li>
<li>调理根据个人口味调整即可</li>
</ul>
</div>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>炝炒藤藤菜：</strong></p>
<ol type="1">
<li>择菜：掐菜尖和叶子来炒；</li>
<li>将择好的菜浸泡在盐水中备用；</li>
<li>切两到三个干红辣椒、两半蒜末、少许姜末，取出藤藤菜用清水洗净；</li>
<li>起锅烧油，加入切好的料炒香，将菜下锅翻炒直到菜变色；</li>
<li>加入少许的盐和鸡精即可起锅。</li>
</ol>
<p><strong><em>RMK：</em></strong></p>
<ul>
<li>菜尖一般掐成两到三段，如果接下来部分较嫩，可以继续掐来使用。叶子只取不烂、无白色虫卵的部分。剩下的菜杆部分作他用</li>
<li>炒料时一般用中小火，加入菜后用大火快速翻炒</li>
</ul>
</div>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>莴笋胡萝卜丝炒鸡蛋：</strong></p>
<ol type="1">
<li>胡萝卜切丝焯水，莴笋切丝后用少许盐抓拌均匀，腌制一会儿后用清水淘干净后控干水备用；</li>
<li>起锅烧油炒鸡蛋，捞出鸡蛋后，放入少许姜末蒜末煸香，再加入胡萝卜和莴笋丝，炒熟后汇入鸡蛋炒匀，加入少许的盐和鸡精即可起锅。</li>
</ol>
</div>
<div class="note info no-icon"><!-- #### No icon note -->
<p><strong>青椒炒土豆丝：</strong></p>
<ol type="1">
<li>土豆切丝，清水淘洗，控水备用，青椒类似上面处理；</li>
<li>起锅烧油，放入少许姜末蒜末煸香，再加入青椒丝煸炒香，然后加入土豆丝，快速翻炒，期间淋入少许开水继续煸炒至菜熟，起锅时加盐和鸡精即可。</li>
</ol>
</div>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>recipe</tag>
      </tags>
  </entry>
  <entry>
    <title>笔名“愚夜观”的由来</title>
    <url>/2021/05/18/penname_dariy_s/</url>
    <content><![CDATA[<p>       我原本是不太想用“愚夜观”这个笔名的。在如今社会，写一些随笔和感想还需要一个额外的笔名，其实是没啥必要的，毕竟谁都会有个网名。QQ，微信，贴吧，知乎，微博，随便拿一个昵称即可当作笔名来使用，额外去构思一个笔名反倒是成为了一件吃力不讨好的事。更何况自己也只是随便写写，既没有深邃的思想，也没有令人称奇的文采，都是些没人看的玩意儿。好巧不巧，昨日与好友 T 君的一番争吵辩驳，事后引得自己反复思量，回忆起自己写过的东西，便构思出了“愚夜观”这个名字。而今只好简单写写这个名字的意思，也便日后别人问起以作解释。</p>
<a id="more"></a>
<p>       <strong>“愚”者，“愚钝”也，也就是“不聪明”的意思。</strong>我终究不是什么哲学家或思想家，想的东西可以说只是一些随性的碎碎念，并不想可以表达什么特别深邃的哲学思想；我也终究不是什么文学大家，写的东西可以说只是讲脑中所想直接表达出来的散文杂章，或更贴近于随笔，和平日微博朋友圈空间动态的小作文也没太大区别。愚者之所言，自然大多是主观色彩浓厚，不太聪明的拙见，读者见到当饭后茶余的消遣即可。如此所想，“愚”一字倒也给了自己提前留了退路。更多的原因，则是因为我写的内容，尤其是小诗篇，常用“雨”这个意相，所以取了“雨”的谐音“愚”作为这个笔名的构成。</p>
<p>       <strong>“观”者，“目之所见”也，也就是“看”的意思。</strong>既然是“看”，那么我写的大多都结合了自己的所见，而不是硬要去说明什么现象或者阐述什么道理。就算从主观上说了什么东西，也仅仅停留在了“看”的程度上。然与单纯的“看”不同的，“观”是“细看”，从“观察”、“观赏”等词汇不难看出有这层含义。既然是“细看”，“看”之后的“想”应是并不可少的，不然先不管是不是真的细丝缜密地看半天之后整理出的感想，“细”的意义就全无了，再者写的东西也体现不了什么“细”。除此之外，“观”也有“对事物的认识或看法”这层含义，“人生观”、“世界观”、“客观”等词汇体现就是如此应用。想说自己写的也算是一种看法想法，至于这种看法合不合理，我想“愚”一字可以尽然，至于他人的观点，我就不得而知了。</p>
<p>       <strong>至于为何是“夜观”？与“愚”类似，因为我写的小诗篇中，常取“夜”这个意相，因而便留下了“夜”这个字。</strong>进一步的理由，则是因为夜晚之所见与白天会有不同：白日是明亮的、美好的、大家都能看见的；与之相反，夜晚看到的则是藏在暗处不会暴露在阳光下的东西，并且这些东西往往每个人只能看到自己的，别人是看不见的。同时，不明亮的夜也能让人沉醉于深思，思前想后一番，才能在白天接着做自己该做的事，想做的事。不得不承认，如此“夜观”，颇有一种“世人皆醉我独醒”的傲慢与偏见，倒是和“愚”不相而和，也算是自己对自己的一种调侃。</p>
<p>       以上便是“愚夜观”这名字的由来。其实除了“愚夜观”这个名字之外，我同时想了“余夜观”、“于夜观”、“愚晚睹”等多个名字以作备用，用作自己写了不合人心的东西之后的挡箭牌。但想到自己写的更多是出于自娱自乐，就觉得笔名怎样，一个足以表意的足矣。行文之际，自己竟乐观地想到以后如果自己的内容能有机会整理成集，此文亦可当作开篇的序。不管怎么说，以后的一些文章，大多会采用“愚夜观”这个名字。</p>
<p align="right">
愚夜观<br />
辛丑年五月十八日
</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>重温“路人女主”至10卷的一些感受</title>
    <url>/2020/11/10/saekano_comment_s/</url>
    <content><![CDATA[<h3 id="序">序</h3>
  花了近一个月时间终于重温完了“路人女主”第8卷至第10卷，效率大不如从前（明明之前一个月都可以重温俺妹整部作品），简直就是怠惰的化身（你啊，真是怠惰呢！.jpg）。其实我个人不喜欢写长评的，因为需要花大量的时间来整理思绪和观点，但无奈当初自己第 10 卷看得草草了事，重温这小说第 10 卷给我带来的感受累积太多又使我不得不在最终章突入前写点东西来消化一下。同时动画也磕磕绊绊地看到了第二季的第 6 集（对应小说第 6 卷完），顺便也提一下吧。<br />
  
<center>
<em>温馨提示，<br/>以下的内容带有严重的剧透和强烈的个人主观，并且可能含有大量的过度解读，<br/>请读者酌情观看。</em>
</center>
<a id="more"></a>
<h3 id="游戏剧本和小说剧本的不同">游戏剧本和小说剧本的不同</h3>
<p>  看完第 10 卷的第一大感受。<br />
  重温到第 5 卷的之后我就一直认为，丸户老贼在这部作品中的亲女儿有两个——表加藤里霞之丘；前者是自己甚至作品相关人士花大量精力塑造出来的魅力女主角；后者是可以说是丸户自己的化身，同样地剧本家身份所以可以放进去自己大量的对创作剧本的私货，并且角色篇章具有强烈的个人色彩。至于英梨梨，硬扣一个“集万千宠爱于一身”的女主光环但实际着墨并不多，说是超有魅力的角色但除了设定之外从文字本身很难看出来（这一点动画反倒还好一些），看似是剧情的核心实则看下来就是个推动剧情强行急速发展的工具人，可以说是败犬中的败犬……咳咳，扯远了，总之，不出意外，作为学姐个人篇章，丸户老贼又如愿以偿了倾述了自己的大量私货。第五卷说的是自己对 galgame 和小说在行文上的观点，第10卷说的是自己对游戏剧情展开和小说剧情展开的观点。 <img src="/images/20201110_01.png" width="50%"> <!-- ![](https://ftp.bmp.ovh/imgs/2020/12/b9fb10d6505caa38.png) -->   当初读第 10 卷的时候因为阅历不多，或者说对游戏作品的剧情斟酌不多，所以第一次读很不理解红坂朱音对霞之丘剧本挑的刺。但玩了不少的 rpg，尤其是 jrpg 游戏之后，意外地能理解对方说的意思，甚至还十分赞同。游戏的剧情，作为 jrpg 游戏核心的一部分，可以通过画面的演出，游戏本身的玩法来对游戏主线剧情进行增色，这一点其实与动画等影视作品类似。与动画不同的是，因为游戏的核心是需要玩家自己上手操作的，游戏角色在非剧情部分大多是由玩家自己来决定的，所以通常玩家很容易将自己代入主角中，或者说给人更强的代入感；因此对游戏来说，在代入主角的前提下获得最棒的剧情体验，往往比剧情本身精不精彩更重要，这大概就是我认为诗羽学姐的剧本的最大毛病（虽然小说没详细说）。近期比较典型的例子就是 P5R 和美末 2，异度之刃 2 其实也有一点（比如真的塑造），剧情其实能接受，但玩家代入某个特定角色后很难产生共鸣，用文中的吐槽“还不如用平淡的文字来写一个俗套故事”然后使人们的注意力放在游戏除故事外的其他部分。<br />
  当然小说一般也会讲究代入感这个东西，不过还好的是，因为单纯用文字构成的小说，对主角的塑造和游戏大量的给人脑补的空间相比是固定的唯一的，所以读者会下意识的将主角和自己分裂开，就算会代入进角色也仍或多或少地站在上帝视角去感受故事的发展。这一点也是霞之丘诗羽作为小说家的写作特质。当然，对于喜欢从上帝视角看故事的人来说游戏剧情和小说剧情的体验可能没差距的。所以这大概也是文中说的“90%的人会觉得霞之丘写的是个好故事”，当然对于喜欢代入主角来看故事的人可能会相当不喜欢，丸户史明的“安艺伦也”也有类似的特质，我的一个朋友就明确表示完全不理解所以这作品完全没看下去。<br />
  同样地道理其实也可以套在后面霞之丘和安艺因为美少女游戏剧情的分歧上。Blessing software 做的是萌豚游戏，所以安艺伦也写的“与诗羽分别相约共同进步”初稿单纯作为视觉小说没准会不错，较为合乎逻辑的苦涩的现实中带有真实之上的甜蜜和喜悦。然而，作为受众为恶心宅男的萌豚游戏的剧本，不能和萌萌哒的美少女享受没羞没臊的恋爱，这样的故事无疑是个条雷线，活脱脱新岛夕的《想要传达给你的爱恋》的翻版，当然还是会有小众群体会接受吧。比较有趣的是，丸户史明老师在故事中对这条游戏吐槽 neta 了白 2，名字为 coda，丸户老贼自己也清楚自己写的故事与玩家的割裂感很严重啊，这样的主角完全代入不了嘛……其实霞之丘和安艺的核心分歧会在第二部分提及，这里就不再说了。<br />
  总之，游戏剧情和小说剧情是不一样的！和小说剧情！（neta 自《机动战士高达》兰拉·巴尔名台词）</p>
<h3 id="她亲手终结了自己的恋情">她亲手终结了自己的恋情</h3>
<p>  这个是我读完第 10 卷第二大，也可以说是印象最深的一个感受。<br />
  重温这作品第二遍的时候，我一直在想英梨梨和诗羽两人是怎么输的，在哪里出局的。英梨梨在故事最精彩的第 6 卷到第 7 卷，甚至延续到第 9 卷其实说的很清楚了，可以说是三位女主角中第一位出局的（这就是真败犬吗……）。第 9 卷安艺用剧本的方式，描绘了他理想中的英梨梨是什么样子，并且因为英梨梨的初恋 buff 所以他对英梨梨的要求很宽容，就算是为了梦想不断前行，只要不离开他，在他身边也能实现理想，他还是会接受英梨梨，所以所有人看完初稿的感受就是“他到底是有多喜欢英梨梨啊”（准确来说这里是我自己脑补的，原本对这里很模糊）。很可惜全场情商最低的英梨梨并没有理解到，还在坚持自己充满乙女向游戏的单纯想法，所以就出局了，或者说迟早会被学姐和加藤截胡。<br />
  说到霞之丘诗羽这边，就相对来说比较复杂。最初我以为是最早出局的，甚至最早看电子书的时候以为是在交代了她的过往的第 2 卷，诗羽学姐可以说是不可能再机会了，安艺伦也只把她当作创作者来看待而不是想追求的异性。看到后后面的时候又会觉得是第五卷安艺伦也再次拒绝选择结局而出局的，第 2 卷其实是在写诗羽重新对安艺伦也的富有魅力的创作者一面认识，重新燃起了恋心。重温之后又觉得第五卷其实就只是诗羽的自作多情（这一点加藤也提到过），安艺伦也的心思完全放在诗羽的剧情写法不适合 ADV 游戏这一点上，别的根本没在意，说白了就是一场误会，但却不知不觉为 6 到 7 卷的发展埋下了伏笔。所以重温到 6 卷和 GS1 时，觉得诗羽学姐是因为英梨梨的背叛，而自己在英梨梨钦定“娇弱”女主的光环觉得必须从创作者层面保护她支持她，所以也跟着背叛出局的，最后我又被男主的对这两个妹子放不下的执念打了脸，说白了就是对黑金的足够包容，自己能原谅对方，嘛，旧情难忘嘛，我懂得我懂得。转而就到了第 10 卷，在惠的鼓励包容下，安艺伦也开始整理自己对诗羽的感情，然后类似于第 9 卷的展开，写出了自己理想当中的诗羽学姐是什么模样，同时也传达了只要对方肯放下高傲的姿态，变得依赖他一点，他还是会接受的，只是这一次，学姐选择了拒绝。<br />
  没错，其实说了那么多，我觉得诗羽学姐出局的真正原因就是第 10 卷这里她作为创作者，作为安艺伦也理想的女神的自尊心和高姿态。并且文中极为执拗的是，她可以承认自己在生活上对男主的依赖，但不允许自己在工作和创作上依赖男主，可以说对自己的才华达到了自负的程度。但其实最有意思的是，诗羽变成这种执拗的个性个人觉得是因为受到了安艺伦也第一次拒绝之后走上了钻牛角尖的缘故（之前是比较依赖伦也的建议和评价的），所以说一开始就出局了也没错，并且还是安艺伦也一手造成的，迟早会因为当时埋下的祸根然后滚雪球式的爆发。反而第6卷加GS的剧情就不那么重要了，嘛，也难怪诸葛惠要求安艺“只能在她面前表现想着学姐哭泣”，这……被当事人看到了加藤还能赢？<br />
  当然，如果学姐渐渐放下了自己的高姿态和自尊心，会是怎样的展开呢？外传漫画《恋爱节拍器》其实就说的比较清楚了，虽然还有一些其他元素就是了。染上我的颜色吧，诗羽学姐！（neta 自《罗布奥特曼》） <img src="/images/20201110_04.png" width="50%"> <!-- ![](https://ftp.bmp.ovh/imgs/2020/12/f51951317253385a.png) -->   总的来讲，学姐的出局，与其说是安艺伦也的选择，倒不如说是自己的选择，前期因为安艺伦也的拒绝钻了牛角尖，后期因为牛角尖钻得太深出不来了。虽然说安艺的责任占比较多的元素。但是一个设定上情商较低，满脑子死宅幻想，同时因为小时候受过校园欺凌和好友背叛的高中生来说，如果不像加藤那样改变自己向对面的理想靠近，同时也时不时地改变对方向自己的理想靠近，确实没啥机会的（我特么都在说些啥……）。 在安艺对学姐线剧情的里设定里面就可以看出，安艺伦也的理想女性是不会背叛他，不会太执着于过去，并且还会向他撒娇的“真由”，这基本就是加藤表现出来的翻版（事实上加藤也是在第七卷之后完全理解他的，这个就是另一段故事了），然而学姐是把自己代入“沙由佳”的，精准踩雷，不愧是你。<br />
  总之，丸户史明老师在学姐的感情刻画上很有那种合乎情理和逻辑，但是将一个失误无限放大的滚雪球的纠结和悲情的个人色彩，很有自己当初玩对应白色相簿 2 的感觉，毕竟失误（春希一激动答应了雪菜的表白）都是一样的。</p>
<h3 id="尾声">尾声</h3>
<p>  霞之丘诗羽作为这部作品我第一眼看过去最喜欢的角色，黑长直，前凸后翘，黑丝，看似厚黑其实纤细娇弱的，看似成熟实则堪比英梨梨般单纯等多种特性其实满符合我口味的。最后不知不觉就洋洋洒洒写了近 4000 多字的长评，大多数在写什么老实说我自己都不清楚。<br />
<img src="/images/20201110_02.png" width="50%"> <!-- ![](https://ftp.bmp.ovh/imgs/2020/12/63e5a27ac6364ea5.png) -->   总而言之，充满了丸户史明个人恶趣味的诗羽学姐的剧情精彩归精彩，但我个人喜欢不起来（幸好突出我最期待的最终章了），把自己笔下的妹子逼成这样老实说 GOOD ENDING 还好，BAD ENDING 反而不禁让人觉得难以释怀。<br />
  至于动画，丸户史明老师多半也知道自己应该收敛，或者说正义的制作人、监督也压住了他的手，削减了很多丸户史明的个人风格，让原本一环扣一环的感情故事变得让人接受很多，比原作更像是恋爱喜剧动画，妹子们的萌元素加重了，沉重的感情元素减轻了，可以说做出了动画独有的特色。比如对应第 6 卷故事的第二季 5, 6 集，安艺的内心独白基本就没了，他对英梨梨的矛盾纠结的感情也没了。而之后的第 7 卷内容，加藤通过很多小细节增添了很多个人魅力，使得整体故事更像偏向于一个纯爱故事（什么是官方亲女儿.jpg）。同时原作沉重的感情出局，到了剧场版也变得相对容易接受，《DREAM TEAM TRIANGLE》响起，气氛到位就完事了，作为原作粉的我特么哭爆，就这点我还是更喜欢动画。<br />
  说句题外话，第 11 集和剧场版我就算时常回顾还是能感动得流泪，加藤惠太棒了。所以订购的剧场版 BD 赶紧到啊！👴快等不及了。 <img src="/images/20201110_03.png" width="50%"> <!-- ![](https://ftp.bmp.ovh/imgs/2020/12/5b77b2fbb0f22eab.png) --></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>lightnovel</tag>
      </tags>
  </entry>
  <entry>
    <title>雪影</title>
    <url>/2021/01/09/snowshadow_poem_s/</url>
    <content><![CDATA[<h1 id="雪影1">雪影<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></h1>
<p> </p>
<p>梦初醒，</p>
<p>你敲打着窗楹，</p>
<p>告知着仅存于今日的光景。</p>
<a id="more"></a>
<p> </p>
<p>玻瑞阿斯<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>一如往常地演奏着乐曲，</p>
<p>悠扬而又空灵。</p>
<p>身着洁白礼服的你，</p>
<p>犹如童话里的妖精，</p>
<p>舞姿轻盈，</p>
<p>歌颂着英杰们的事迹，</p>
<p>甜美而又动听。</p>
<p>置身琴后的阿波罗<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>为之吸引，</p>
<p>撩动云织的琴弦，</p>
<p>增添自己的一份豪情。</p>
<p>驻足倾听，</p>
<p>仿佛自己也置身于，</p>
<p>那波澜的歌声里。</p>
<p> </p>
<p>终曲如期来临，</p>
<p>盖亚母亲<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>张开怀抱，</p>
<p>等待即将回家的你。</p>
<p>我不禁伸手去挽留，</p>
<p>却只留下了你的泪滴，</p>
<p>和不知谁的叹息。</p>
<p> </p>
<p>如梦初醒<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>，</p>
<p>行人一如既往地踏步前行，</p>
<p>消失在远方的风里。</p>
<p>我将这悸动埋在心底，</p>
<p>期待着，</p>
<p>明年能与你共和一曲。</p>
<p> </p>
<blockquote>
<p>1 月 7 日，蓉城自清晨下大雪，一般路过研究生上工途中胡思乱想，原本想借这“雪花缓缓飘落到地上，自己伸手去抓什么都抓不到”的场景抒发一下忧郁，吐露一下自己去年的碌碌无为，觉得自己“不配”进入留在“歌”的英杰故事里，但又觉得太自卑了有伤身心健康，于是又算借“瑞雪兆丰年”讨个彩头，希望今年能有资格站在她身边“和歌”吧<em>（这么写感觉像是老舔狗了，这就是过来人吗？）</em>。</p>
</blockquote>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><span style="font-family:楷体">雪影，原本想写成“舞蹈”，写着写着就变成“歌声”了……不过也可以理解成“雪音”的文字游戏。同时也想说自己只能看着雪的身影，不能抓住其实体<em>（因为入手即化，笑）</em>。</span><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><span style="font-family:楷体">玻瑞阿斯，希腊神话中的北风神，这里将冬天的北风拟人化。</span><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><span style="font-family:楷体">琴后的阿波罗，指云层后的太阳，将云作为琴，将“风吹云动”说成是“拨动琴弦”。</span><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><span style="font-family:楷体">盖亚，希腊神话中大地母神的盖亚，近现代 ACG 印象经常误解成男性，比如盖亚奥特曼。</span><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><span style="font-family:楷体">毕竟也是大脑脑补的，说成是“梦”也没问题。</span><a href="#fnref5" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 年春季动画感想汇总（二）</title>
    <url>/2022/04/22/springanime22_comment2_s/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>  ok，既然这次也是汇总，前言就不搞那么多废话了，直接开始吧。这次的是《夏日重现》，《机动奥特曼》，剧场版《魔法少女伊莉雅：无名的少女》，以及附送的古见第二季第 3 集与《间谍过家家》第 2 集。</p>
<a id="more"></a>
<h2 id="夏日重现">《夏日重现》</h2>
<p>  这动画对我来说不算陌生了，当初冲着第一话出场的各种妹子去看的，好吧，我承认我就是馋南方日鹤的身子。不过原作一话一话更新相隔时间长，而每一话信息量又大导致我看不懂在讲啥就弃了。<br />
  我个人认为这种轮回式悬疑推理作品比起一话一话慢慢追着看，更适合更新完之后一口气补。不然单集观感就和以前的石头门前半段的观感类似，除了各色各样的妹子，帅气的男主（凶真和桶子除外），可能啥都搞不清楚，迷迷糊糊一集就结束了，当然有各色各样的妹子看也不错了。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_1.png" width="63%" style="display: inline-block" /><img src="/images/springa2_2.jpeg" width="27%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>OP 男主的爆头画面，神似《女神异闻录 3》人格面具的召唤方式。ATLUS 赶紧将 P3 重置呀！</em></td>
</tr>
</tbody>
</table>
<p>  不得不吐槽的是，这个曲调轻松、活力四射的 OP 欺诈性太足了，迫真四月的 OP 是你的谎言。以及这个 OP 最后一幕，男主一脸装逼的表情却拿枪对着自己的头，我真以为下一秒他就会喊出“persona”。不是，这也太 p3 了。另外，推荐一个整活，果然寒蝉的 OP 一用这感觉就来了，果然还是这种邪气电波味儿十足的曲子适合这种悬疑动画。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_3.png" width="60%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em><a href="https://www.bilibili.com/video/BV1Zi4y1U73V">BV1Zi4y1U73V</a> 时机恰当的神插入，最绝的还是 ED 的这个画面与《ひぐらしのなく頃に》主歌转音处的绝配。</em></td>
</tr>
</tbody>
</table>
<p>  总之，以第一集这表现，我可以放心等更新了一些再来看。正好该找个时间把漫画重新看一遍了。</p>
<h2 id="机动奥特曼">《机动奥特曼》</h2>
<p>  看完之后有一说一，打戏还是不错的，再怎么说也比抽帧的第一季流畅了。<br />
  这动画说白了就是把一部带着奥特曼元素加当下流行的白左元素的面向欧美低龄层的超级英雄电影硬是砍成了6集。所以超级英雄电影嘛，剧情就算弱智得跟啥一样，配上爆米花，情怀拉满还是能看下去的。你说是吧，漫威蜘蛛侠3？<br />
  至于说打戏部分，我想想啊，奥特恋爱 <em>（这一季女主还是挺萌的）</em>，奥特自爆身份 <em>（传统艺能属于是）</em>，奥特逃单，奥特断手 <em>（肉联厂主任竟然在外传还债了）</em>，有问必答 <em>（七爷：小六，来，给他们整个活。泰罗：草，略（指自爆））</em>，奥特倒贴，奥特 kiss <em>（贝利亚和莉莉点了赞）</em>……</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_4.png" width="54%" style="display: inline-block" /><img src="/images/springa2_5.png" width="36%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>奥特 kiss，这一场景莫名让我出戏到了漫画《Darkness Heels ~Lili~》女主莉莉亲吻贝利亚的片段，大孝子捷德喜迎一位萝莉后妈wwwww。</em></td>
</tr>
</tbody>
</table>
<p>  <em>（说打戏，说打戏）</em> 哦哦，你说打戏啊，emmm，肉搏倒是全程在线，运镜和细节处理都相当专业且到位（看人分析的），看起来相当爽，不过这种 3D 动画我看的比较少所以也不好评价就是了。七爷各种装逼时刻被削了（原作七爷一人削金古桥），以及光线技能少了还是可惜 <em>（我的八分光轮，断头刀，手镯人的火花一闪……）</em>。果然这垃圾玩 y，哦不对，这情怀动画本质是超级英雄片是吧！<br />
  ……<br />
  对不起，圆不下去了。这动画做的很好，下次别在做了。什么？这玩意儿还能有最终季？老人，地铁，手机 .jpg。<br />
  <em>（说原作啊，说原作）</em> 你说原作相比？原作其实从中期开始就一团乱麻，东一榔头西一棒子的，老实说原创成这样其实也不错，至少配上爆米花以下略。外加本家特利迦都那个尿性，你不能指望一个外传能有多用心。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_6.png" width="65%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>奥特三兄贵，七爷这一季少有的 C 位高光时刻，这场景就很美式超级英雄漫画风格。</em></td>
</tr>
</tbody>
</table>
<p>  总之，感觉不如去期待痞子拍的《新奥特曼》，好歹给人像是披着初代皮的奈克瑟斯的电影版归曼，应该还是能整些活吧。</p>
<h2 id="魔法少女伊莉雅无名的少女">《魔法少女伊莉雅：无名的少女》</h2>
<p>  我是真没想到以这玩意儿的人气还能撑到再出一部剧场版，正好四月 BD 也出了，就看看究竟咋样吧。<br />
  简单来说，剧情展开、叙事节奏、文戏演出稀碎，毕竟原作在卫宫巨侠传之后就那样，我也不指望这种纯粉丝向的电影还能做出什么惊为天人改编。不过好在这一部剧场版相比前作卫宫巨侠传，在打戏上是真的认真在做了，虽然分镜混乱屡见不鲜，2、3D 切换略有不自然，全程作画只有定格能看，但还是看得出来真的想要做好的样子。<br />
  最为重要的是，最关键的是，魔法少女伊莉雅的这一部剧场版，真的能看见伊莉雅！！不仅是活的伊莉雅，还有：</p>
<blockquote>
<p>变身魔法少女的伊莉雅 <em>（这不废话吗？）</em><br />
带孝女伊莉雅 <em>（切嗣：勿 cue）</em><br />
B叔版伊莉雅 <em>（卧槽，竟然没有乳海，吃我射杀百头啦！）</em><br />
狂阶美杜莎/戈尔贡版伊莉雅 <em>（原来这卡片还能叠加着用的吗？）</em><br />
R姐版伊莉雅 <em>（R姐，你又在头铁怼光炮）</em><br />
棉被王伊莉雅 <em>（谈谈，指伊莉雅用誓约胜利之剑一剑穿胸）</em></p>
</blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_7.jpg" width="40%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>出自原作者广山弘的手笔的棉被王伊莉雅，这个剧场版的宣传绘，可惜这动画的作画还原不出这种英气。另外物理谈判没用到光炮也太可惜了。</em></td>
</tr>
</tbody>
</table>
<p>  甚至还能看到：</p>
<blockquote>
<p>B叔版美游 <em>（这纹路，太奎托斯了吧喂……）</em><br />
静谧版美游 <em>（静谧都来了，Fp 有机会转正了？旧剑化身来一个啊秋梨膏！）</em><br />
开菊花盾的卫宫巨侠 <em>（不愧是唯一指定里男主，这电影的所有发展可以说是巨侠一个人种下的种子）</em><br />
姑 嫂 和 睦：指美游一边幻想着自己陪樱相伴买菜，一边用穿刺死棘之枪一枪贯爆长江樱。樱：到底现在谁是 B 阶）<em>（结合后面出场的棉被王伊莉雅，我只能说美游自称这是模仿伊莉雅的做法我是丝毫没有怀疑过的，摊手）</em></p>
</blockquote>
<p>  总之，电影辣鸡归辣鸡，但乐子其实真不少。我死寂了很久的月球之魂又开始熊熊燃烧了，所以，我决定：</p>
<center>
<strong>把卫宫巨侠传漫画再看一遍。这烂电影我是真的不会在看第二遍了。</strong> <em>（然后为了整理评论，又断断续续浏览了一遍截图）</em>
</center>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_8.png" width="65%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>结尾彩蛋的cg插画很好看，看笔触应该出自原作者广山弘的手笔。广山老师，多花点功夫在剧情上吧……</em></td>
</tr>
</tbody>
</table>
<h2 id="瓜神颜艺第二弹我的间谍恋爱物语果然有问题第二集间谍过家家第二集"><del>瓜神颜艺第二弹（？）</del>，<del>我的间谍恋爱物语果然有问题第二集（？）</del>，《间谍过家家》第二集。</h2>
<p>  看来制作组是决定以原作剧情还原的“稳”优先了，看不到什么精彩改编了。不过就第一集来说，第二集观感要好一些。该有的都有，该对应的点也很对味儿。<br />
  嗯，这很不错，至少没有了莫名其妙的创新破坏观感，更不用说能保持这种质量就很奢侈了，不存在内涵哦。<br />
  当然如果在叙事节奏和剧情演出上再花些功夫就更好了。就目前来看，还行，继续待看下一集。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_9.png" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>名场景手雷求婚，太太的头发没有还原原作的长发差评啊。</em></td>
</tr>
</tbody>
</table>
<h2 id="古见同学有交流障碍症第二季第-3-集">《古见同学有交流障碍症》第二季第 3 集</h2>
<p>  喂喂喂，我确定不是在看什么奇怪的女性向动画吗？第二季目前就三集，两集全是用在片居和只野这对了可还行。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa2_10.png" width="50%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>说真的，这一幕场景伴随甜蜜的 OP 插入，我很难不怀疑制作组在搞事。说好的正常向狗粮动画呢？</em></td>
</tr>
</tbody>
</table>
<p>  唯一真神只野仁子又出场了——！期待真神下次正式登场，虽然大概要等到有生之年的第六季了……<br />
  话说你们买红薯就买红薯，不要拿不用尝都知道是酸的来给人好吧，那可是酸的啊喂！</p>
<h2 id="尾声">尾声</h2>
<p>  总之汇总（二）也算是及时更新了，这可以说是破纪录了。但是路人女主画集上还没来得及更新，画集下都快出了，怎么感觉除了项目，博文还会产生这该死 DDL 的，大概是错觉吧 （叹气）。哦对了，还有 86 的动画漫评，第一季制作太烂让我有吐不完的槽，不过出于不看完就不轻易发言的坚持 <em>（明明自己在说说已经吐槽过了）</em>，等第二季看完了再来慢慢说吧。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>anime</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 年春季动画感想汇总（一）</title>
    <url>/2022/04/17/springanime22_comment_s/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>  我自从开始读博之后，忙得一发不可收拾，外加一个项目导致自己几乎每周都是在跨越各种各样的修罗场，久而久之博客这边都长满了杂草。于是，秉承着尽可能不断更的负责态度 <em>（才不是迫于编辑压力的不爽态度，哼</em> o(′^｀)o <em>）</em>，我决定将自己平常看动画后的短评整理成汇总<del>来凑数</del>，更新博客…………好啦，我知道自己明明有时间去看动画漫画小说打游戏玩胶，其实完全是自己太懒了不想写，所以才想到用这种方法灌水。毕竟人如果平常太忙的话，也会没兴致会花心思去写大段文字的，想必有相关经验的读者应该能理解我这种为了保证文字质量而“宁缺毋滥”的想法，对吧？<br />
<a id="more"></a>   咳咳，严肃点。虽然这次是类似于总集篇性质的博文，但因为自己有着“绝对不会给别人呈现一模一样的东西”的死宅执著，我还是会或多或少进行一些订正和补充的。总之，这次就先整理了自己这个季度在追的三部动画第一集的短评作为汇总（一），汇总（二）和（三）不出意外也会出吧。唉，明明自己有挺多坑没填，又给自己挖了新坑……</p>
<h2 id="古见同学有交流障碍症">《古见同学有交流障碍症》</h2>
<p>  相比于这个季度的其他霸权动画，老实说这动画才是我最期待的作品。第一季于去年 10 月秋季播出，虽然整体上因为剧情起伏不大，白开水一般导致观感很一般，但是其远超原作出彩的演出和细节的制作完全打动了我这个从第一话就追到更新的原作粉丝，可以说是我去年看过的最推荐的校园恋爱漫改作品，个人心目中不亚于前年的《辉夜大小姐想让我告白》，甚至排名还高一些。真心佩服制作组厨力，以及川越一生监督 YYDS！</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/komi2_ep1.png" width="60%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em><a href="https://www.bilibili.com/video/BV1Xf4y177VB">第一话的黑板交流名场景</a>，将原作前期不算特别起眼的一幕改编得十分出彩，搭配抓耳的配乐完全戳中了的我好球区。以及这一幕之后神 OP 的神插入，交替带来的惊艳冲击，也是我迷上这改编动画原因之一。</em></td>
</tr>
</tbody>
</table>
<p>  说回到第二季的第一集，虽然剧情仍旧是剧情白开水，但质量还是顶。不过 OP 被片居夺舍了我实在忍不住了，这滤镜，这特写，这真的不是什么奇怪的耽美动画吗？以及麻烦不要再玩这橡皮这种元素了行不行，《just because》ptsd 犯了。你们日本高中生就不能考前多检查检查文具吗？哦，这次是男女主之间插入橡皮元素啊，那没事了。<br />
  最后，第一集最让我惊喜的莫过于，看似马赛克，实则动作表现细腻的神 ED，不输给真人实拍的日常作画，日常打趣甚至离开教室提上挎包这个简单动作都细节满满。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/komi2_ed.png" width="60%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em><a href="https://www.bilibili.com/video/BV1o34y1s7H7">古见第二季的 ED 动画</a>。可以说与第一季是近似手绘的神 OP 并肩的存在了。</em></td>
</tr>
</tbody>
</table>
<p>  总之，期待一手后面的修学旅行剧情，感觉这动画就制作来说随时随地都会带给我惊喜。</p>
<h2 id="相合之物">《相合之物》</h2>
<p>  这动画第一集怎么说呢？对我来说其实蛮微妙的。<br />
  原作在我心目中是比肩《天真与闪电/甜蜜稻妻》的温馨日常向亲子漫画，当然还有我喜闻乐道的淡淡的恋爱元素：前女友 vs. 天降 JK，这都是什么丸户史明、冈妈之类的胃药批发作者才会用的设定啊wwwwww</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa_1.png" width="40%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>男主经典木头男设定，左数第二个是天降 JK，右数第三个是前女友。其实这作品前期甚至还有丧心病狂的养女股的，只不过作者终究还是想要坚持温馨路线，所以中途股市就崩盘了，甚至现在养女都和男主没啥互动戏份了。</em></td>
</tr>
</tbody>
</table>
<p>  可惜的是，虽然我还是一个不看字幕听不懂讲啥的萌萌人，但真心习惯不了动画那奇怪的关西腔（动画的舞台是在京都），所以我第一集没看完就弃了。外加动画没让我感觉很来电，等后面找机会再补吧。</p>
<h2 id="间谍过家家">《间谍过家家》</h2>
<p>  最后是期待已久的《间谍过家家》第一集，意料之中的高质量，忠实还原原作的一集，几乎找不到什么明显的缺点。<br />
  但要说好看的话，我觉得这动画的编剧和 86 动画的编剧一样还是太保守了。第一话太忠于原作，同时为了合理分集还塞入了前期大量的剧情，导致第一集剧情就和流水帐一样表现略平淡。原作黄昏撕脸转身可以说是这一集的小高潮，但是画面定格特写太短；回忆杀和独白使用太简单、尾声太长（原作这一话只到父女回家）等诸多因素冲淡了这第一个名场景。个人认为这里真应该大胆地对原作的内容进行调整，以保证动画这种载体下的最佳观感。希望后几集的名场景“手雷拉环求婚”能好一些。<br />
  另外，真的不是我特意去玩声优梗，黄昏一开口我直接喷了出来，尤其是前面论述“特工不能结婚”的台词，这就是大老师转世吧喂！</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/springa_2.jpeg" width="60%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>这动画由霸权社和 CW 共同负责，但其实我个人其实看见这种多公司联合制作的作品就心情复杂，单集质量不稳定，剧本风格不统一，运气差还可能因为两个公司制作团队配合不好导致剧情暴走，没错，我说的就是“国家队”。</em></td>
</tr>
</tbody>
</table>
<p>  总之，继续看瓜神颜艺就对了。<br />
  哦，差点忘说了，还有主题曲，该说我老了吗，还是说对流行不感冒吗？老实说我欣赏不来这动画的 OP 和 ED ，都觉得挺一般的。</p>
<h2 id="尾声">尾声</h2>
<p>  这季度目前我就差不多看了这些，之后应该还有《夏日重现》和《机动奥特曼》，以及这个月才出的《魔法少女伊莉雅：无名的少女》剧场版的 BD，运气好有时间的话，这些动画的评论及后续的评论应该会以汇总的形式更新，运气好的话。但就博文来说，我个人其实想在自己主办的 86 动画鉴赏会 <em>（所以到底是谁说的自己没时间的啊喂！）</em>之后写一篇 86 动画的评论，好歹也是我去年看到的最棒的轻小说改编动画。或者以到手的路人女主画册来填一篇路人女主系列尾声二的坑了 <em>（怎么还是路人女主啊，真就不带换的是吧，取关取关了）</em>，嗯看情况吧。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>anime</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2020/11/10/test_z/</url>
    <content><![CDATA[<p>本来想写个测试文档作为第一篇博文来着，突然觉得记录一下搭建这个网站的过程也不错，名字还是叫 test 吧。具体搭建过程基本参考这个<a href="https://zhuanlan.zhihu.com/p/26625249">知乎专栏</a>，不过这篇文章写得并不全，有些细节丢失了之后导致某些地方有点卡手。我首先会把搭建时遇到的一些问题和解决方法列举一下（Part 1），之后应该会陆陆续续整点新功能，所以到时候就接着在这里补充一些遇到的新问题（Part 2）。</p>
<a id="more"></a>
<h2 id="part-1">Part 1</h2>
<h3 id="设置-ssh-以免密部署">设置 ssh 以免密部署</h3>
<p>在使用 <code>ssh-keygen</code> 生成密钥并于 github 上 add ssh key 后，先在 <code>~/.ssh</code> 里测试一下配置是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>然后得到了成功提示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi fomiuna! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>其实按照原文章搞的话必不可能成功，因为 <code>ssh-agent</code> 并没有启动。所以需要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> `ssh-agent -s`</span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure>
<p>之后才可。接下来在博客根目录下的配置文件 <code>_config.yml</code> 中修改 deploy 属性如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:fomiuna/fomiuna.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>若按原文直接在 repo 写 <code>https</code> 好像不太行，还是要输入密码。</p>
<h3 id="关于数学公式渲染">关于数学公式渲染</h3>
<p>我相信咱们还是会写点学习上的东西，不会一直在博客上吹逼吧，不会吧不会吧？<br />
咳咳，话题回来。本来我参考了这篇<a href="https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/">博文</a>来配置 mathjax 渲染的，但是按这篇文章把 marked 引擎换成 kramed 后还是没卵用。然后我去 next 主题下的配置文件中瞅了一眼 mathjax 属性，发现注释中已经告诉我去官网看 <a href="https://theme-next.js.org/docs/third-party-services/math-equations">instruction</a> 了，于是按提示装了 pandoc 之后问题就得到了解决。</p>
<p>现在拿分部积分公式试一下效果： <span class="math display">\[
    \int_{\Omega}u\ \mathrm{div}(\mathbf{V})\mathrm{d}x = \int_{\partial\Omega}u\mathbf{V}\cdot \mathbf{n}\mathrm{d}S-\int_{\Omega}\mathrm{grad}(u)\cdot\mathbf{V}\mathrm{d}x
\]</span></p>
<p>（不错，我很满意）</p>
<h3 id="博文配图">博文配图</h3>
<p>参考一下<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">这个</a>，咱们可能还是考虑一下外链比较好。</p>
<p>我先搞个本地的图试试看： <img src="/images/rushia.jpg" /></p>
<hr />
<p>其实第一次搞实在遇到了很多问题，跑去搜索并用了网上各种解决方案的之后，成功把网站搞崩了（怎么都加载不出来主题）并且不知道怎么纠正。后来还是老老实实读<a href="https://theme-next.js.org/muse/">官方文档</a>照着重新再做，基本就没再遇到什么问题了（所以小白还是不要先去整大佬们花里胡哨那一套）。</p>
<p><em>那么到此，一血（指第一篇博文）我就拿下了。</em></p>
<h2 id="part-2">Part 2</h2>
<h3 id="给文章加阴影边框">给文章加阴影边框</h3>
<p>在网上找了不少 adding shadow effect 的文章，都是需要在 <code>css\_custom\custom.styl</code> 文件中改 <code>.post</code> 属性。但因版本更新问题，在我使用的 NexT（ver 8.0.2）里已取消了此路径下的这个文件夹和样式表。<a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html?highlight=custom">新的 Custom File Support</a> 告诉我们：可以在主题 config 文件中取消注释 <code>custom_file_path</code> 里面你想作个性化调整的属性，然后在博客根目录下的 <code>source\_data</code> 文件夹中进行相应文件（没有就新建）的自定义调整。</p>
<p>比如我们想要实现的这个功能是在 <code>style</code> 属性中，在主题 config 文件中开启 <code>custom_file_path</code> 的 <code>style</code> 选项后，再到 <code>source\_data\styles.styl</code> 中添加</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">    <span class="attribute">border-radius</span> : <span class="number">12px</span>; <span class="comment">// 圆角，爱了</span></span><br><span class="line">    -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> rgba(<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">1.0</span>);</span><br><span class="line">    -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> rgba(<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>; <span class="comment">// 左右边距</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p.s. 在我查官方文档前，先是在 <code>css\_common\components\post</code> 文件夹里逗留时找到了 <code>post.styl</code> 里的 <code>.post-block</code> 属性，然后试着把其他文章里给出的填写例子加进去</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (hexo-config(<span class="string">&#x27;motion.transition.post_block&#x27;</span>)) &#123;</span><br><span class="line">  <span class="selector-class">.post-block</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">    -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.pagination</span>, <span class="selector-class">.comments</span> &#123;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不出所料也是起作用的。</p>
<h3 id="博客背景图片设置及-block-透明化处理">博客背景图片设置及 block 透明化处理</h3>
<p>仍在自定义的 <code>styles.styl</code> 里进行调整。需要注意的是对页面头所在的 <code>.header-inner</code> 样式里不能直接调整透明度 <code>opacity</code>，因为 <code>header-inner</code> 包含 <code>header.swig</code> 中的所有内容，若使用 <code>opacity</code> 进行配置，子结点会出很多问题（例如会影响到搜索框的透明度）。所以我们使用 <code>rgba</code> 来进行调整</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.85</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在待解决的问题是如何在保持 post block 的透明化前提下对其中插入的图片做非透明化处理（透明化图片和背景会相互干扰，看上去很不舒服）。</p>
<h3 id="关于应对上传速度慢的方法">关于应对上传速度慢的方法</h3>
<p>由于 GFW 的存在 writing objects 速度会十分感人，经常会遇见上传失败的情况。在这里记录一下适用自己的解决方案。</p>
<p>由于我的 VPN 仅对 http 代理，所以只能考虑将上传方式从 ssh 更改到 https 了（目前免密部署用不了了）。首先在博客文件夹下的 <code>\.deploy_git\.git</code> 的 <code>config</code> 文件里进行如下添加 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">  proxy &#x3D; http:&#x2F;&#x2F;xxx:y</span><br><span class="line">[https]</span><br><span class="line">  proxy &#x3D; https:&#x2F;&#x2F;xxx:y</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">  remote &#x3D; https:&#x2F;&#x2F;github.com&#x2F;zzz&#x2F;zzz.github.io.git</span><br><span class="line">  merge &#x3D; refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure> 这里 <code>xxx:y</code> 是代理地址与端口号，<code>zzz</code> 是 repo 名。如果上传文件大小有限制，可以在 <code>http</code> 和 <code>https</code> 项中添加 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postBuffer &#x3D; 524288000</span><br></pre></td></tr></table></figure> 然后到主站配置文件 <code>_config.yml</code> 里修改 <code>deploy</code> 配置项 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  # other deployer</span><br><span class="line">  - type: &#39;git&#39;</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;zzz&#x2F;zzz.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure> 之后的每次部署（如 <code>hexo clean &amp;&amp; hexo g -d</code>）都将要求输入用户名与密码了。Github 在即将进行的 git 操作更新中将取消支持用户名-密码验证了（<a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">见此</a>），目前的方法到时候可能也会受到影响。</p>
<!-- <font size=5>*To be continued.*</font> -->
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>《铃芽之旅》小说和电影感想汇总</title>
    <url>/2023/03/27/suzume_comment_s/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>由于《铃芽之旅》的小说和电影是我在出差途中抽时间看完的，为了图方便惯例先后写成了两则说说放在了 QQ 空间里。现在回顾一下小说和电影的两则说说，觉得加在一块完成度其实还挺高，基本把这作品的优缺点全提了一遍。所以这里将两则说说汇总完善一下，久违地发一篇 acg 的评论博文吧。</p>
<a id="more"></a>
<h2 id="小说评论">小说评论</h2>
<p>叛逆少女离家出走，走出心理阴影顺便拯救世界——《铃芽之旅》，又名《零：铃芽之巫男》<em>（这世界观和人物设定既视感太重了wwww）</em>。</p>
<p>想不到自己阴差阳错就实现了 “在电影之前就看完《铃芽之旅》的小说” 的目标。那啥，这也算出差的鹈鹕味儿了。反正看完了，就简单给个书 <em>（ju）</em> 评 <em>（tou）</em> ，外加一部分电影的推测，正好给犹豫去不去看电影的人做个参考，或者去现场做个验证。</p>
<p><strong>总的来说，这是个新海诚电波味儿十足的公路文艺片</strong>。如果是冲着男女主之间甜甜的爱情之类的喜闻乐道的元素去看的，我的建议是可以放弃了，这作品连男女主感情部分都只是甜头（小说都是比较生硬的那种）。看点在于小时候的大地震对于女主和女主的亲人造成的影响，以及女主离家出手一路过来经历各种事之后的心理转变，并且借由和恐怖游戏零系列很像的“常世”“现世”这种经典日本民俗设定，想要传达出“走出过去的悲伤，去珍惜当下人的温暖”的寓意。</p>
<p>不过小说老实说都表达得很勉强，甚至我是看了诚哥的后记才完全体会到，只看节奏快对白电波味儿十足的电影的观众可能容易摸不着头脑。甚至还会被男女主的感情线，旅途的风土人情，一小部分日本大萧条时代私货和这个过于日本化的奇幻设定给冲淡，给人很一种强烈的“啥都讲了，啥都差一口气”的茫然感。外加女主这种莫名其妙不计后果的叛逆心和行动力大多数只会觉得她好欠揍，以及故事主要推动还是经典的“为了爱就要不顾一切向前进”生硬得一笔的男女主感情。</p>
<p>好在我觉得电影归功于画面好看，音乐好听，人物好看，当个普通的公路旅行音乐片也还行。从宫崎到爱媛，再到神户，再到东京，最后到仙台，前期哼着小曲悠哉悠哉到处蹭吃蹭喝、欣赏风景、和温柔的美少女贴贴 <em>（虽然不能理解女主为啥能这么悠哉）</em>，只能说小说都体会不到。不过都到神户了诶，神户大桥啊，风见鸡之馆啊，这些个 fate 知名景点都不去一遍也太对不起意思了吧，诚哥！</p>
<p>总之，小说的感受姑且是这样了，自己大概率只能出差之后才能去电影院看一遍电影，到时候再去看看电影又会是怎样的表现吧。不过原本计划出差期间才看的小说，去的路上就看完了……</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/suzume1.jfif" width="40%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">首先声明自己不是在打广告。不过这次《铃芽之旅》的简中豪华版，我个人感觉十分良心。尤其是这次的双封皮，喜欢哪个就换用哪个，比起台版常见的双面印刷更有利于保护和收藏。</td>
</tr>
</tbody>
</table>
<h2 id="电影评论">电影评论</h2>
<p>电影看完了，具体表现基本和上述预测得一模一样。</p>
<p>不过还是出乎我意料的是，这作品的演出在精彩音效和声演的加持下比想象得经验。尤其是作为高潮戏码的“常世一梦”，自己这种看过一遍剧情还是会触动到，或者说正因为自己知道故事前后的逻辑和表达的意思才能被这演出所震撼到吧。<em>（给原画和演出几位老师狠狠点赞了）</em></p>
<p>所以说这次真的算是剧本拖了点后腿了。本身就跳跃的对白在快节奏下显得前言不搭后语，大体的剧情只能靠关键词+演出自己悟。唯一的好处在于心理描写的缺失显得女主没那么叛逆，就这点观感反而上升了。</p>
<p>不过这种公路片性质的剧情个人觉得不管是从商业角度还是从个人创作表达角度，本来就不适合拍成电影。从商业来看，篇幅短不仅剧情的表现效果打折，剧情出现城市少，对应地能展现的风土人情和当地风景也会少 <em>（nmd，就是没有神户大桥是吧！）</em>；从个人创作来看，5 个角色的线（女主、女主姨妈、男主、男主基友、大臣）＋偏独创的奇幻设定，如果不考虑削减次要人物戏份的话（比如男主基友和大臣），就算是一季 12 集的 TV 塞下这么多内容都需要疯狂赶节奏。这么来看不管怎么想，都应该是 TV 剧会好一些。</p>
<p>不过比较有趣是，表（关闭后门）里（女主的经历）两条线的剧情时间占比恰好是 2 : 1（我看手机估计的），正好在第 8 集左右转折。如此分割，我坐在电影院基本每一集讲些哪些的内容大致都能划分出来，还能塞一些剧情用于设定铺垫和男女主两边个人线的补全，举个小例子：</p>
<ul>
<li>第 1 &amp; 2 集：男女主初相遇 + 世界观设定介绍 + 里线的铺垫，大地震啥的，差不多对应宫崎戏份；</li>
<li>第 3 &amp; 4 集：酒店女儿情节 + 里线设定铺垫 + 男主个人线（教师梦），顺带女主开导男主推动男女主感情，差不多是爱媛剧情展开版；</li>
<li>第 5 &amp; 6 集：神户酒保剧情 + 给出女主义无反顾帮男主的原因，铺垫里线 + 继续补全男主的教师梦 + 游乐园那里达到第一次感情高潮 <em>（来个烟花助兴会更好wwww）</em>，差不多是神户剧情的展开版；</li>
<li>第 7 &amp; 8 集：东京剧情展开版：给白猫、基友更多的戏份，第8集最后男主牺牲，表现大致结束一转后续大地震的里线。</li>
<li>第 9 &amp; 10 集：女主在回忆杀之后下定决心剧情 + 并且集中讲述里线故事——女主+姨妈；</li>
<li>第 11&amp;12&amp;13 集：对应一路上去仙台拯救男主的剧情。</li>
</ul>
<p>总之，要看这电影的话，我更推荐了解一些背景和设定，甚至索性把这电影当成小说改编作先读一遍小说，观感应该会是最佳的。另外前作彩蛋我竟然错过了ORZ……</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/suzume2.png" width="40%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">出差期间抽时间看的电影。看完之后最大感想比起电影自身的内容，印象最深的莫过于旁边现充女在剧情后段疯狂抽泣，让我很想去吐槽她真的看懂了吗？<em>（什么婆罗门想法wwww）</em> 另外，我这边的场次竟然没有电影特典，太残念了属于是……</td>
</tr>
</tbody>
</table>
<h2 id="尾声">尾声</h2>
<p>其实原本是想在这两条评论的基础上装个逼把自己构思的 TV 改编大纲和每一集内容发展的详细版给放上去。但左想右想发现自己确实不是啥专业的，发现自己越要认真想去构思整体脉络，漏洞还越多，干脆就放弃了。不过后面有机会的话还是想尝试一下。</p>
<p>不过话说回来，虽然我这个诚哥粉对这作品各种长篇大论，看起来我对一作挺满意甚至挺喜欢的。但实际上，比起这作品，我还是更推荐大家去关注同期的《古立特宇宙》，什么才是真正照顾粉丝所有感受的情怀拉满的商业好作品（战术后仰.jpg）。</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/suzume3.jpg" width="40%"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">这个季度最期待的剧场版。虽然看起来是我在无脑吹 <em>（实际上却是是）</em>，但是就我了解到的看过的都说好。至少这次雨宫哲监督和长谷川圭一编剧十分明白观众想看什么，作为粉丝向作品算是福利一次性大放送了。只希望国内能够快点看到。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>anime</tag>
        <tag>novel</tag>
      </tags>
  </entry>
  <entry>
    <title>夜路</title>
    <url>/2021/05/17/yorumiti_poem_s/</url>
    <content><![CDATA[<h1 id="夜路">夜路</h1>
<p>夜是幽暗的，</p>
<p>它自始自终是那样，</p>
<p>令人迷茫而不明方向；</p>
<a id="more"></a>
<p>家是美好的，</p>
<p>它理所应该在前方，</p>
<p>令人向往而憧憬着安详。</p>
<p> </p>
<p>我跟随着人流，</p>
<p>快步走在路上，</p>
<p>走在属于自己的，</p>
<p>独一无二的家的路上。</p>
<p> </p>
<p>夜终究阻挡了前进的方向，</p>
<p>彷徨！</p>
<p>无处寻访，</p>
<p>因为大家不了解各自家的方向。</p>
<p>流浪，</p>
<p>“是时候搬去一个明亮的地方”</p>
<p>有人道出了最合适的感想。</p>
<p> </p>
<p>我聆听着，</p>
<p>失望于指不了路的思想，</p>
<p>感慨这自然而然的现状。</p>
<p>但我知道，</p>
<p>我是能回家的，</p>
<p>因为，</p>
<p>灯还亮着，</p>
<p>路在脚下，</p>
<p>而钥匙在身上。</p>
<p> </p>
<blockquote>
<p>辛丑年5月16日，忆白天琐事走夜路有感，徘徊思索无果，只叹一声“希望博士申请答辩顺利通过”，遂寻道回家。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplus2 Primer Ed5 Reading Notes 1</title>
    <url>/2020/12/18/cplus2_noteI_z/</url>
    <content><![CDATA[<p>Personalized notes taken while reading <a href="https://www.informit.com/store/c-plus-plus-primer-9780321714114">Cplus2 Primer Ed5</a> (C++11 standard) Part I: The Basics and Part II: The C++ Library.<br />
Since the standard has changed now, I will use &quot;<strong>NCC</strong>&quot; to reprensent &quot;not the case currently&quot;. Anyway, good programming convention matters.<br />
Long-term updating required.</p>
<a id="more"></a>
<h1 id="preface">Preface</h1>
<p>Modern C++ can be thought of as comprising three parts:</p>
<ol type="1">
<li>The low-level language, much of which is inherited from C</li>
<li>More advanced language features that allow us to define our own types and to organize large-scale programs and systems</li>
<li>The standard library, which uses these advanced features to provide useful data structures and algorithms</li>
</ol>
<h1 id="chapter-1.-getting-started">Chapter 1. Getting Started</h1>
<ul>
<li><p>The operating system runs a C++ program by calling <code>main</code>.</p></li>
<li><p>On most systems, the value returned from main is a status indicator. A return value of <code>0</code> indicates suceess. A nonzero return has a meaning that is defined by the system. Ordinarily a nonzero return indicates what kind of error occurred.</p></li>
<li><p>A type defines both the contents of a data element and the operations that are possible on those data.</p></li>
<li><p>The value returned from <code>main</code> is accessed in a system-dependent manner. On both UNIX and Windows systems, after executing the program, you must issue an appropriate <code>echo</code> command.<br />
On UNIX systems, we obtain the status by writing <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $?</span><br></pre></td></tr></table></figure> To see the status on a Windows system, we write <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo %ERRORLEVEL%</span><br></pre></td></tr></table></figure></p></li>
<li><p>The output operator <code>&lt;&lt;</code> takes two operands: the left-hand operand must be an <code>ostream</code> object; the right-hand operand is a vaule to print. The result of the output operator is its left-hand operand. The input operator <code>&gt;&gt;</code> behaves analogously to the output operator.</p></li>
<li><p>The manipulator <code>endl</code> has the effect of ending the current line and flushing the buffer associated with that device. Flushing buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written. By default, reading <code>cin</code> flushes <code>cout</code>; <code>cout</code> is also flushed when the program ends normally; writes to <code>cerr</code> are not buffered, usually used for error messages or other output that is not part of the normal logic of the program.<br />
<em>Programmers often add print statements during debugging. Such statements should always flush the stream. Otherwise, if the program crashes, output my be left in the buffer, leading to incorrect inferences about where the program crashed.</em></p></li>
<li><p>When a comment pair does span multiple lines (surely, the best way is to use single-line comments cause comment pairs do not nest), it is often a good idea to indicate visually that the inner lines are part of a multiple comment (e.g. begin each line with an asterisk).</p></li>
<li><p>The best way to comment a block of code is to insert single-line comments at the beginning of each line in the section we want to ignore since that code might contain nested comment pairs but comment pairs do not nest.</p></li>
<li><p>The variable defined in init-statement of <code>for</code>'s header exists only inside the <code>for</code>; it is not possible to use the variable after the loop terminates.</p></li>
<li><p>When we use an <code>istream</code> as a condition, <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br></pre></td></tr></table></figure> the effect is to test the state of the stream. If the stream is valid—that is, if the stream hasn't encountered an error—then the test succeeds.<br />
<em>An <code>istream</code> becomes invalid when we hit end-of-file (e.g. ctrl+z on Win or ctrl+d on UNIX) or encounter an invalid input, such as reading a value that is not an integer.</em></p></li>
<li><p>Most operating systems support file redirection (to avoid tediously repeated typing), which lets us associate a named file with the standard input and the standard output: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ exefile &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure> This command will read input from a file named <code>infile</code> and write its output to a file named <code>outfile</code> in the current directory.</p></li>
</ul>
<h1 id="chapter-2.-variables-and-basic-types">Chapter 2. Variables and Basic Types</h1>
<ul>
<li><p>C++ is a statically typed language; type checking is done at compile time.</p></li>
<li><p>To give meaning to memory at a given address, we must know the type of the value stored there. The type determines how many bits are used and how to interpret those bits.</p></li>
<li><p>Which of the two character representations <code>signed char</code> and <code>unsigned char</code> is equivalent to <code>char</code> depends on the compiler. So computations using <code>char</code> are especially problematic because <code>char</code> is <code>signed</code> on some machines and <code>unsigned</code> on others. If you need a tiny integer, explicitly specify either <code>signed char</code> or <code>unsigned char</code>.<br />
<em>Do not use plain <code>char</code> or <code>bool</code> in arithmetic expressions. Use them only to hold characters or truth values.</em></p></li>
<li><p>If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold. If we assign an out-of-range value to an object of signed type, the result is undefined. Expressions that mix signed and unsigned values can yield suprising results when the signed value is negative since signed values are automatically converted to unsigned in an arithmetic expression.</p></li>
<li><p>Programs usually should avoid implementation-defined behavior. Such programs are said to be nonportable. When program is moved to another machine, code that relied on implementation-defined behavior may fail.<br />
<em>Tracking down these sorts of problems in previously working programs is, mildly put, unpleasant.</em></p></li>
<li><p>The type of a string literal is array of constant <code>char</code>s. The compiler appends a null character (<code>'\0'</code>) to every string literal. Thus, the actual size of a string literal is one more that its apparent size.</p></li>
<li><p>Two string literals that appear adjacent to one another and that are seperated only by spaces, tabs or newlines are concatenated into a single literal.<br />
<em>We use this form of literal when we need to write a literal that would otherwise be too large to fit comfortably on a single line.</em></p></li>
<li><p>Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object's current value and replaces that value with a new one.</p></li>
<li><p>When used with variables of built-in type, the list initialization has one important property: The compiler will not let us initialize variables of built-in type if the initializer might lead to the loss of information: <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="comment">// error: narrowing conversion required</span></span><br><span class="line">int c(ld), d = ld; // ok: but value will be truncated</span><br></pre></td></tr></table></figure></p></li>
<li><p>The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. With one exception, variables of built-in type defined inside a function are uninitialized. The value of an uninitialized variable of built-in type is undefined. (<strong>NCC</strong>)</p></li>
<li><p>DEFINITION <span class="math inline">\(\subseteq\)</span> DECLARATION.<br />
To support seperate compilation, C++ distinguishes between declarations and definitions. A declaration makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name.<br />
Variables must be defined exactly once but can be declared many times. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable. It is an error to provide an initializer on an <code>extern</code> inside a function.</p></li>
<li><p>Local object with a same as the global object will hide the global one. Use scope operator <code>::</code> to override the default scoping rules. When the scope operator has an empty left-hand side, it is a request to fetch the name on the right-hand side from the global scope.</p></li>
<li><p>Ordinarily, when we initialize a variable, the value of the initializer is copied into the object we are creating. When we define a reference, instead of copying the initializer's value, we bind the reference to its initializer. References must be initialized and cannot be rebound to refer to other different objects.<br />
<em>A reference is not an object. Instead, it is just another name for an already existing object. So we may not define a reference to a reference. Since references do not have addresses, we may not define a reference or pointer to a reference.</em></p></li>
<li><p><code>nullptr</code> is a literal that has a special type that can be converted to any other pointer type. If the pointer is 0, then the condition is <code>false</code>. Any nonzero pointer evaluates as <code>true</code>. Using an invalid pointer as a condition or in a comparison is undefined.</p></li>
<li><p>A <code>void*</code> pointer holds an address, but the type of the object at that address is unknown. We cannot use a <code>void*</code> to operate on the object it addresses—we don't know that object's type. Generally, we use a <code>void*</code> pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory.</p></li>
<li><p>In the code <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure> the <code>int</code> is called base type, <code>*</code> and <code>&amp;</code> are type modifiers.</p></li>
<li><p>It can be easier to understand complicated pointer or reference declarations if you read them from right to left. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line"><span class="keyword">int</span>* ip, &amp;r = ip; <span class="comment">// invalid bind</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>const</code> variables are defined as local to the file. When we define a <code>const</code> with the same name in multiple files, it is as if we had written definitions for seperate variables in each file. When we have a <code>const</code> that we want to share across multiple files but whose initializer is not a constant expression, we need to use <code>extern</code> on both its definition and declaration(s).</p></li>
<li><p>We can initialize a reference to <code>const</code> from any expression that can be converted to the type of the reference. In particular, we can bind a reference to <code>const</code> to a non<code>const</code> object, a literal, or a more general expression. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure> but here we cannot use <code>r1</code> to change <code>i</code>. When we use <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure> the compiler transforms this into something like <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure> Since binding a reference to a temporary is almost surely not what the programmer intended and the language makes it illegal, we cannot use a nonconst reference in the above examples.</p></li>
<li><p>We use the term top-level <code>const</code> to indicate that the pointer itself is a <code>const</code>. When a pointer can point to a <code>const</code> object, we refer to that <code>const</code> as a low-level <code>const</code>. The distinction between top-level and low-level matters when we copy an object: top-level <code>const</code>s are ignored at that time. On the other hand, low-level <code>const</code> is never ignored. When we copy an object, both objects must have the same low-level <code>const</code> qualification or there must be a conversion between the types of the two objects.<br />
<em><code>const</code> in reference types is always low-level.</em></p></li>
<li><p>When define a pointer in a <code>constexpr</code> declaration, the <code>constexpr</code> specifier applies to the pointer, not the type to which the pointer points, which means that the <code>constexpr</code> imposes a top-level <code>const</code> on the objects it defines.</p></li>
<li><p>Attension, <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring *cstr = <span class="number">0</span>; <span class="comment">// cstr is a constant pointer to char, not a pointer to `const` `char`, since the type of pstring is &quot;pointer to `char`&quot;, which means that the base type of declaration is a pointer type</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>As with any other type specifier, we can define multiple variables using <code>auto</code>. Because a declaration can involve only a single base type, the initializers for all the variables in the declaration must have types that are consistent with each other.</p></li>
<li><p><code>auto</code> ordinarily ignores top-level <code>const</code>s. As usual in initializations, low-level <code>const</code>s, such as when an initializer is a pointer to <code>const</code>, are kept. If we want the deduced type to have top-level <code>const</code>, we must say so explicitly. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = ci; <span class="comment">// a is an int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b = ci; <span class="comment">// b has type const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;c = ci; <span class="comment">// c is a const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;d = <span class="number">42</span>; <span class="comment">// error: cannot bind a plain reference to a literal</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;e = <span class="number">42</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure> From above we can see that when we ask for a reference to an <code>auto</code>-deduced type, top-level <code>const</code>s in the initializer are not ignored.</p></li>
<li><p>When the expression to which we apply <code>decltype</code> is a variable, <code>decltype</code> returns the type of that variable, including top-level <code>const</code> and references. And <code>decltype</code> returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) a = <span class="number">0</span>; <span class="comment">// a has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) b; <span class="comment">// error: b is a reference and must be initialized</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) c; <span class="comment">// ok: addition yields an int; c is an (uninitialized) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) d; <span class="comment">// error: d is int&amp; and must be initialized</span></span><br></pre></td></tr></table></figure> If we use <code>decltype(r)</code>, we will get a reference type. Another important difference between <code>decltype</code> and <code>auto</code> is that the deduction done by <code>decltype</code> depends on the form of its given expression. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) e; <span class="comment">// error: e is int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(i) f; <span class="comment">// ok: f is an int</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="chapter-3.-strings-vectors-and-arrays">Chapter 3. Strings, Vectors, and Arrays</h1>
<ul>
<li><p>Code inside headers ordinarily should not use <code>using</code> declarations. The reason is that the contents of a header are copied into the including program's text. If a header has a <code>using</code> declaration, then every program that includes that header gets that same <code>using</code> declaration. As a result, a program that didn't intend to use the specified library name might encounter unexpected name conflicts. Use the C++ versions of C library headers.</p></li>
<li><p>Like the input operator, <code>getline</code> returns its <code>istream</code> argument. The newline that causes <code>getline</code> to return is discarded; the newline is not stored in the <code>string</code>.</p></li>
<li><p>String literals are not standard library <code>string</code>s. The <code>string</code> library lets us convert both character literals and character string literals to <code>string</code>s. E.g. when we mix <code>string</code>s and string or character literals, at least one operand to each <code>+</code> operator must be of <code>string</code> type.</p></li>
<li><p>When we use curly braces, we're saying that, if possible, we want to list initialize the object. That is, if there is a way to use the values inside the curly braces as a list of element initializers, the class will do so. Only if it is not possible to list initialize the object will the other ways to initialize the object be considered.</p></li>
<li><p>Since <code>vector</code>s grow efficiently, it is often unnecessary—and can result in poorer performance—to define a <code>vector</code> of a specific size.<br />
<em>The exception to this rule is if all the elements actually need the same value. If differing element values are needed, it is usually more efficient to define an empty <code>vector</code> and add elements as the values we need become known at run time.</em></p></li>
<li><p>The body of a range <code>for</code> must not change the size of the sequence over which it is iterating. (<strong>NCC</strong>)</p></li>
<li><p>A valid iterator either denotes an element or denotes a position one past the last element in a container. All other iterator values are invalid. If container is empty, <code>begin</code> returns the same iterator as the one returned by <code>end</code>-they are both off-the-end iterators.</p></li>
<li><p>Any operation, such as <code>push_back</code>, that changes the size of a <code>vector</code> potentially invalidates all iterators into that <code>vector</code>. It is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.</p></li>
<li><p>Iterators are equal if they denote the same element or if they are both off-the-end iterators for the same container. Otherwise, they are unequal. Subtracting two iterators yields the number that when added to the right-hand iterator yields the left-hand iterator. The iterators must denote elements in, or one past the end of, the same container.<br />
<em>In subtracting the result type is a signed integral type named <code>difference_type</code>.</em></p></li>
<li><p>In most expressions, when we use an object of array type, we are really using a pointer to the first element in that array.</p></li>
<li><p>Unlike subscripts for <code>vector</code> and <code>string</code>, the index of the built-in subscript operator is not an <code>unsigned</code> type.</p></li>
</ul>
<h1 id="chapter-4.-expressions">Chapter 4. Expressions</h1>
<ul>
<li><p>Roughly speaking, when we use an object as an rvalue, we use the object's value (its contents). When we use an object as an lvalue, we use the object's identity (its location in memory). We can use an lvalue when an rvalue is requried, but we cannot use an rvalue when an lvalue (i.e., a location) is required (with one exception that will be covered later).</p></li>
<li><p><code>sizeof</code> does not evaluate its operand, so dereferencing an invalid pointer as the operand to <code>sizeof</code> is safe because the pointer is not actually used.</p></li>
</ul>
<h1 id="chapter-5.-statements">Chapter 5. Statements</h1>
<ul>
<li>Throwing an exception terminates the current function and transfers control to a handler that will know how to handle this error. When a <code>catch</code> is selected to handle an exception, the associated block is executed.</li>
</ul>
<h1 id="chapter-6.-functions">Chapter 6. Functions</h1>
<ul>
<li><p>Parameter initialization works the same way as variable in initialization.</p></li>
<li><p>Using reference parameters could avoid copying objects of large class types or large containers. (Moreover, some class type cannot be copied.) Reference parameters that are not changed inside a function should be references to <code>const</code>.</p></li>
<li><p>When you use the arguments in <code>argv</code>, remember that the optional arguments begin in <code>argv[1]</code>, <code>arg[0]</code> contains the program's name (or empty string), not user input.</p></li>
<li><p>Never return a reference or pointer to a local object. Reference returns are LVALUES.</p></li>
<li><p>The form of a function that returns a pointer to an array is <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type (*function(parameter_list))[dimension]</span><br></pre></td></tr></table></figure></p></li>
<li><p>Overloaded functions must differ in the number or the type(s) of their parameters. It is an error for two functions to differ only in terms of their return types. A parameter that has a top-level <code>const</code> is indistinguishable from one without a top-level <code>const</code>. On the other hand, we can overload based on whether the parameter is a reference (or pointer) to the <code>const</code> or non<code>const</code> version of a given type; such <code>const</code>s are low-level. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>; <span class="comment">// redeclares</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// also redeclares</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>; <span class="comment">// new function that takes a const reference</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>; <span class="comment">// new function, takes a pointer to const</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>If a parameter has a default argument, all the parameters that follow it must also have default arguments. To override the default for the last parameter, we must also supply arguments for the first several parameters (if exist). So we may design the ordering of parameters so that those least likely to use a default value appear first and those most likely to use a default appear last.</p></li>
<li><p>Names used as default arguments are resolved in the scope of the function declaration.</p></li>
<li><p>The <code>inline</code> mechanism is meant to optimize small, straight-line functions that are called frequnetly. The specification is only a request to the compiler. The compiler may choose to ignore this request.</p></li>
</ul>
<h1 id="chapter-7.-classes">Chapter 7. Classes</h1>
<ul>
<li><p>Member functions access the object on which they were called through an extra, implicit parameter named <code>this</code>. When we call a member function, <code>this</code> is initialized with the address of the object on which the function was invoked. Any direct use of a member of the class is assumed to be an implicit reference through <code>this</code>. (<code>this</code> is a <code>const</code> pointer.)</p></li>
<li><p>Although <code>this</code> is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind <code>this</code> to a <code>const</code> object. This means that we cannot call an ordinary member function on a <code>const</code> object. A <code>const</code> following the parameter list (i.e., <code>const</code> member function) indicates that <code>this</code> is a pointer to <code>const</code>. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">  <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">  <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_data total;</span><br><span class="line">total.isbn();</span><br><span class="line">Sales_data::isbn(&amp;total);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data *<span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Unlike other member functions, constructors may not be declared as <code>const</code>. When we create a <code>const</code> object of a class type, the object does not assume its &quot;<code>const</code>ness&quot; until after the constructor completes the object's initialization.</p></li>
<li><p>Classes that have members of built-in or compound type usually should rely on the synthesized default constructor only if all such members have in-class initializers. If we define any constructors, the class will not have a default constructor unless we define that constructor ourselves.</p></li>
<li><p><code>= default</code> defines the default constructor. We are defining this constructor only because we want to provide other constructors as well as the default constructor. We want this constructor to do exactly the same work as the synthesized version we had been using.</p></li>
<li><p>We can define a class type using either keyword, <code>struct</code> or <code>class</code>. The only difference between them is the default access level. If we use the <code>struct</code> keyword, the members defined before the first access specifier are <code>public</code>; if we use <code>class</code>, then the members are <code>private</code>.<br />
<em>As a matter of programming style, when we define a class intending for all of its members to be <code>public</code>, we use <code>struct</code>. If we intend to have <code>private</code> members, then we use <code>class</code>.</em></p></li>
<li><p>Friend declarations may appear only inside a class definition. Friends are not members of the class and are not affected by the access control of the section in which they are declared.</p></li>
<li><p>Unlike ordinary members, members that define types must appear before they are used.</p></li>
<li><p>It sometimes (but not very often) happens that a class has a data member that we want to be able to modify, even inside a <code>const</code> member function. We indicate such members by including the <code>mutable</code> keyword in their declaration. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.</p></li>
<li><p>When we provide an in-class initializer, we must do so following an <code>=</code> sign or inside braces. (See <a href="https://stackoverflow.com/questions/24836526/why-c11-in-class-initializer-cannot-use-parentheses">this post</a>.)</p></li>
<li><p>A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. It is important to understand that friendship is not transitive.</p></li>
<li><p>A class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend.</p></li>
<li>Class definitions are processed in two phases:
<ul>
<li>First, the member declarations are compiled.</li>
<li>Function bodies are compiled only after the entire class has been seen.</li>
</ul>
<p>Member function definitions are processed after the compiler processes all of the declarations in the class.</p></li>
</ul>
<h1 id="chapter-8.-the-io-library">Chapter 8. The IO Library</h1>
<h1 id="chapter-9.-sequential-containers">Chapter 9. Sequential Containers</h1>
<h1 id="chapter-10.-generic-algorithms">Chapter 10. Generic Algorithms</h1>
<h1 id="chapter-11.-associative-containers">Chapter 11. Associative Containers</h1>
<h1 id="chapter-12.-dynamic-memory">Chapter 12. Dynamic Memory</h1>
]]></content>
      <categories>
        <category>学习</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>study notes</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplus2 Linux Development Course Note</title>
    <url>/2022/10/24/cplus_ncprog_z/</url>
    <content><![CDATA[<p>来自牛客 C++ 项目.</p>
<a id="more"></a>
<h1 id="ch2.-多进程开发">Ch2. 多进程开发</h1>
<h2 id="进程概述">2.1 进程概述</h2>
<ul>
<li>程序是包含一系列信息的文件, 这些信息描述了如何在运行时创建一个进程.</li>
<li>进程是正在运行的程序的实例, 是一个具有一定独立功能的程序关于某个数据集合的一次运行活动, 是操作系统动态执行的基本单元. 在传统的操作系统中, 进程既是基本的分配单元, 也是基本的执行单元.</li>
<li>进程是内核定义的抽象实体, 并为该实体分配用以执行程序的各项系统资源. 从内核角度看, 进程由<strong>用户内存空间</strong>和<strong>一系列内核数据结构</strong>组成.</li>
<li>单道程序, 多道程序, 时间片, Linux 进程调度算法.</li>
<li>并行: 指在同一时刻，有多条指令在多个处理器上同时执行. 并发: 指在同一时刻只能有一条指令执行, 但多个进程指令被快速地轮换执行, 使得宏观上具有多个进程同时执行的效果.</li>
<li>内核会为每个进程分配一个进程控制块 (Processing Control Block, PCB), 维护进程相关的信息. Linux 下的 PCB 是 <code>task_struct</code> 结构体, 可在 <code>/usr/src/linux-headers-xxx/include/linux/sched.h</code> 文件中查询相关定义. 其成员包括不限于: 进程 id, 进程状态, 进程切换时需要保存和恢复的 CPU 寄存器, 描述虚拟地址空间的信息, 描述控制终端的信息, 当前工作目录, umask 掩码, 文件描述符表, 和信号相关的信息, 用户 id 与组 id, 会话和进程组, 进程可用资源上限 (<code>ulimit -a</code>) 等.</li>
</ul>
<h2 id="进程状态转换">2.2 进程状态转换</h2>
<ul>
<li>三态模型. <strong>就绪</strong>: 进程具备运行条件, 等待系统分配处理器以便运行; <strong>运行</strong>: 进程占有处理器正在运行; <strong>阻塞</strong>: wait 或 sleep, 进程不具备运行条件, 正在等待某个事件的完成. 五态模型. <strong>新建</strong>: 进程刚被创建时的状态, 尚未进入就绪队列; <strong>就绪</strong>; <strong>运行</strong>; <strong>阻塞</strong>; <strong>终止</strong>: 正常结束或异常终止, 或被操作系统或其他进程终止. 终止态进程不再执行, 待其他进程完成了对其的信息抽取后, 操作系统将删除该进程.</li>
<li>查看进程: | <code>ps aux / ajx</code> | | --------------------------------------------- | | <code>a</code>: 显示终端上的所有进程, 包括其他用户的进程 | | <code>u</code>: 详细信息 | | <code>x</code>: 没有控制终端的进程 | | <code>j</code>: 与作业控制相关的信息 | <code>tty</code>: 终端信息; <code>STAT</code>: 状态信息; <code>PPID</code>, <code>PID</code>, <code>PGID</code>: 父进程, 进程, 进程组 id. ## 2.3 进程创建</li>
</ul>
<h1 id="chapter-1.-getting-started">Chapter 1. Getting Started</h1>
<ul>
<li><p>The operating system runs a C++ program by calling <code>main</code>.</p></li>
<li><p>On most systems, the value returned from main is a status indicator. A return value of <code>0</code> indicates suceess. A nonzero return has a meaning that is defined by the system. Ordinarily a nonzero return indicates what kind of error occurred.</p></li>
<li><p>A type defines both the contents of a data element and the operations that are possible on those data.</p></li>
<li><p>The value returned from <code>main</code> is accessed in a system-dependent manner. On both UNIX and Windows systems, after executing the program, you must issue an appropriate <code>echo</code> command.<br />
On UNIX systems, we obtain the status by writing <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $?</span><br></pre></td></tr></table></figure> To see the status on a Windows system, we write <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo %ERRORLEVEL%</span><br></pre></td></tr></table></figure></p></li>
<li><p>The output operator <code>&lt;&lt;</code> takes two operands: the left-hand operand must be an <code>ostream</code> object; the right-hand operand is a vaule to print. The result of the output operator is its left-hand operand. The input operator <code>&gt;&gt;</code> behaves analogously to the output operator.</p></li>
<li><p>The manipulator <code>endl</code> has the effect of ending the current line and flushing the buffer associated with that device. Flushing buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written. By default, reading <code>cin</code> flushes <code>cout</code>; <code>cout</code> is also flushed when the program ends normally; writes to <code>cerr</code> are not buffered, usually used for error messages or other output that is not part of the normal logic of the program.<br />
<em>Programmers often add print statements during debugging. Such statements should always flush the stream. Otherwise, if the program crashes, output my be left in the buffer, leading to incorrect inferences about where the program crashed.</em></p></li>
<li><p>When a comment pair does span multiple lines (surely, the best way is to use single-line comments cause comment pairs do not nest), it is often a good idea to indicate visually that the inner lines are part of a multiple comment (e.g. begin each line with an asterisk).</p></li>
<li><p>The best way to comment a block of code is to insert single-line comments at the beginning of each line in the section we want to ignore since that code might contain nested comment pairs but comment pairs do not nest.</p></li>
<li><p>The variable defined in init-statement of <code>for</code>'s header exists only inside the <code>for</code>; it is not possible to use the variable after the loop terminates.</p></li>
<li><p>When we use an <code>istream</code> as a condition, <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br></pre></td></tr></table></figure> the effect is to test the state of the stream. If the stream is valid—that is, if the stream hasn't encountered an error—then the test succeeds.<br />
<em>An <code>istream</code> becomes invalid when we hit end-of-file (e.g. ctrl+z on Win or ctrl+d on UNIX) or encounter an invalid input, such as reading a value that is not an integer.</em></p></li>
<li><p>Most operating systems support file redirection (to avoid tediously repeated typing), which lets us associate a named file with the standard input and the standard output: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ exefile &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure> This command will read input from a file named <code>infile</code> and write its output to a file named <code>outfile</code> in the current directory.</p></li>
</ul>
<h1 id="chapter-2.-variables-and-basic-types">Chapter 2. Variables and Basic Types</h1>
<ul>
<li><p>C++ is a statically typed language; type checking is done at compile time.</p></li>
<li><p>To give meaning to memory at a given address, we must know the type of the value stored there. The type determines how many bits are used and how to interpret those bits.</p></li>
<li><p>Which of the two character representations <code>signed char</code> and <code>unsigned char</code> is equivalent to <code>char</code> depends on the compiler. So computations using <code>char</code> are especially problematic because <code>char</code> is <code>signed</code> on some machines and <code>unsigned</code> on others. If you need a tiny integer, explicitly specify either <code>signed char</code> or <code>unsigned char</code>.<br />
<em>Do not use plain <code>char</code> or <code>bool</code> in arithmetic expressions. Use them only to hold characters or truth values.</em></p></li>
<li><p>If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold. If we assign an out-of-range value to an object of signed type, the result is undefined. Expressions that mix signed and unsigned values can yield suprising results when the signed value is negative since signed values are automatically converted to unsigned in an arithmetic expression.</p></li>
<li><p>Programs usually should avoid implementation-defined behavior. Such programs are said to be nonportable. When program is moved to another machine, code that relied on implementation-defined behavior may fail.<br />
<em>Tracking down these sorts of problems in previously working programs is, mildly put, unpleasant.</em></p></li>
<li><p>The type of a string literal is array of constant <code>char</code>s. The compiler appends a null character (<code>'\0'</code>) to every string literal. Thus, the actual size of a string literal is one more that its apparent size.</p></li>
<li><p>Two string literals that appear adjacent to one another and that are seperated only by spaces, tabs or newlines are concatenated into a single literal.<br />
<em>We use this form of literal when we need to write a literal that would otherwise be too large to fit comfortably on a single line.</em></p></li>
<li><p>Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object's current value and replaces that value with a new one.</p></li>
<li><p>When used with variables of built-in type, the list initialization has one important property: The compiler will not let us initialize variables of built-in type if the initializer might lead to the loss of information: <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="comment">// error: narrowing conversion required</span></span><br><span class="line">int c(ld), d = ld; // ok: but value will be truncated</span><br></pre></td></tr></table></figure></p></li>
<li><p>The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. With one exception, variables of built-in type defined inside a function are uninitialized. The value of an uninitialized variable of built-in type is undefined. (<strong>NCC</strong>)</p></li>
<li><p>DEFINITION <span class="math inline">\(\subseteq\)</span> DECLARATION.<br />
To support seperate compilation, C++ distinguishes between declarations and definitions. A declaration makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name.<br />
Variables must be defined exactly once but can be declared many times. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable. It is an error to provide an initializer on an <code>extern</code> inside a function.</p></li>
<li><p>Local object with a same as the global object will hide the global one. Use scope operator <code>::</code> to override the default scoping rules. When the scope operator has an empty left-hand side, it is a request to fetch the name on the right-hand side from the global scope.</p></li>
<li><p>Ordinarily, when we initialize a variable, the value of the initializer is copied into the object we are creating. When we define a reference, instead of copying the initializer's value, we bind the reference to its initializer. References must be initialized and cannot be rebound to refer to other different objects.<br />
<em>A reference is not an object. Instead, it is just another name for an already existing object. So we may not define a reference to a reference. Since references do not have addresses, we may not define a reference or pointer to a reference.</em></p></li>
<li><p><code>nullptr</code> is a literal that has a special type that can be converted to any other pointer type. If the pointer is 0, then the condition is <code>false</code>. Any nonzero pointer evaluates as <code>true</code>. Using an invalid pointer as a condition or in a comparison is undefined.</p></li>
<li><p>A <code>void*</code> pointer holds an address, but the type of the object at that address is unknown. We cannot use a <code>void*</code> to operate on the object it addresses—we don't know that object's type. Generally, we use a <code>void*</code> pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory.</p></li>
<li><p>In the code <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure> the <code>int</code> is called base type, <code>*</code> and <code>&amp;</code> are type modifiers.</p></li>
<li><p>It can be easier to understand complicated pointer or reference declarations if you read them from right to left. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line"><span class="keyword">int</span>* ip, &amp;r = ip; <span class="comment">// invalid bind</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>const</code> variables are defined as local to the file. When we define a <code>const</code> with the same name in multiple files, it is as if we had written definitions for seperate variables in each file. When we have a <code>const</code> that we want to share across multiple files but whose initializer is not a constant expression, we need to use <code>extern</code> on both its definition and declaration(s).</p></li>
<li><p>We can initialize a reference to <code>const</code> from any expression that can be converted to the type of the reference. In particular, we can bind a reference to <code>const</code> to a non<code>const</code> object, a literal, or a more general expression. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure> but here we cannot use <code>r1</code> to change <code>i</code>. When we use <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure> the compiler transforms this into something like <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure> Since binding a reference to a temporary is almost surely not what the programmer intended and the language makes it illegal, we cannot use a nonconst reference in the above examples.</p></li>
<li><p>We use the term top-level <code>const</code> to indicate that the pointer itself is a <code>const</code>. When a pointer can point to a <code>const</code> object, we refer to that <code>const</code> as a low-level <code>const</code>. The distinction between top-level and low-level matters when we copy an object: top-level <code>const</code>s are ignored at that time. On the other hand, low-level <code>const</code> is never ignored. When we copy an object, both objects must have the same low-level <code>const</code> qualification or there must be a conversion between the types of the two objects.<br />
<em><code>const</code> in reference types is always low-level.</em></p></li>
<li><p>When define a pointer in a <code>constexpr</code> declaration, the <code>constexpr</code> specifier applies to the pointer, not the type to which the pointer points, which means that the <code>constexpr</code> imposes a top-level <code>const</code> on the objects it defines.</p></li>
<li><p>Attension, <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring *cstr = <span class="number">0</span>; <span class="comment">// cstr is a constant pointer to char, not a pointer to `const` `char`, since the type of pstring is &quot;pointer to `char`&quot;, which means that the base type of declaration is a pointer type</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>As with any other type specifier, we can define multiple variables using <code>auto</code>. Because a declaration can involve only a single base type, the initializers for all the variables in the declaration must have types that are consistent with each other.</p></li>
<li><p><code>auto</code> ordinarily ignores top-level <code>const</code>s. As usual in initializations, low-level <code>const</code>s, such as when an initializer is a pointer to <code>const</code>, are kept. If we want the deduced type to have top-level <code>const</code>, we must say so explicitly. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = ci; <span class="comment">// a is an int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b = ci; <span class="comment">// b has type const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;c = ci; <span class="comment">// c is a const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;d = <span class="number">42</span>; <span class="comment">// error: cannot bind a plain reference to a literal</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;e = <span class="number">42</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure> From above we can see that when we ask for a reference to an <code>auto</code>-deduced type, top-level <code>const</code>s in the initializer are not ignored.</p></li>
<li><p>When the expression to which we apply <code>decltype</code> is a variable, <code>decltype</code> returns the type of that variable, including top-level <code>const</code> and references. And <code>decltype</code> returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) a = <span class="number">0</span>; <span class="comment">// a has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) b; <span class="comment">// error: b is a reference and must be initialized</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) c; <span class="comment">// ok: addition yields an int; c is an (uninitialized) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) d; <span class="comment">// error: d is int&amp; and must be initialized</span></span><br></pre></td></tr></table></figure> If we use <code>decltype(r)</code>, we will get a reference type. Another important difference between <code>decltype</code> and <code>auto</code> is that the deduction done by <code>decltype</code> depends on the form of its given expression. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) e; <span class="comment">// error: e is int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(i) f; <span class="comment">// ok: f is an int</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="chapter-3.-strings-vectors-and-arrays">Chapter 3. Strings, Vectors, and Arrays</h1>
<ul>
<li><p>Code inside headers ordinarily should not use <code>using</code> declarations. The reason is that the contents of a header are copied into the including program's text. If a header has a <code>using</code> declaration, then every program that includes that header gets that same <code>using</code> declaration. As a result, a program that didn't intend to use the specified library name might encounter unexpected name conflicts. Use the C++ versions of C library headers.</p></li>
<li><p>Like the input operator, <code>getline</code> returns its <code>istream</code> argument. The newline that causes <code>getline</code> to return is discarded; the newline is not stored in the <code>string</code>.</p></li>
<li><p>String literals are not standard library <code>string</code>s. The <code>string</code> library lets us convert both character literals and character string literals to <code>string</code>s. E.g. when we mix <code>string</code>s and string or character literals, at least one operand to each <code>+</code> operator must be of <code>string</code> type.</p></li>
<li><p>When we use curly braces, we're saying that, if possible, we want to list initialize the object. That is, if there is a way to use the values inside the curly braces as a list of element initializers, the class will do so. Only if it is not possible to list initialize the object will the other ways to initialize the object be considered.</p></li>
<li><p>Since <code>vector</code>s grow efficiently, it is often unnecessary—and can result in poorer performance—to define a <code>vector</code> of a specific size.<br />
<em>The exception to this rule is if all the elements actually need the same value. If differing element values are needed, it is usually more efficient to define an empty <code>vector</code> and add elements as the values we need become known at run time.</em></p></li>
<li><p>The body of a range <code>for</code> must not change the size of the sequence over which it is iterating. (<strong>NCC</strong>)</p></li>
<li><p>A valid iterator either denotes an element or denotes a position one past the last element in a container. All other iterator values are invalid. If container is empty, <code>begin</code> returns the same iterator as the one returned by <code>end</code>-they are both off-the-end iterators.</p></li>
<li><p>Any operation, such as <code>push_back</code>, that changes the size of a <code>vector</code> potentially invalidates all iterators into that <code>vector</code>. It is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.</p></li>
<li><p>Iterators are equal if they denote the same element or if they are both off-the-end iterators for the same container. Otherwise, they are unequal. Subtracting two iterators yields the number that when added to the right-hand iterator yields the left-hand iterator. The iterators must denote elements in, or one past the end of, the same container.<br />
<em>In subtracting the result type is a signed integral type named <code>difference_type</code>.</em></p></li>
<li><p>In most expressions, when we use an object of array type, we are really using a pointer to the first element in that array.</p></li>
<li><p>Unlike subscripts for <code>vector</code> and <code>string</code>, the index of the built-in subscript operator is not an <code>unsigned</code> type.</p></li>
</ul>
<h1 id="chapter-4.-expressions">Chapter 4. Expressions</h1>
<ul>
<li><p>Roughly speaking, when we use an object as an rvalue, we use the object's value (its contents). When we use an object as an lvalue, we use the object's identity (its location in memory). We can use an lvalue when an rvalue is requried, but we cannot use an rvalue when an lvalue (i.e., a location) is required (with one exception that will be covered later).</p></li>
<li><p><code>sizeof</code> does not evaluate its operand, so dereferencing an invalid pointer as the operand to <code>sizeof</code> is safe because the pointer is not actually used.</p></li>
</ul>
<h1 id="chapter-5.-statements">Chapter 5. Statements</h1>
<ul>
<li>Throwing an exception terminates the current function and transfers control to a handler that will know how to handle this error. When a <code>catch</code> is selected to handle an exception, the associated block is executed.</li>
</ul>
<h1 id="chapter-6.-functions">Chapter 6. Functions</h1>
<ul>
<li><p>Parameter initialization works the same way as variable in initialization.</p></li>
<li><p>Using reference parameters could avoid copying objects of large class types or large containers. (Moreover, some class type cannot be copied.) Reference parameters that are not changed inside a function should be references to <code>const</code>.</p></li>
<li><p>When you use the arguments in <code>argv</code>, remember that the optional arguments begin in <code>argv[1]</code>, <code>arg[0]</code> contains the program's name (or empty string), not user input.</p></li>
<li><p>Never return a reference or pointer to a local object. Reference returns are LVALUES.</p></li>
<li><p>The form of a function that returns a pointer to an array is <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type (*function(parameter_list))[dimension]</span><br></pre></td></tr></table></figure></p></li>
<li><p>Overloaded functions must differ in the number or the type(s) of their parameters. It is an error for two functions to differ only in terms of their return types. A parameter that has a top-level <code>const</code> is indistinguishable from one without a top-level <code>const</code>. On the other hand, we can overload based on whether the parameter is a reference (or pointer) to the <code>const</code> or non<code>const</code> version of a given type; such <code>const</code>s are low-level. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>; <span class="comment">// redeclares</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// also redeclares</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>; <span class="comment">// new function that takes a const reference</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>; <span class="comment">// new function, takes a pointer to const</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>If a parameter has a default argument, all the parameters that follow it must also have default arguments. To override the default for the last parameter, we must also supply arguments for the first several parameters (if exist). So we may design the ordering of parameters so that those least likely to use a default value appear first and those most likely to use a default appear last.</p></li>
<li><p>Names used as default arguments are resolved in the scope of the function declaration.</p></li>
<li><p>The <code>inline</code> mechanism is meant to optimize small, straight-line functions that are called frequnetly. The specification is only a request to the compiler. The compiler may choose to ignore this request.</p></li>
</ul>
<h1 id="chapter-7.-classes">Chapter 7. Classes</h1>
<ul>
<li><p>Member functions access the object on which they were called through an extra, implicit parameter named <code>this</code>. When we call a member function, <code>this</code> is initialized with the address of the object on which the function was invoked. Any direct use of a member of the class is assumed to be an implicit reference through <code>this</code>. (<code>this</code> is a <code>const</code> pointer.)</p></li>
<li><p>Although <code>this</code> is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind <code>this</code> to a <code>const</code> object. This means that we cannot call an ordinary member function on a <code>const</code> object. A <code>const</code> following the parameter list (i.e., <code>const</code> member function) indicates that <code>this</code> is a pointer to <code>const</code>. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">  <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">  <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_data total;</span><br><span class="line">total.isbn();</span><br><span class="line">Sales_data::isbn(&amp;total);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data *<span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Unlike other member functions, constructors may not be declared as <code>const</code>. When we create a <code>const</code> object of a class type, the object does not assume its &quot;<code>const</code>ness&quot; until after the constructor completes the object's initialization.</p></li>
<li><p>Classes that have members of built-in or compound type usually should rely on the synthesized default constructor only if all such members have in-class initializers. If we define any constructors, the class will not have a default constructor unless we define that constructor ourselves.</p></li>
<li><p><code>= default</code> defines the default constructor. We are defining this constructor only because we want to provide other constructors as well as the default constructor. We want this constructor to do exactly the same work as the synthesized version we had been using.</p></li>
<li><p>We can define a class type using either keyword, <code>struct</code> or <code>class</code>. The only difference between them is the default access level. If we use the <code>struct</code> keyword, the members defined before the first access specifier are <code>public</code>; if we use <code>class</code>, then the members are <code>private</code>.<br />
<em>As a matter of programming style, when we define a class intending for all of its members to be <code>public</code>, we use <code>struct</code>. If we intend to have <code>private</code> members, then we use <code>class</code>.</em></p></li>
<li><p>Friend declarations may appear only inside a class definition. Friends are not members of the class and are not affected by the access control of the section in which they are declared.</p></li>
<li><p>Unlike ordinary members, members that define types must appear before they are used.</p></li>
<li><p>It sometimes (but not very often) happens that a class has a data member that we want to be able to modify, even inside a <code>const</code> member function. We indicate such members by including the <code>mutable</code> keyword in their declaration. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.</p></li>
<li><p>When we provide an in-class initializer, we must do so following an <code>=</code> sign or inside braces. (See <a href="https://stackoverflow.com/questions/24836526/why-c11-in-class-initializer-cannot-use-parentheses">this post</a>.)</p></li>
<li><p>A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. It is important to understand that friendship is not transitive.</p></li>
<li><p>A class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend.</p></li>
<li>Class definitions are processed in two phases:
<ul>
<li>First, the member declarations are compiled.</li>
<li>Function bodies are compiled only after the entire class has been seen.</li>
</ul>
<p>Member function definitions are processed after the compiler processes all of the declarations in the class.</p></li>
</ul>
<h1 id="chapter-8.-the-io-library">Chapter 8. The IO Library</h1>
<h1 id="chapter-9.-sequential-containers">Chapter 9. Sequential Containers</h1>
<h1 id="chapter-10.-generic-algorithms">Chapter 10. Generic Algorithms</h1>
<h1 id="chapter-11.-associative-containers">Chapter 11. Associative Containers</h1>
<h1 id="chapter-12.-dynamic-memory">Chapter 12. Dynamic Memory</h1>
]]></content>
      <categories>
        <category>学习</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>study notes</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>(ICML20) Streaming Algorithms for M$k$SC under Noise</title>
    <url>/2020/11/16/icml20_noisy_MkSC_z/</url>
    <content><![CDATA[<p>这几年次模优化里做 <span class="math inline">\(k\)</span>-submodular 的开始多起来了, 不过目前不管是 offline 还是 streaming setting 下, 大多做的都是无约束的最大化算法. 而基数约束问题 Maximize a <span class="math inline">\(k\)</span>-submodular function subject to Size Constraint (M<span class="math inline">\(k\)</span>SC) 的研究还较少, 且也仅限于单调函数的情况. ICML2020 里出现了一篇研究 streaming 下的 non-monotone M<span class="math inline">\(k\)</span>SC 算法的<a href="http://optnetsci.cise.ufl.edu/papers/icml20lan.pdf">文章</a>, 且文章还假设了对 objective function 的 query 是困难的, 只能间接获得一个 (有 bound 保证的) 真实值的估计 (就是所谓带噪数据). 这篇博文在介绍一下该论文的同时, 也是对 <span class="math inline">\(k\)</span> 次模函数的一个简单调研.</p>
<a id="more"></a>
<h2 id="preliminaries">Preliminaries</h2>
<h3 id="k-submodular-function"><span class="math inline">\(k\)</span>-submodular function</h3>
<p><span class="math inline">\(k\)</span>-submodular 函数是 submodular 函数的自然 extension. 给定 ground set 为 <span class="math inline">\(V\)</span>, 定义 <span class="math inline">\(V\)</span> 上的 <span class="math inline">\(k\)</span>-tuple 是 <span class="math inline">\(k\)</span> 个两两不交子集作为分量的 <span class="math inline">\(k\)</span> 维向量, 即 <span class="math display">\[
      (k+1)^{V}:=\{(S_1,\dots,S_k):S_i\subseteq V,S_i\cap S_j=\emptyset,\ \forall i\neq j,\ i,j\in[k]\}
  \]</span> 称函数 <span class="math inline">\(f:(k+1)^{V}\to\mathbb{R}_{\geq0}\)</span> 是 <span class="math inline">\(k\)</span>-submodular 的, 若对 <span class="math inline">\((k+1)^{V}\)</span> 里的任意两个元素 <span class="math inline">\(S=(S_1,\dots,S_k)\)</span> 和 <span class="math inline">\(T=(T_1,\dots,T_k)\)</span> 都有 <span class="math display">\[
    f(S)+f(T)\geq f(S\sqcap T)+f(S\sqcup T)
\]</span> 其中 <span class="math display">\[
      \begin{aligned}
        &amp; S\sqcap T := (S_1\cap T_1,\dots,S_k\cap T_k)\\
        &amp; S\sqcup T := \bigg((S_1\cup T_1)\Big\backslash\Big(\bigcup_{i\in[k]\backslash\{1\}}(S_i\cup T_i)\Big),\dots,(S_k\cup T_k)\Big\backslash\Big(\bigcup_{i\in[k]\backslash\{k\}}(S_i\cup T_i)\Big)\bigg)
      \end{aligned}
  \]</span></p>
<h3 id="notations-and-properties">Notations and properties</h3>
<ul>
<li>对 <span class="math inline">\(\mathbf{x}=(X_1,\dots,X_k)\in(k+1)^V\)</span>, 令 <span class="math inline">\(\text{supp}(\mathbf{x})=\cup_{i\in[k]}X_i\)</span>, 且记 <span class="math inline">\(\mathbf{x}\)</span> 特征函数为 <span class="math display">\[
    \mathbf{x}(e)=\begin{cases}
        i,&amp; \text{if}\ e\in X_i \\
        0,&amp; \text{if}\ e\in V\backslash\text{supp}(\mathbf{x})
    \end{cases}
\]</span> 为方便起见, 记 <span class="math inline">\(|\mathbf{x}|=|\text{supp}(\mathbf{x})|\)</span>. 特别地, 我们记 <span class="math inline">\(\mathbf{x}=\langle e,i\rangle\)</span>, 若 <span class="math inline">\(\mathbf{x}(e)=i,\mathbf{x}(e&#39;)=0,\forall e&#39;\in V\backslash\{e\}\)</span>. 另外, 我们记 <span class="math inline">\(i\)</span> 方向的 marginal gain 为 <span class="math display">\[
    \Delta_{e,i}f(\mathbf{x})=f(\mathbf{x}\sqcup\langle e,i\rangle)-f(\mathbf{x})
\]</span> 特别地, 若 <span class="math inline">\(\Delta_{e,i}f(\mathbf{x})\geq0\)</span> 对任意 <span class="math inline">\(\mathbf{x}\in(k+1)^V,\mathbf{x}(e)=0\)</span> 成立, 我们就说这个 <span class="math inline">\(k\)</span>-submodular 函数是单调的.</li>
<li>对 <span class="math inline">\((k+1)^V\)</span> 中的元素 <span class="math inline">\(\mathbf{x}=(X_1,\dots,X_k)\)</span> 和 <span class="math inline">\(\mathbf{y}=(Y_1,\dots,Y_k)\)</span>, 我们记 <span class="math inline">\(\mathbf{x}\sqsubseteq\mathbf{y}\)</span>, 若 <span class="math inline">\(X_i\subseteq Y_i\)</span>, <span class="math inline">\(\forall i\in[k]\)</span>. 显然, 由次模性我们可以推出 <span class="math display">\[
    \Delta_{e,i}f(\mathbf{y})\leq \Delta_{e,i}f(\mathbf{x}),\ \forall \mathbf{x}\sqsubseteq\mathbf{y},\mathbf{y}(e)=0
\]</span> 另外由次模性我们可以得到 <span class="math inline">\(k\)</span>-submodular 函数所谓 pairwise-monotone 的重要性质: <span class="math display">\[
    \Delta_{e,i}f(\mathbf{x})+\Delta_{e,j}f(\mathbf{x})\geq0,\ \forall \mathbf{x}\in(k+1)^V,\mathbf{x}(e)=0,i,j\in[k],i\neq j
\]</span></li>
<li>称函数 <span class="math inline">\(F:(k+1)^V\to\mathbb{R}\)</span> 是 <span class="math inline">\(f\)</span> 的 <span class="math inline">\(\epsilon\)</span>-estimate, 若 <span class="math display">\[
    (1-\epsilon)f(\mathbf{x})\leq F(\mathbf{x})\leq (1+\epsilon)f(\mathbf{x}),\ \forall\mathbf{x}\in(k+1)^V
\]</span></li>
</ul>
<h3 id="problem-definition">Problem definition</h3>
<p>给定一个有限集合 <span class="math inline">\(V\)</span>, 一个 <span class="math inline">\(k\)</span>-submodular 函数 <span class="math inline">\(f\)</span> 的 <span class="math inline">\(\epsilon\)</span>-estimate <span class="math inline">\(F\)</span> 和一个正整数 <span class="math inline">\(B\)</span>, 我们要解决如下问题 <span class="math display">\[
    \begin{aligned}
        \text{Maximize}&amp;\quad f(\mathbf{s}) \\
        \text{Subject to}&amp;\quad \mathbf{s}\in(k+1)^V,\ |\mathbf{s}|\leq B
    \end{aligned}
\]</span> 这个问题是 NP 难的 (并且我们仅知道带噪数据 <span class="math inline">\(F\)</span>, 且 streaming setting 下只能最多进行一次遍历全体数据 <span class="math inline">\(V\)</span> 的操作), 所以我们只能去寻求效果最好的近似解. 记理论上的一个最优解为 <span class="math inline">\(\mathbf{o}\)</span>, 即 <span class="math inline">\(f(\mathbf{o})=\text{max}_{|\mathbf{s}|\leq B}f(\mathbf{s})\)</span>. 容易看出 <span class="math inline">\(k=1\)</span> 时就是基数约束下的次模优化问题.</p>
<h2 id="algorithms">Algorithms</h2>
<p>文章首先提出了<strong>已知 <span class="math inline">\(f(\mathbf{o})\)</span> 的值</strong>的确定性算法.</p>
<div class="note info no-icon"><h3 id="alg.-1-dstream-with-known-fmathbfo">(Alg. 1) DStream with known <span class="math inline">\(f(\mathbf{o})\)</span></h3>
<p>input <span class="math inline">\(V,F,k,B,M\)</span> and <span class="math inline">\(o,\gamma\)</span> s.t. <span class="math inline">\(f(\mathbf{o})\geq o\times B\geq f(\mathbf{o})/(1+\gamma)\)</span><br />
initiate <span class="math inline">\(\mathbf{s}^0=\{\emptyset,\dots,\emptyset\}\)</span>, <span class="math inline">\(t=0\)</span><br />
<strong>for</strong> each <span class="math inline">\(e\in V\)</span>:<br />
  <strong>if</strong> <span class="math inline">\(|\mathbf{s}^t|&lt;B\)</span>:<br />
    find <span class="math inline">\(i=\text{argmax}_{i&#39;\in [k]}F(\mathbf{s}^t\sqcup\langle e,i&#39;\rangle)\)</span><br />
    <strong>if</strong> <span class="math inline">\(\frac{F(\mathbf{s}^t\sqcup\langle e,i\rangle)}{1-\epsilon}\geq(t+1)\frac{o}{M}\)</span>:<br />
      <span class="math inline">\(\mathbf{s}^{t+1}=\mathbf{s}^t\sqcup\langle e,i\rangle\)</span><br />
      <span class="math inline">\(t=t+1\)</span><br />
<strong>return</strong> <span class="math inline">\(\mathbf{s}^t\)</span> if <span class="math inline">\(f\)</span> is monotone; <span class="math inline">\(\text{argmax}_{\mathbf{s}\in\{\mathbf{s}^j:j\leq t\}}F(\mathbf{s})\)</span> if <span class="math inline">\(f\)</span> is non-monotone.</p>
</div>
<p>可以看出这个算法的开始类似梯度下降: 在每一轮对新的元素 <span class="math inline">\(e\)</span> 的处理时, 首先选择一个下降速度最快的方向 <span class="math inline">\(i\)</span>. 接着算法使用 <span class="math inline">\(\frac{F}{(1-\epsilon)(t+1)}\)</span> 来近似 (往大了取) 当前平均值 <span class="math inline">\(\frac{f}{t+1}\)</span>, 通过判断这个值和预先设定好的 threshold 值 <span class="math inline">\(\frac{o}{M}\)</span> 的大小关系来决定是否将 <span class="math inline">\(e\)</span> 加入到集合中. (即, 排除掉那些对集合贡献不大的元素.)</p>
<div class="note primary no-icon"><h4 id="proposition-1">Proposition 1</h4>
<p>If <span class="math inline">\(\mathbf{s}\)</span> is an output of Alg. 1 under monotone case, then it satisfies <span class="math display">\[
  f(\mathbf{o})\leq\max\Big\{(1+\gamma)(1+\epsilon),\frac{2+4B\epsilon}{M-1}\Big\}\frac{M}{1-\epsilon}f(\mathbf{s})
\]</span></p>
</div>
<p>如下为<strong>未知 <span class="math inline">\(f(\mathbf{o})\)</span> 的值</strong>时的确定性算法.</p>
<div class="note info no-icon"><h3 id="alg.-2-dstream-without-known-fmathbfo">(Alg. 2) DStream without known <span class="math inline">\(f(\mathbf{o})\)</span></h3>
<p>input <span class="math inline">\(V,F,k,B,M&gt;1,\gamma&gt;0\)</span><br />
initiate <span class="math inline">\(\Delta_u=\Delta_l=\Delta=0\)</span>, <span class="math inline">\(t_j=0,\forall j\in\mathbb{Z}^+\)</span><br />
<strong>for</strong> each <span class="math inline">\(e\in V\)</span>:<br />
  <span class="math inline">\(\Delta=\max\{\Delta,\max_{j\in[k]}F(\langle e,j\rangle)\}\)</span><br />
  <span class="math inline">\(\Delta_u=\Delta\big/(1-\epsilon),\ \ \Delta_l=\Delta\big/((1+\epsilon)(1+\gamma))\)</span><br />
  <span class="math inline">\(O=\{(1+\gamma)^j\ |\ \frac{\Delta_l}{BM}\leq(1+\gamma)^j\leq(1+\epsilon)\Delta_u\}\)</span><br />
  <strong>for</strong> each <span class="math inline">\(j\)</span> s.t. <span class="math inline">\((1+\gamma)^j\in O\)</span>:<br />
    <span class="math inline">\(o=M(1+\gamma)^j\)</span><br />
    <strong>if</strong> <span class="math inline">\(t_j&lt;B\)</span>:<br />
      <span class="math inline">\(i=\text{argmax}_{j&#39;\in[k]}F(\mathbf{s}_j^{t_j}\sqcup\langle e,j&#39;\rangle)\)</span><br />
      <strong>if</strong> <span class="math inline">\(\frac{F(\mathbf{s}_j^{t_j}\sqcup\langle e,i\rangle)}{1-\epsilon}\geq(t_j+1)\frac{o}{M}\)</span>:<br />
        <span class="math inline">\(\mathbf{s}_j^{t_j+1}=\mathbf{s}_j^{t_j}\sqcup\langle e,i\rangle\)</span><br />
        <span class="math inline">\(t_j=t_j+1\)</span><br />
<strong>return</strong> <span class="math inline">\(\text{argmax}_{\mathbf{s}_j^{t_j}:j\in O}F(\mathbf{s}_j^{t_j})\)</span> if <span class="math inline">\(f\)</span> is monotone; <span class="math inline">\(\text{argmax}_{\mathbf{s}_j^{i}:i\leq t_j,j\in O}F(\mathbf{s}_j^{i})\)</span> if <span class="math inline">\(f\)</span> is non-monotone.</p>
</div>
<p>这个算法的大致思路仍类似经典的 sieve streaming: 当我们不知道 <span class="math inline">\(f(\mathbf{o})\)</span> 时, 想办法构造一个包含 <span class="math inline">\([\frac{f(\mathbf{o})}{(1+\gamma)B},\frac{f(\mathbf{o})}{B}]\)</span> 的区间, 并在该区间内散布诸多 sieve 以期望其中有一个 sieve 能达到 Alg. 1 中 <span class="math inline">\(o\)</span> 的效果. 那么此时这个区间该如何估计? 由于 <span class="math inline">\(F\)</span> 的 <span class="math inline">\(\epsilon\)</span>-estimate 性质, 必然有 <span class="math display">\[
    (1-\epsilon)\max_{|\mathbf{x}|=1}f(\mathbf{x})\leq\max_{|\mathbf{x}|=1}F(\mathbf{x})\leq(1+\epsilon)\max_{|\mathbf{x}|=1}f(\mathbf{x})
\]</span> 利用次模性, 所以 <span class="math inline">\(\Delta_u=\max_{|\mathbf{x}|=1}\frac{F(\mathbf{x})}{1-\epsilon}\)</span> 就可作为 <span class="math inline">\(\frac{f(\mathbf{o})}{B}\)</span> 的一个 upper bound, <span class="math inline">\(\Delta_l/B=\max_{|\mathbf{x}|=1}\frac{F(\mathbf{x})}{(1+\epsilon)(1+\gamma)B}\)</span> 可作为 <span class="math inline">\(\frac{f(\mathbf{o})}{(1+\gamma)B}\)</span> 的一个 lower bound. 所以 sieve 集合 <span class="math inline">\(\{(1+\gamma)^j\ |\ j\in\mathbb{Z},\frac{\Delta_l}{BM}\leq(1+\gamma)^j\leq\frac{\Delta_u}{M}\}\)</span> 中就存在 <span class="math inline">\(v\)</span> 使得 <span class="math inline">\(vM\)</span> 是 <span class="math inline">\(o\)</span> 的一个理想值, <span class="math inline">\(v\)</span> 所对应的集合 <span class="math inline">\(S_v\)</span> 就是我们想要的估计值. 有了这个区间和筛子, 我们对每个到来的元素都分别对各个筛子过一遍 Alg. 1 就可以了.</p>
<p>那么现在的问题是, 我们并不能提前知道所有单元素集合中使得 <span class="math inline">\(f\)</span> 最大的那个. 所以算法中对上下界 <span class="math inline">\(\Delta_u,\Delta_l\)</span> 采取了 lazy estimation 的做法: 即取当前所见过的单元素集合的最大值. 事实上, 下界因为变小了, 对算法的正确性并没有什么影响, 而上界可能损失一些性质比较好的集合. 所以我们调整上界到让算法能包含当前能使得 <span class="math inline">\(S_v\)</span> 非空的最大的 <span class="math inline">\(v\)</span>. 由于 <span class="math display">\[
    \frac{F(\mathbf{s})}{1+\epsilon}\leq |\mathbf{s}|\max_{\mathbf{s}(e)\neq0,i\in[k]}\frac{F(\langle e,i \rangle)}{1-\epsilon}
\]</span> 故不等式 <span class="math display">\[
    \frac{F(\mathbf{s})}{1-\epsilon}&gt;\frac{(1+\epsilon)|\mathbf{s}|}{1-\epsilon}\max_{\mathbf{s}(e)\neq0,i\in[k]}\frac{F(\langle e,i \rangle)}{1-\epsilon}
\]</span> 必然不成立, 这启发我们取 <span class="math inline">\(\frac{o}{M}=M&#39;(1+\epsilon)\Delta_u\)</span>, 这里 <span class="math inline">\(M&#39;\)</span> 是可以任取一个大于 <span class="math inline">\(\frac{1}{1-\epsilon}\)</span> 的常数. 所以算法的 sieve 集合可取为 <span class="math display">\[
\Big\{(1+\gamma)^j\ |\ j\in\mathbb{Z},\frac{\Delta_l}{BM}\leq(1+\gamma)^j\leq\frac{M&#39;}{M}(1+\epsilon)\Delta_u\Big\}
\]</span> (这里跟原文取的不太一样, 原文中对应这里直接取了 <span class="math inline">\(M&#39;=M\)</span>, 有点令人费解. 另外原算法中 <span class="math inline">\(j\)</span> 仅取正整数其实是没有道理的, 因为根据我们的分析 <span class="math inline">\(j\)</span> 完全是可以取到负值的.)</p>
<div class="note primary no-icon"><h4 id="proposition-2">Proposition 2</h4>
<p>DStream has query complexity of <span class="math inline">\(O\bigg(\frac{|V|k}{\gamma}\log\Big(\frac{(1+\epsilon)(1+\gamma)}{1-\epsilon}BM\Big)\bigg)\)</span> and takes <span class="math inline">\(O\bigg(\frac{B}{\gamma}\log\Big(\frac{(1+\epsilon)(1+\gamma)}{1-\epsilon}BM\Big)\bigg)\)</span> memory. If <span class="math inline">\(f\)</span> is monotone, the approximation ratio is <span class="math display">\[
  \frac{1+\epsilon}{(1-\epsilon)^2}\min_{x\in(1,M]}\max\bigg\{(1+\gamma)(1+\epsilon)x,\frac{(2+4B\epsilon)x}{x-1}\bigg\}
\]</span> If <span class="math inline">\(f\)</span> is non-monotone, then the ratio is <span class="math display">\[
    \frac{1+\epsilon}{(1-\epsilon)^2}\min_{x\in(1,M]}\max\bigg\{(1+\gamma)(1+\epsilon)x,\frac{(3+4\epsilon+6\epsilon B+\epsilon^2+2\epsilon^2 B)x}{(1-\epsilon)(x-1)}\bigg\}
\]</span></p>
</div>
<p>下面介绍论文提出的一个随机算法.</p>
<div class="note info no-icon"><h3 id="alg.-3-rstream">(Alg. 3) RStream</h3>
<p>input <span class="math inline">\(V,F,k,B,M&gt;1,\gamma&gt;0,\eta\geq1\)</span><br />
initiate <span class="math inline">\(\Delta_u=\Delta_l=\Delta=0\)</span>, <span class="math inline">\(t_{j,\epsilon&#39;}=0,\forall j\in\mathbb{Z}^+,\epsilon&#39;\in\mathbb{R}^+\)</span><br />
<strong>for</strong> each <span class="math inline">\(e\in V\)</span>:<br />
  <span class="math inline">\(\Delta=\max\{\Delta,\max_{j\in[k]}F(\langle e,j\rangle)\}\)</span><br />
  <span class="math inline">\(\Delta_u=\frac{(1+\epsilon)^2+4\epsilon B}{(1-\epsilon^2)(1-\epsilon)}\Delta,\ \ \Delta_l=\Delta\big/((1+\epsilon)(1+\gamma))\)</span><br />
  <span class="math inline">\(O=\{(1+\gamma)^j\ |\ \frac{\Delta_l}{BM}\leq(1+\gamma)^j\leq\Delta_u\}\)</span><br />
  <strong>for</strong> each <span class="math inline">\(j\)</span> s.t. <span class="math inline">\((1+\gamma)^j\in O\)</span>:<br />
    <span class="math inline">\(o=M(1+\gamma)^j\)</span><br />
    <strong>for</strong> each <span class="math inline">\(\epsilon&#39;=\epsilon,\frac{(\eta-2)\epsilon}{\eta-1},\frac{(\eta-3)\epsilon}{\eta-1},\dots,0\)</span>:<br />
      <strong>if</strong> <span class="math inline">\(t_{j,\epsilon&#39;}&lt;B\)</span>:<br />
        <strong>for</strong> each <span class="math inline">\(i\in[k]\)</span>:<br />
          <span class="math inline">\(d_i=\frac{F(\mathbf{s}_{j\epsilon&#39;}^{t_{j,\epsilon&#39;}}\sqcup\langle i,e\rangle)}{1-\epsilon&#39;}-\frac{F(\mathbf{s}_{j\epsilon&#39;}^{t_{j,\epsilon&#39;}})}{1+\epsilon&#39;}\)</span><br />
          <span class="math inline">\(d_i=0\)</span> <strong>if</strong> <span class="math inline">\(d_i&lt;\frac{o}{M}\)</span><br />
        <span class="math inline">\(T=|\{i\ |\ d_i&gt;0\}|\)</span><br />
        <span class="math inline">\(D=\sum_{i\in[k]}d_i^{T-1}\)</span><br />
        <strong>if</strong> <span class="math inline">\(t_{j,\epsilon&#39;}&lt;B\)</span> and <span class="math inline">\(T&gt;0\)</span>:<br />
          <strong>if</strong> <span class="math inline">\(T=1\)</span>:<br />
            <span class="math inline">\(i=\)</span> the only one that <span class="math inline">\(d_i&gt;0\)</span><br />
          <strong>else</strong>:<br />
            <span class="math inline">\(i=\)</span> selected with prob. <span class="math inline">\(d_i^{T-1}\big/D\)</span><br />
          <span class="math inline">\(\mathbf{s}_{j,\epsilon&#39;}^{t_{j,\epsilon&#39;}+1}=\mathbf{s}_{j,\epsilon&#39;}^{t_{j,\epsilon&#39;}}\sqcup\langle e,i\rangle\)</span><br />
          <span class="math inline">\(t_{j,\epsilon&#39;}=t_{j,\epsilon&#39;}+1\)</span><br />
<strong>return</strong> <span class="math inline">\(\text{argmax}_{\mathbf{s}_{j,\epsilon&#39;}^{t_{j,\epsilon&#39;}}:j\in O}F(\mathbf{s}_{j,\epsilon&#39;}^{t_{j,\epsilon&#39;}})\)</span> if <span class="math inline">\(f\)</span> is monotone; <span class="math inline">\(\text{argmax}_{\mathbf{s}_{j,\epsilon&#39;}^{i}:i&lt;t_{j,\epsilon&#39;},j\in O}F(\mathbf{s}_{j,\epsilon&#39;}^{i})\)</span> if <span class="math inline">\(f\)</span> is non-monotone.</p>
</div>
<p>类似之前的想法, 我们仍然需要找出一个合适的 <span class="math inline">\(o\)</span> 使得 <span class="math inline">\(f(\mathbf{o})\geq oB\geq f(\mathbf{o})\big/(1+\gamma)\)</span>. 但是我们不会直接使用 <span class="math inline">\(\text{argmax}\)</span> 方向, 而是对所有 marginal gain 超过 threshold 的方向按比例随机选择其一来加入到 <span class="math inline">\(\mathbf{s}\)</span> 中: 首先我们使用 <span class="math inline">\(d_i\)</span> 来&quot;近似&quot;表达 marginal gain, (因子 <span class="math inline">\(1/(1-\epsilon),1/(1+\epsilon)\)</span> 是为了考虑到 <span class="math inline">\(F(\mathbf{s}\sqcup\langle e,i\rangle)&lt;F(\mathbf{s})\)</span> 最坏的情况.) 并且我们将没有超过 threshold 的 <span class="math inline">\(d_i\)</span> 置零. 然后按概率 <span class="math display">\[
  \mathrm{Pr}[\langle e,i\rangle\ \text{is added to }\mathbf{s}] = d_i^{T-1}\Big/\sum_{j\in[k]}d_j^{T-1}
\]</span> 进行选择, <span class="math inline">\(T=|\{i\ |\ d_i&gt;0\}|\)</span>.</p>
<p>这样简单的处理有一个问题: <span class="math inline">\(d_i\)</span> 作为我们想要求的 <span class="math inline">\(f(\langle e,i\rangle|\mathbf{s})\)</span> 估计值可能效果很差. 例如若 <span class="math inline">\(F(\mathbf{s})\approx f(\mathbf{s})=f(\mathbf{s}\sqcup\langle e,i\rangle)\approx F(\mathbf{s}\sqcup\langle e,i\rangle)\)</span>, 此时 <span class="math inline">\(d_i\approx\frac{2\epsilon}{1-\epsilon^2}f(\mathbf{s})\)</span>, 这可能使得选择方向 <span class="math inline">\(i\)</span> 的几率非零, 即使真实的 marginal gain 此时为 0. 为了解决这个问题, 文章在算法中引入了 <span class="math inline">\(\eta\)</span> 来将 <span class="math inline">\(\epsilon\)</span> 拆分成一系列 <span class="math inline">\(\epsilon&#39;(\to0)\)</span> 来实现某种去随机化的效果: 对每个 <span class="math inline">\(\epsilon&#39;\)</span>, 将 <span class="math inline">\(F\)</span> 视作 <span class="math inline">\(\epsilon&#39;\)</span>-estimate 进行计算, 即对每个 sieve <span class="math inline">\(j\)</span>, 都有一串 <span class="math inline">\(\{t_{j,\epsilon&#39;}\}_{\epsilon&#39;}\)</span> 来记录各个 <span class="math inline">\(\epsilon&#39;\)</span> 下集合的大小.</p>
<p>那么这个时候的 <span class="math inline">\(\Delta_u\)</span> 如何选择? 首先 <span class="math display">\[
    \frac{F(\mathbf{s}\sqcup\langle i,e\rangle)}{1-\epsilon}-\frac{F(\mathbf{s})}{1+\epsilon}=\frac{1}{1-\epsilon^2}\Big(F(\mathbf{s}\sqcup\langle i,e\rangle)-F(\mathbf{s})+\epsilon\big(F(\mathbf{s}\sqcup\langle i,e\rangle)+F(\mathbf{s})\big)\Big)
\]</span> 注意到 <span class="math display">\[
  \begin{aligned}
    F(\mathbf{s}\sqcup\langle i,e\rangle)-F(\mathbf{s})\leq&amp;(1+\epsilon)f(\mathbf{s}\sqcup\langle i,e\rangle)-(1-\epsilon)f(\mathbf{s})\\
    =&amp;f(\mathbf{s}\sqcup\langle i,e\rangle)-f(\mathbf{s})+\epsilon\big(f(\mathbf{s}\sqcup\langle i,e\rangle)+f(\mathbf{s})\big)\\
    \leq&amp;\frac{\Delta}{1-\epsilon}+2B\epsilon\Delta
  \end{aligned}
\]</span> 故可取 (和原文仍稍有出入) <span class="math display">\[
  \frac{1}{1-\epsilon^2}\Big(\frac{\Delta}{1-\epsilon}+2B\epsilon\Delta+2B(1+\epsilon)\epsilon\Delta\Big)\leq\frac{1+4B\epsilon}{(1-\epsilon^2)(1-\epsilon)}\Delta=\Delta_u
\]</span></p>
<div class="note primary no-icon"><h4 id="proposition-3">Proposition 3</h4>
<p>RStream has query complexity of <span class="math inline">\(O\bigg(\frac{\eta|V|k}{\gamma}\log\Big(\frac{(1+\gamma)((1+\epsilon)^2+4\epsilon B)}{(1-\epsilon)^2}BM\Big)\bigg)\)</span> and takes <span class="math inline">\(O\bigg(\frac{\eta B}{\gamma}\log\Big(\frac{(1+\gamma)((1+\epsilon)^2+4\epsilon B)}{(1-\epsilon)^2}BM\Big)\bigg)\)</span> memory. If <span class="math inline">\(f\)</span> is monotone, the approximation ratio is <span class="math display">\[
  \frac{1+\epsilon}{1-\epsilon}\min_{x\in(1,M]}\max\bigg\{\frac{(1+\epsilon+2B\epsilon)(1+\gamma)x}{1-\epsilon},\Big(\frac{(1+\epsilon)^2+4B\epsilon}{1-\epsilon^2}(1-k^{-1})+1\Big)\frac{kx}{kx-k-1}\bigg\}
\]</span> If <span class="math inline">\(f\)</span> is non-monotone, then the ratio is <span class="math display">\[
    \frac{1+\epsilon}{1-\epsilon}\min_{x\in(1,M]}\max\bigg\{\frac{(1+\epsilon+2B\epsilon)(1+\gamma)x}{1-\epsilon},\frac{(3k-2)(1+\epsilon)^2+(8k-8)\epsilon B}{(1-\epsilon)^2}\frac{x}{kx-k-2}\bigg\}
\]</span></p>
</div>
<h2 id="greedy-on-f">Greedy on <span class="math inline">\(F\)</span></h2>
<p>现在我们考虑直接使用 greedy 算法的效果.</p>
<div class="note info no-icon"><h3 id="alg.-4-greedy-algorithm">(Alg. 4) Greedy Algorithm</h3>
<p>input <span class="math inline">\(V,F,k,B\)</span><br />
initiate <span class="math inline">\(\mathbf{s}^0=\{\emptyset,\dots,\emptyset\}\)</span><br />
<strong>for</strong> <span class="math inline">\(t=1\)</span> to <span class="math inline">\(B\)</span>:<br />
  <span class="math inline">\(e,i=\text{argmax}_{e\in V\backslash\text{supp}(\mathbf{s}),i\in[k]}F(\mathbf{s}^{t-1}\sqcup\langle e,i\rangle)\)</span>:<br />
  <span class="math inline">\(\mathbf{s}^{t}=\mathbf{s}^{t-1}\sqcup\langle e,i\rangle\)</span><br />
<strong>return</strong> <span class="math inline">\(\mathbf{s}^B\)</span> if <span class="math inline">\(f\)</span> is monotone; <span class="math inline">\(\text{argmax}_{\mathbf{s}\in\{\mathbf{s}^j:j\leq B\}}F(\mathbf{s})\)</span> if <span class="math inline">\(f\)</span> is non-monotone.</p>
</div>
<div class="note primary no-icon"><h4 id="proposition-4">Proposition 4</h4>
<p>If <span class="math inline">\(\mathbf{s}\)</span> is an output of Alg. 4 under monotone case, then it satisfies <span class="math display">\[
  f(\mathbf{o})\leq\frac{2+2\epsilon B}{1-\epsilon}f(\mathbf{s})
\]</span></p>
</div>
<p><strong><em>Proof of Proposition 4:</em></strong> 设 <span class="math inline">\(e^j,i^j\)</span> 是算法第 <span class="math inline">\(j\)</span> 轮选中的元素和方向, 按如下方式构造 <span class="math inline">\(\{\mathbf{o}^j\}\)</span> 序列:</p>
<ul>
<li><span class="math inline">\(\mathbf{o}^0=\mathbf{o}\)</span></li>
<li><p>当 <span class="math inline">\(j&gt;0\)</span> 时, 记 <span class="math inline">\(S^j=\text{supp}(\mathbf{o}^{j-1})\backslash\text{supp}(\mathbf{s}^{j-1})\)</span>. 并令 <span class="math display">\[
    o^j=\begin{cases}
      e^j,&amp;\text{if}\ e^j\in S^j\\
      \text{an arbitrary element in }S^j,&amp;\text{otherwise}
    \end{cases}
\]</span> 再定义 <span class="math inline">\(\mathbf{o}^{j-1/2},\mathbf{o}^{j},\mathbf{s}^{j-1/2}\in(k+1)^V\)</span> 使得</p>
<span class="math display">\[\begin{aligned}
    &amp;\mathbf{o}^{j-1/2}(e)=\begin{cases}
      0,&amp; e=o^j\\
      \mathbf{o}^{j-1}(e),&amp; e\in V\backslash\{o^j\}
    \end{cases},\ \

    \mathbf{o}^{j}(e)=\begin{cases}
      i^j,&amp; e=e^j\\
      \mathbf{o}^{j-1/2}(e),&amp; e\in V\backslash\{e^j\}
    \end{cases},\\

    &amp;\mathbf{s}^{j-1/2}(e)=\begin{cases}
      i^j,&amp; e=o^j\\
      \mathbf{s}^{j-1}(e),&amp; e\in V\backslash\{o^j\}
    \end{cases}
  \end{aligned}\]</span>
<p>(简单解释就是, 对第 <span class="math inline">\(j\)</span> 轮选出的 <span class="math inline">\(i,e\)</span>, 若 <span class="math inline">\(e\in\text{supp}(\mathbf{o}^{j-1})\backslash\text{supp}(\mathbf{s}^{j-1})\)</span>, 则构造 <span class="math inline">\(\mathbf{o}^j\)</span> 为从 <span class="math inline">\(\mathbf{o}^{j-1}\)</span> 里删掉元素 <span class="math inline">\(e\)</span> 后再重新把 <span class="math inline">\(e\)</span> 加到 <span class="math inline">\(i\)</span> 位置上; 若 <span class="math inline">\(e\notin\text{supp}(\mathbf{o}^{j-1})\backslash\text{supp}(\mathbf{s}^{j-1})\)</span>, 则构造 <span class="math inline">\(\mathbf{o}^j\)</span> 为从 <span class="math inline">\(\text{supp}(\mathbf{o}^{j-1})\backslash\text{supp}(\mathbf{s}^{j-1})\)</span> 任意选一个元素在 <span class="math inline">\(\mathbf{o}^{j-1}\)</span> 中删去后, 再将 <span class="math inline">\(e\)</span> 加到第 <span class="math inline">\(i\)</span> 个位置的集合中去. 而 <span class="math inline">\(\mathbf{o}^{j-1/2}\)</span> 就表示删掉元素后而 <span class="math inline">\(e\)</span> 尚未加入前时的中间量, <span class="math inline">\(\mathbf{s}^{j-1/2}\)</span> 是将被从 <span class="math inline">\(\mathbf{o}^{j-1}\)</span> 删去的元素加到 <span class="math inline">\(\mathbf{s}^{j-1}\)</span> 的第 <span class="math inline">\(i\)</span> 位置上去的辅助量.)</p></li>
</ul>
<p>显然, <span class="math inline">\(\mathbf{s}^j\sqsubseteq\mathbf{o}^j,\mathbf{s}^B=\mathbf{o}^B\)</span> (W.L.O.G. 设 <span class="math inline">\(|\mathbf{o}|=|\mathbf{s}|=B\)</span>). 结合单调性, greedy, 次模性, 我们有 <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o}^{j-1})-f(\mathbf{o}^{j})\leq&amp;f(\mathbf{o}^{j-1})-f(\mathbf{o}^{j-1/2})\leq f(\mathbf{s}^{j-1/2})-f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{1}{1-\epsilon}F(\mathbf{s}^{j-1/2})-f(\mathbf{s}^{j-1})\leq\frac{1}{1-\epsilon}F(\mathbf{s}^{j})-f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s}^{j})-f(\mathbf{s}^{j-1})
  \end{aligned}
\]</span> 因此 <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o})-f(\mathbf{s})=&amp;\sum_{j=1}^B\Big(f(\mathbf{o}^{j-1})-f(\mathbf{o}^j)\Big)\leq\sum_{j=1}^B\Big(\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s}^{j})-f(\mathbf{s}^{j-1})\Big)\\
    \leq&amp;\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s})+\sum_{j=1}^B\frac{2\epsilon}{1-\epsilon}f(\mathbf{s}^{j})\leq\frac{1+\epsilon+2\epsilon B}{1-\epsilon}f(\mathbf{s})
  \end{aligned}
\]</span> 得证.</p>
<details class="note default no-icon"><summary><p><strong>RMK 1</strong></p>
</summary>
<p>从这个证明我们可以看出单调 <span class="math inline">\(k\)</span>-submodular 函数在 cardinality 约束下的近似比只能做到 <span class="math inline">\(1/2\)</span>. 回想 <span class="math inline">\(k=1\)</span> 时最佳近似比 <span class="math inline">\(1-1/e\)</span> 的证明过程中用到的关键不等式 <span class="math display">\[
  f(O)-f(S^{j-1})\leq\sum_{e\in O\backslash S^{j-1}}\Delta_ef(S^{j-1})\leq B(f(S^j)-f(S^{j-1}))
\]</span> 在高维情况下是不起作用的, 因为元素的加入在纵向上按时间排列的同时, 在横向上对集合也有区别, 这就造成了 <span class="math inline">\(f(\mathbf{o})-f(\mathbf{s}^{j-1})\)</span> 无法简单展开, 即类似 <span class="math inline">\(f(\mathbf{o}|\mathbf{s})\)</span> 的表达在高维时会出现问题. 当然, 在固定其他 <span class="math inline">\(k-1\)</span> 个集合的情形下, <span class="math inline">\(f\)</span> 对单个位置上还是有次可加性的, 但总体上来看, 我们也许只能得到 <span class="math display">\[
    f(S_1,\dots,S_k)\leq\bigg|\bigcup_{j\in[k]}S_j\bigg|\sum_{i\in[k]}\Big(\frac{1}{|S_i|}\sum_{e\in S_i}f(\langle e,i\rangle)\Big)
\]</span></p>

</details>
<div class="note primary no-icon"><h4 id="proposition-5">Proposition 5</h4>
<p>If <span class="math inline">\(\mathbf{s}\)</span> is an output of Alg. 4 under non-monotone case, then it satisfies <span class="math display">\[
  f(\mathbf{o})\leq\frac{3+\epsilon+4\epsilon B}{1-\epsilon}f(\mathbf{s})
\]</span></p>
</div>
<p><strong><em>Proof of Proposition 5:</em></strong> 仍然像上面构造 <span class="math inline">\(\mathbf{o}^j,\mathbf{o}^{j-1/2}\)</span>. 由 pairwise-monotonicity, 必存在 <span class="math inline">\(i&#39;\in[k]\)</span> 使得 <span class="math inline">\(f(\mathbf{s}^{j-1}\sqcup\langle e^j,i&#39;\rangle)\geq f(\mathbf{s}^{j-1})\)</span>. 另外由 greedy 选择: <span class="math display">\[
  f(\mathbf{s}^{j-1}\sqcup\langle e^j,i&#39;\rangle)\leq\frac{1}{1-\epsilon}F(\mathbf{s}^{j-1}\sqcup\langle e^j,i&#39;\rangle)\leq\frac{1}{1-\epsilon}F(\mathbf{s}^j)\leq\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s}^j)
\]</span> 考虑如下三种情况:</p>
<ul>
<li><span class="math inline">\(\mathbf{o}^{j-1}(e^j)=i^j\)</span>. 此时 <span class="math inline">\(e^j\)</span> 不动, <span class="math inline">\(\mathbf{o}^{j}=\mathbf{o}^{j-1}\)</span>, 故 <span class="math inline">\(f(\mathbf{o}^{j-1})-f(\mathbf{o}^j)=0\leq\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s}^j)-f(\mathbf{s}^{j-1})\)</span>.</li>
<li><span class="math inline">\(\mathbf{o}^{j-1}(e^j)=0\)</span>. 此时 <span class="math inline">\(e^j\)</span> 与 <span class="math inline">\(\text{supp}(\mathbf{o}^{j-1})\backslash\text{supp}(\mathbf{s}^{j-1})\)</span> 中的某个元素进行交换. 令任一 <span class="math inline">\(i&#39;\in[k]\backslash\{i^j\}\)</span>, 有 <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o}^{j-1})-f(\mathbf{o}^{j})=&amp;f(\mathbf{o}^{j-1})+f(\mathbf{o}^{j-1/2}\sqcup\langle e^j,i&#39;\rangle)-2f(\mathbf{o}^{j-1/2})-\Big(f(\mathbf{o}^{j-1/2}\sqcup\langle e^j,i&#39;\rangle)+f(\mathbf{o}^{j})-2f(\mathbf{o}^{j-1/2})\Big)\\
    \leq&amp;f(\mathbf{o}^{j-1})+f(\mathbf{o}^{j-1/2}\sqcup\langle e^j,i&#39;\rangle)-2f(\mathbf{o}^{j-1/2})\\
    \leq &amp;f(\mathbf{s}^{j-1/2})+f(\mathbf{s}^{j-1}\sqcup\langle e^j,i&#39;\rangle)-2f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{1}{1-\epsilon}F(\mathbf{s}^{j-1/2})+\frac{1}{1-\epsilon}F(\mathbf{s}^{j-1}\sqcup\langle e^j,i&#39;\rangle)-2f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{2}{1-\epsilon}F(\mathbf{s}^j)-2f(\mathbf{s}^{j-1})\leq \frac{2(1+\epsilon)}{1-\epsilon}f(\mathbf{s}^j)-2f(\mathbf{s}^{j-1})
  \end{aligned}
\]</span></li>
<li><span class="math inline">\(\mathbf{o}^{j-1}(e^j)\in[k]\backslash\{i^j\}\)</span>. 这种情况表明 <span class="math inline">\(e^j\)</span> 从第 <span class="math inline">\(\mathbf{o}^{j-1}(e^j)\)</span> 个位置移动到了第 <span class="math inline">\(i^j\)</span> 位置上去. <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o}^{j-1})-f(\mathbf{o}^{j})=&amp;2f(\mathbf{o}^{j-1})-2f(\mathbf{o}^{j-1/2})-\Big(f(\mathbf{o}^{j-1})+f(\mathbf{o}^j)-2f(\mathbf{o}^{j-1/2})\Big)\\
    \leq&amp;2f(\mathbf{o}^{j-1})-2f(\mathbf{o}^{j-1/2})\\
    \leq &amp;2f(\mathbf{s}^{j-1/2})-2f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{2}{1-\epsilon}F(\mathbf{s}^{j-1/2})-2f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{2}{1-\epsilon}F(\mathbf{s}^j)-2f(\mathbf{s}^{j-1})\leq \frac{2(1+\epsilon)}{1-\epsilon}f(\mathbf{s}^j)-2f(\mathbf{s}^{j-1})
  \end{aligned}
\]</span></li>
</ul>
<p>综上我们有 <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o})-f(\mathbf{s})=&amp;\sum_{j=1}^B\Big(f(\mathbf{o}^{j-1})-f(\mathbf{o}^j)\Big)\leq2\sum_{j=1}^B\Big(\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s}^{j})-f(\mathbf{s}^{j-1})\Big)\\
    \leq&amp;2\Big(\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s})+\sum_{j=1}^B\frac{2\epsilon}{1-\epsilon}f(\mathbf{s}^{j})\Big)\leq\frac{2+2\epsilon+4\epsilon B}{1-\epsilon}f(\mathbf{s})
  \end{aligned}
\]</span> 得证.</p>
<details class="note default no-icon"><summary><p><strong>RMK 2</strong></p>
</summary>
<p>从这个证明可以看出非单调 <span class="math inline">\(k\)</span>-submodular 函数在 cardinality 约束下的近似比可达到 <span class="math inline">\(3\)</span>. 另外, 在 <span class="math inline">\(k=1\)</span> 时至少能做到 <span class="math inline">\(e\)</span> 的结果了 (见 <a href="https://theory.epfl.ch/moranfe/Publications/SODA2014.pdf">SODA2014 的一篇文章</a>).</p>

</details>
<h2 id="omitted-proofs">Omitted Proofs</h2>
<h3 id="proof-of-proposition-1">Proof of Proposition 1</h3>
<p>首先, 对 <span class="math inline">\(V\)</span> 做完一趟 pass 之后, <span class="math inline">\(|\mathbf{s}|\)</span> 可能达到也可能没达到满的 budget. 若 <span class="math inline">\(t=B\)</span>, 则 <span class="math display">\[
  f(\mathbf{s})\geq\frac{F(\mathbf{s}^B)}{1+\epsilon}\geq\frac{1-\epsilon}{1+\epsilon}B\frac{o}{M}\geq\frac{1-\epsilon}{1+\epsilon}\frac{f(\mathbf{o})}{(1+\gamma)M}
\]</span> 得到近似比之一 <span class="math inline">\((1+\epsilon)(1+\gamma)\frac{M}{1-\epsilon}\)</span>.</p>
<p>下面我们考虑 <span class="math inline">\(t&lt;B\)</span> 时的情况. 定义 <span class="math inline">\(\mathbf{o}^{j}=(\mathbf{o}\sqcup\mathbf{s}^j)\sqcup\mathbf{s}^{j}\)</span>.</p>
<div class="note "><h4 id="claim-1">Claim 1</h4>
<p><span class="math display">\[
  f(\mathbf{o})-f(\mathbf{o}^t)\leq\frac{1+\epsilon+2B\epsilon}{1-\epsilon}f(\mathbf{s})
\]</span></p>
</div>
<p><strong><em>Proof of Claim 1:</em></strong> 类似地, 我们记 <span class="math inline">\(\langle e^j,i^j\rangle\)</span> 是 Alg. 1 中第 <span class="math inline">\(j\)</span> 个加入的元素. 定义 <span class="math inline">\(\mathbf{o}^{j-1/2}=(\mathbf{o}\sqcup\mathbf{s}^j)\sqcup\mathbf{s}^{j-1}\)</span>. 进一步, 我们定义 <span class="math display">\[
    \mathbf{s}^{j-1/2}=\begin{cases}
      \mathbf{s}^{j-1}\sqcup\langle e^j,\mathbf{o}(e^j)\rangle,&amp;\text{if}\ e^j\in\text{supp}(\mathbf{o})\\
      \mathbf{s}^{j-1},&amp;\text{otherwise}
    \end{cases}
\]</span> 此时就有 <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o}^{j-1})-f(\mathbf{o}^j)\leq&amp; f(\mathbf{o}^{j-1})-f(\mathbf{o}^{j-1/2})\\
    \leq&amp;f(\mathbf{s}^{j-1/2})-f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{1}{1-\epsilon}F(\mathbf{s}^{j-1/2})-f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{1}{1-\epsilon}F(\mathbf{s}^j)-f(\mathbf{s}^{j-1})\\
    \leq&amp;\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s}^j)-f(\mathbf{s}^{j-1})
  \end{aligned}
\]</span> 因此 <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o})-f(\mathbf{o}^t)=&amp;\sum_{j=1}^t\Big(f(\mathbf{o}^{j-1})-f(\mathbf{o}^j)\Big)\leq\sum_{j=1}^t\Big(\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s}^j)-f(\mathbf{s}^{j-1})\Big)\\
    =&amp;\frac{1+\epsilon}{1-\epsilon}f(\mathbf{s})+\sum_{j=1}^{t-1}\frac{2\epsilon}{1-\epsilon}f(\mathbf{s}^j)\leq\frac{1+\epsilon+2B\epsilon}{1-\epsilon}f(\mathbf{s})
  \end{aligned}
\]</span> Claim 1 得证.</p>
<div class="note "><h4 id="claim-2">Claim 2</h4>
<p><span class="math display">\[
  f(\mathbf{o}^t)-f(\mathbf{s})\leq\frac{1}{M}f(\mathbf{o})+\frac{2\epsilon B}{1-\epsilon}f(\mathbf{s})
\]</span></p>
</div>
<p><strong><em>Proof of Claim 2:</em></strong> 由于 <span class="math inline">\(\mathbf{s}\sqsubseteq\mathbf{o}^t\)</span>, 用 <span class="math inline">\(\{\langle u_i,j_i\rangle\}_{j=1}^r\)</span> 表示 <span class="math inline">\(\text{supp}(\mathbf{o}^t)\backslash\text{supp}(\mathbf{s})\)</span> 中的元素及其位置, 然后我们用 <span class="math inline">\(\mathbf{s}_i\)</span> 表示 <span class="math inline">\(\mathbf{s}\)</span> 遇到 <span class="math inline">\(u_i\)</span> 时的值. 我们有 <span class="math display">\[
  \frac{F(\mathbf{s}_i\sqcup\langle u_i,j_i\rangle)}{1-\epsilon}-\frac{F(\mathbf{s}_i)}{1+\epsilon}\leq\frac{o}{M}+\frac{2\epsilon F(\mathbf{s}_i)}{1-\epsilon^2}
\]</span> 令 <span class="math inline">\(\mathbf{u}_i=\mathbf{s}\sqcup\{\langle u_1,j_i\rangle,\dots,\langle u_i,j_i\rangle\}\)</span>, 有 <span class="math display">\[
  \begin{aligned}
    f(\mathbf{o}^t)-f(\mathbf{s})=&amp;\sum_{i=1}^{B-t}\Big(f(\mathbf{u}_i)-f(\mathbf{u}_{i-1})\Big)\leq\sum_{i=1}^{B-t}\Big(f(\mathbf{s}_i\sqcup\langle u_i,j_i\rangle)-f(\mathbf{s}_{i})\Big)\\
    \leq&amp;\sum_{i=1}^{B-t}\Big(\frac{1}{1-\epsilon}F(\mathbf{s}_i\sqcup\langle u_i,j_i\rangle)-\frac{1}{1+\epsilon}F(\mathbf{s}^i)\Big)\leq\sum_{i=1}^{B-t}\Big(\frac{o}{M}+\frac{2\epsilon}{1-\epsilon^2}F(\mathbf{s}_i)\Big)\leq\frac{1}{M}f(\mathbf{o})+\frac{2\epsilon B}{1-\epsilon}f(\mathbf{s})
  \end{aligned}
\]</span> Claim 2 得证.</p>
<p>结合 Claim 1, Claim 2 就可完成 Proposition 1 的证明.</p>
<h3 id="proof-of-proposition-2">Proof of Proposition 2</h3>
<p>TBC.</p>
<h3 id="proof-of-proposition-3">Proof of Proposition 3</h3>
<p>TBC.</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>submodular maximization</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>路人女主系列的尾声一 —— memorial 2 豪华版分享</title>
    <url>/2021/01/06/saekano_memorial2_comment_r1.0_s/</url>
    <content><![CDATA[<h2 id="序章">序章</h2>
<p>  新年伊始，预定的台版路人女主小说的最后一卷 memorial 2 的豪华版是终于到货了。原本想把去年到货的我惠手办和剧场版 BD 当作是我对这个系列的句点（因为这小说日版其实很早就发售了），但实际到手看过之后，觉得很有意思，就想拿出来再说一说。同时觉得角川还想用这个作品再捞一笔钱，比如没收录的剧场版特典和深琦暮人老师的路主画集，自己多半还要掏钱，所以我对这个系列到底哪里才算是真正的完结自己也不敢说死，姑且就写个“尾声一”吧。至于会不会有“尾声二”，看我心情随缘吧。</p>
<a id="more"></a>
<p><em>（画外音：是是是，都知道你很喜欢这部作品了，换些其他的作品好吗？）</em></p>
<p>  路人女主小说有 13 本没有后缀的<strong>无印</strong>（以男主为第一人称的故事本篇），3 本 <strong>girl side</strong>（简称 GS ，以各个女主为主要视点的故事本篇），2 本 <strong>FD</strong>（FD 为小说短篇合集，FD 2 为动画 BD 短篇合集）以及 2 本 <strong>memorial</strong>（主要收录了小说店铺和杂志附送特典，设定集，创作者访谈，新的小短篇等）构成。这次的 memorial 2 就收录了剧场版的一部分设定，写作“周边附送的特典”，实则为各种后日谈的短篇，剧场版的声优和制作者访谈，以及作为补充的新短篇。下文就打算以这次小说豪华版的内容和小说本身的内容来进行一下<strong>主观的、业余的、个人色彩浓厚的</strong>分享。</p>
<h2 id="豪华版简单开箱">豪华版简单开箱</h2>
<p>  这次豪华版的包装采用了台版轻小说常见的塑料盒子包装。背面可以看到小说的封面和这次豪华版里包含的内容——小说的特殊封面，卡套和挂饰。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/saenai_1.jpg" width="50%" style="display: inline-block" /><img src="/images/saenai_2.jpg" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>想到应该是最后一本就预定的豪华版，比起《天气之子》，感觉这次外包装挺简单的</em></td>
</tr>
</tbody>
</table>
<!-- ![想到应该是最后一本就预定的豪华版，比起《天气之子》，感觉这次外包装挺简单的](saenai 1&2.jpg) -->
<p>  这次小说封面我个人很喜欢，深崎暮人老师笔下的加藤还是一如既往的好看<em>（应该没带惠痴眼镜，真的……大概……至少有一点点没带）</em>。有趣的是，也不知道是不是深崎暮人老师故意地，这次设计的加藤的站姿与第一卷英梨梨的站姿很相似，暗示“加藤取代了英梨梨在安艺心中的位置”？何迫梨啊wwww……</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/saenai_3.png" width="50%" style="display: inline-block" /><img src="/images/saenai_4.jpg" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>左为 memorial 2 的封面站姿，右为 小说第 1 卷的封面站姿，虽然能理解深崎暮人老师在 13 卷操了很多心，这么对比来看仍觉得是满满的恶意啊</em></td>
</tr>
</tbody>
</table>
<!-- ![左为 memorial 2 的封面站姿，右为 小说第 1 卷的封面站姿，虽然能理解深崎暮人老师在13卷操了很多心，这么对比来看仍觉得是满满的恶意啊](saenai 3&4.jpg) -->
<p>  打开盒子变能看到本次豪华版的内容物——豪华版特殊封面的小说和小周边。由于手上没有普通版的，所以这个特殊封面有啥不同我也不清楚，这里就忽略了。小周边为印有加藤惠的亚克力卡套和挂牌，有一说一，作为锁扣的挂牌可以说经常见到，亚克力卡套我还是第一次见。一开始这玩意儿既宅还粉我觉得蛮羞耻的不敢用，但最后觉得反正认识自己的人都知道我是个没救的阿宅，就拿来装饭卡了<em>（只要自己觉得不尴尬，尴尬的就是别人.jpg）</em></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/saenai_5.jpg" width="50%" style="display: inline-block" /><img src="/images/saenai_6.jpg" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>卡套的正面：与封面相同的加藤惠；挂牌与卡套的背面：大大的 blessing software 社团的 logo 镂空里面可以看到自己的校园卡</em></td>
</tr>
</tbody>
</table>
<!-- ![](saenai 5&6.jpg) -->
<p>  这次豪华版的内容物不算多，我个人感觉还行，但感觉真的溢价，价钱差不多是普通版的一倍多，如果不是我这种作品厨，带收藏性质的话，建议还是卖普通版吧<em>（真的会有人吃了我的安利会买吗？）</em>。重点还是这本小说的内容。</p>
<h2 id="小说内容的感想和吐槽">小说内容的感想和吐槽</h2>
<p>  前面也提了，memorial 2 说是小说，准确来讲应该是各种乱七八糟东西的大杂烩，这里我都拿我印象最深的部分说一下。</p>
<p>  对于<strong>设定集</strong>部分，印象最深当然还是深崎暮人老师对剧场版最后各个角色成人后的设定。看过剧场版的朋友大概知道都长得啥样，但深崎老师的原设感觉比动画更好看就离谱。惠看起来更加人妻化，这真的是之前姿色中等偏上的路人女主吗<em>（捂脸）</em>。英梨梨和学姐的成人后模样原来是参考了红坂朱音和町田苑子的模样吗，这啥？剩斗士联盟的传承吗？太惨了吧。出海和美智留的部分都刻意强调了“动不动泡在安艺房间”这一点，啊这，牛头人狂喜. jpg。至于两个大老爷们儿，这俩帅哥除了发型变了，真的有变化吗……</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/saenai_7.jpeg" width="45%" style="display: inline-block" /><img src="/images/saenai_8.jpeg" width="45%" style="display: inline-block" /><img src="/images/saenai_9.jpeg" width="45%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>果然长发的惠更符合我的口味，长发放下来的英梨梨也好看，好吧，我承认我是长直控啦！齐肩短发的学姐看起来阳光成熟了很多，但是作为标志性的白色发带却没了……算了黑丝还在就无所谓吧</em></td>
</tr>
</tbody>
</table>
<!-- 
![果然长发的惠更符合我的口味，长发放下来的英梨梨也好看，好吧，我承认我是长直控啦！齐肩短发的学姐看起来阳光成熟了很多，但是作为标志性的白色发带却没了……算了黑丝还在就无所谓吧](saenai 7&8&9.jpg) -->
<p>  对于<strong>特典小说</strong>部分，个人觉得都比较有意思，通篇插科打诨，一扫小说后期的沉重部分。但这里我肯定只会说学姐和惠的篇章，哈？英梨梨？这人谁啊？<em>（泥垢啦！）</em>学姐的短篇为《爱与青春的节拍器》和《恋爱与纯情的节拍器》，加起来不过 10 页，并且内容如其标题，就是赤裸裸的外传漫画《恋爱节拍器》的硬推广，甚至开头和结尾都一模一样然后被安艺吐槽是最骚的。有趣的其实是作为外传的学姐和伦理君去看两季 TV 第 0 话，表面相同内核不同的人物看自己在动画表现的感想和吐槽<em>（所以这也算是 TV 动画的逆推广？）</em>。</p>
<blockquote>
<p>不，我才不认同自己在动画中会像这样被安排成卖肉主力的女二。我不认同！  ——霞之丘诗羽《爱与青春的节拍器》</p>
<p>可是动画和原作的那家伙跟我不一样，风评很糟糕啊！  ——安艺伦也《恋爱与纯情的节拍器》</p>
</blockquote>
<p>  话说丸户老贼你知道学姐在正篇是“卖肉主力”啊！知道的话就少写一些擦边球啊喂。就因为擦边球太多，我安利向别人这作品都超困难的<em>（哭）</em>。并且你知道伦理君在小说和动画的风评糟糕啊！既然知道就不要这么卖力朝着那方向塑造啊喂！亲女儿加藤惠的风评也会收到男主的风评影响啊<em>（掀桌）</em>。 说句题外话，《恋爱节拍器》的漫画作画 <strong>武者サブ</strong> 老师和作者 <strong>丸户史明</strong> 的这对搭档的新作《 媒体组合少女》也终于开始连载了，现在大妈之家就能看第 1 话，感兴趣的朋友可以去康康。</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/saenai_10.jpg" width="50%" style="display: inline-block" /><img src="/images/saenai_11.jpg" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>恋节组合的新作：大学刚毕业的男主长濑宏太第一话就阴差阳错就当上了社长，似李，假面骑士零一，修玛吉亚是U咩……咳咳，抱歉，DNA动了。女主之一安藤凪纱标志性的黑长直加黑丝，同时还是小说编辑，不愧是你，丸户史明</em></td>
</tr>
</tbody>
</table>
<!-- ![恋节组合的新作：大学刚毕业的男主长濑宏太第一话就阴差阳错就当上了社长，似李，假面骑士零一，修玛吉亚是U咩……咳咳，抱歉，DNA动了。女主之一安藤凪纱标志性的黑长直加黑丝，同时还是小说编辑，不愧是你，丸户史明](saenai 10&11.jpg) -->
<p>  至于我惠的短篇，用一句话来说就是<strong>“比本篇的互动更甜，更工口。渡航求求你让丸户教你如何写后日谈吧”</strong>。内容覆盖体操服挂画推广，礼服挂画推广，沙滩挂画推广，睡衣挂画推广等，时间则大多在安艺伦也复读到大学一年级期间，最后新增的短篇则是补充了安艺伦也大学二年级第一次负责商业游戏制作的故事<em>（打工人的开始）</em>。讲真，丸户的执念到底有多深啊，别的恋爱系作品要么成双成对点到为止，到了丸户这里硬是从本篇结束到最后新旧 blessing software 社团重聚每个时间段不落都给你交代得明明白白的，剧场版特典以为是从安艺考上大学到成人礼开始跳过了一段时间，memorial 2 通通给你补上了，这就是黄油剧本家的时间管理能力吗，👴是真滴佛了。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="/images/saenai_12.png" width="50%" style="display: inline-block" /><img src="/images/saenai_13.png" width="50%" style="display: inline-block" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>深崎暮人笔下的体操服加藤和泳装加藤，丸户史明看图说话，前者“独占厨”甜的掉牙，后者海边洞窟留白无限遐想</em></td>
</tr>
</tbody>
</table>
<!-- 
![深崎暮人笔下的体操服加藤和泳装加藤，丸户史明看图说话，前者“独占厨”甜的掉牙，后者海边洞窟留白无限遐想](saenai 10&11.jpg) -->
<p>  并且短篇《不起眼 Fantasia 感谢祭 2017》，《不起眼 DRAGON MAGAZINE 2018 7月号》以及《不起眼代笔者担任法》可以明显看出，自从身为自己化身的霞之丘诗羽戏份减少后，本应为黄油作家的丸户史明老师将无处释放的 <strong>GHS欲望</strong> 终于转向了加藤和安艺两人。可以的，一看就知道丸户老师写面向青少年的轻小说憋得太久了，索性就在短篇放飞自我了，但是不要刚好停在关键的地方好吗？</p>
<blockquote>
<p>——欸，伦也。</p>
<p>——怎样啦？</p>
<p>——哪里有洞窟，要不要过去看看？</p>
<p>——什……</p>
<p>接着，她突然从正面看向我的眼睛，一面紧紧握住我的手，一面扔下了轻小说不该扔下的震撼弹。</p>
<p>……很遗憾，指定的字数写到这里就满了。</p>
<p>若有意见请洽交代格式的 Fantasia 文库编辑部。</p>
<p>——————————《不起眼 Fantasia 感谢祭 2017》</p>
<p><strong><em>最后的中断借口在短篇《不起眼 DRAGON MAGAZINE 2018 7月号》也有出现</em></strong>。</p>
</blockquote>
<blockquote>
<p>顺带一提，某项传统（新年第一〇）依习俗是在一月二日，因此这不能算在内。</p>
<p>——————————《不起眼代笔者担任法》</p>
<p><strong><em>该说不愧是 30 禁作者吗，前文交代了安艺认为新年第一天应该陪父母，这里刻意的马赛克加指代不明的”传统“让人浮想联翩 wwww。</em></strong></p>
</blockquote>
<p>  最后就是对于<strong>剧场版相关访谈</strong>方面。动画声优的采访让人感觉到一股子莫名的正经，脑子里面极容易会想起 FD 的第 2 篇（对应到 TV 第 1 季前几集）安艺采访诗羽的场景，就算不着边际的话也能改的很漂亮。老实说乐子挺少的，为啥不直接看生放送，公开调戏 “伦理君” 多有意思<em>（梅林腰上别着欧布圆环，手持破坏大剑，向我冲了过来）</em>。乐子较多还是导演，原作者和插画师关于剧场版 Fine 的专访，除了导演和插画师满满的干货，仍然延续了这作品企划之初专访的欢乐风格<em>（详情参见 memorial 1）</em>。</p>
<blockquote>
<p>至于丸户先生……连制作电视剧集时，好像也只提到过 “请容我对丝袜的描写说几句话。”……我记得的顶多就这样而已。</p>
<p>——————————龟井干太《导演&amp;原作者专访》</p>
<p><strong><em>不是，丸户老贼你到底有多执着于这个方面啊……另外，该说不愧是原作者的化身吗，谁是里之女主我就不用多说了吧，英梨梨？这人谁啊？（还要再玩这个梗吗？）</em></strong></p>
</blockquote>
<p>  原作者丸户史明的部分比起正经讲述，他的发言简直就是整活和名言的集合体，我随便拿出几段感受一下吧。</p>
<blockquote>
<p>我认为处男感越强的人，对那一幕（指数“1 2 3”后接吻的戏）越会有深刻感触。</p>
<p><strong><em>谢谢丸户老师，有被内涵到。</em></strong></p>
<p>这（指车站十字相扣）真的可以往电影里演吗？有的部分我也如此顾虑过，从那个角度来看，我认为这部电影不行算 “光明磊落” 的电影。</p>
<p><strong><em>我前面就吐槽过，既然知道的话就少出现一些这种令人误解的片段啊。</em></strong></p>
<p>我认为自己一直以来都不希望伦也被讨厌，也始终努力不让他被讨厌，但实在是不容易。果然伦也的性格就是不受管控。</p>
<p><strong><em>这究竟是谁的错啊？</em></strong></p>
<p>只不过，要求用 10 分钟左右的片长来演众角色成熟后的场景，就是出自我的任性了。而且连妄想题材都包括在内（笑）。</p>
<p><strong><em>《路人女主的养成方法：coda篇》堂堂连载！老实说，我当初看到那里真的被吓到。</em></strong></p>
<p>英梨梨落到这番地步真的很可怜呢。该说她错失了不少时机吗……还是错失机运和缘分呢？</p>
<p><strong><em>所<sub>以</sub>说~（敲黑板），这究竟是谁的错啊？</em></strong></p>
<p>———————————丸户史明《导演&amp;原作者专访》</p>
</blockquote>
<p>  丸户老师同时也透露了剧场版最后的彩蛋里面动画制作组和声优玩得很嗨的场景，深崎老师也透露了自己打算在《路主》画集上让英梨梨获得幸福<em>（看来还是生父疼亲女儿啊。莫非指的是第 9 卷的那个 if 结局？这样使得我不得不掏腰包买画集了吗）</em>。再次感谢各位创作者和参与者在《路主》这部作品上投入的心血了。</p>
<h2 id="尾声的尾声但愿这就是最后了">尾声的尾声（但愿这就是最后了）</h2>
<p>  新年的第一篇的博客到这里总算是写完了。俗话说“有了‘尾声一的尾声’，必然会有‘尾声二的尾声’和‘尾声X的尾声’”，为了避免这种事出现，所以这里就直接定义为“尾声的尾声”了。</p>
<p>  起初是打算写一些非宅的东西，但想想自己好像除了 ACGN 基本就是个白板<em>（唉，自己学习工作都是个白板就令我很无语）</em>，恰巧手上正好有这次的素材，自己看完又开始火力全开状态<em>（绝对不是因为催稿现成找的，绝对不是）</em>。</p>
<p>  这一次也破天荒地尝试了用 Typora 来写博客，以前都是用 Word 的，我为了适应新的工具在格式上花了挺多精力的，应该还能让人接受吧。</p>
<p>  下次还是打算久违地开开新坑吧，一月新番有我关注了很久的《弱势角色友崎君》，也一直没看完原作，追番的同时把小说给补了，没准也能写几篇呢？<em>（笑，好久没立过这样的 flag 了）</em></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>acg</category>
      </categories>
      <tags>
        <tag>lightnovel</tag>
      </tags>
  </entry>
</search>
